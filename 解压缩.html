<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DEFLATE分段压缩解压工具 - 支持文件夹压缩</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pako/2.1.0/pako.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        
        body {
            background-color: #f0f2f5;
            color: #333;
            line-height: 1.6;
            padding: 20px;
            min-height: 100vh;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
        }
        
        header {
            text-align: center;
            margin-bottom: 30px;
            padding-bottom: 20px;
            border-bottom: 2px solid #4a6ee0;
        }
        
        .logo {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 15px;
            margin-bottom: 15px;
        }
        
        .logo-icon {
            font-size: 2.5rem;
            color: #4a6ee0;
        }
        
        h1 {
            color: #2c3e50;
            font-size: 2.5rem;
            margin-bottom: 10px;
        }
        
        .subtitle {
            color: #7f8c8d;
            font-size: 1.1rem;
            max-width: 800px;
            margin: 0 auto;
        }
        
        .highlight {
            color: #4a6ee0;
            font-weight: bold;
        }
        
        .mode-selector {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
            justify-content: center;
        }
        
        .mode-btn {
            padding: 10px 20px;
            border: 2px solid #4a6ee0;
            background-color: white;
            color: #4a6ee0;
            border-radius: 6px;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.3s ease;
        }
        
        .mode-btn.active {
            background-color: #4a6ee0;
            color: white;
        }
        
        .mode-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
        }
        
        .app-container {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 30px;
            margin-bottom: 30px;
        }
        
        @media (max-width: 768px) {
            .app-container {
                grid-template-columns: 1fr;
            }
        }
        
        .card {
            background-color: white;
            border-radius: 12px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.08);
            padding: 25px;
            height: 100%;
            transition: transform 0.3s ease;
        }
        
        .card:hover {
            transform: translateY(-5px);
        }
        
        .card-title {
            font-size: 1.5rem;
            color: #2c3e50;
            margin-bottom: 20px;
            padding-bottom: 10px;
            border-bottom: 2px solid #eaeaea;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .card-title i {
            color: #4a6ee0;
        }
        
        .upload-area {
            border: 3px dashed #d1d8e0;
            border-radius: 10px;
            padding: 40px 20px;
            text-align: center;
            margin-bottom: 25px;
            cursor: pointer;
            transition: all 0.3s ease;
            position: relative;
        }
        
        .upload-area:hover {
            border-color: #4a6ee0;
            background-color: #f8f9ff;
        }
        
        .upload-icon {
            font-size: 3rem;
            color: #a5b1c2;
            margin-bottom: 15px;
        }
        
        .upload-text {
            font-size: 1.2rem;
            color: #7f8c8d;
            margin-bottom: 10px;
        }
        
        .folder-upload-hint {
            font-size: 0.9rem;
            color: #4a6ee0;
            margin-top: 10px;
            font-weight: 600;
        }
        
        .file-info {
            background-color: #f8f9fa;
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 20px;
            display: none;
        }
        
        .file-info.active {
            display: block;
        }
        
        .file-info-row {
            display: flex;
            justify-content: space-between;
            margin-bottom: 8px;
        }
        
        .folder-info {
            max-height: 200px;
            overflow-y: auto;
            margin-top: 10px;
        }
        
        .folder-item {
            padding: 5px 10px;
            border-bottom: 1px solid #eee;
            font-size: 0.9rem;
            display: flex;
            justify-content: space-between;
        }
        
        .folder-path {
            color: #666;
            font-family: monospace;
            word-break: break-all;
        }
        
        .folder-size {
            color: #4a6ee0;
            font-weight: bold;
            min-width: 80px;
            text-align: right;
        }
        
        .settings {
            margin-bottom: 25px;
        }
        
        .setting-group {
            margin-bottom: 20px;
        }
        
        .setting-label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
            color: #2c3e50;
        }
        
        .slider-container {
            display: flex;
            align-items: center;
            gap: 15px;
        }
        
        .slider-value {
            min-width: 60px;
            text-align: center;
            font-weight: bold;
            color: #4a6ee0;
        }
        
        input[type="range"] {
            flex-grow: 1;
            height: 8px;
            border-radius: 4px;
            background: #e0e0e0;
            outline: none;
            -webkit-appearance: none;
        }
        
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 22px;
            height: 22px;
            border-radius: 50%;
            background: #4a6ee0;
            cursor: pointer;
            border: 3px solid white;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
        }
        
        .buttons {
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
        }
        
        .btn {
            flex: 1;
            padding: 15px 20px;
            border: none;
            border-radius: 8px;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
            transition: all 0.3s ease;
            min-width: 150px;
        }
        
        .btn-primary {
            background-color: #4a6ee0;
            color: white;
        }
        
        .btn-primary:hover {
            background-color: #3a5ed0;
            transform: translateY(-2px);
        }
        
        .btn-secondary {
            background-color: #f0f2f5;
            color: #2c3e50;
        }
        
        .btn-secondary:hover {
            background-color: #e4e7eb;
        }
        
        .btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none !important;
        }
        
        .progress-section {
            margin-top: 25px;
        }
        
        .progress-header {
            display: flex;
            justify-content: space-between;
            margin-bottom: 10px;
        }
        
        .progress-label {
            font-weight: 600;
        }
        
        .progress-percentage {
            font-weight: bold;
            color: #4a6ee0;
        }
        
        .progress-bar {
            height: 12px;
            background-color: #e0e0e0;
            border-radius: 6px;
            overflow: hidden;
        }
        
        .progress-fill {
            height: 100%;
            background-color: #4a6ee0;
            width: 0%;
            transition: width 0.3s ease;
            border-radius: 6px;
        }
        
        .segments-container {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(80px, 1fr));
            gap: 10px;
            margin-top: 15px;
        }
        
        .segment {
            height: 30px;
            background-color: #e0e0e0;
            border-radius: 6px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.8rem;
            font-weight: 600;
            transition: all 0.3s ease;
        }
        
        .segment.processed {
            background-color: #4a6ee0;
            color: white;
        }
        
        .segment.compressing {
            background-color: #7d9eff;
            color: white;
        }
        
        .result-section {
            margin-top: 25px;
            padding-top: 20px;
            border-top: 2px solid #eaeaea;
            display: none;
        }
        
        .result-section.active {
            display: block;
        }
        
        .result-info {
            background-color: #f0f7ff;
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 20px;
        }
        
        .result-row {
            display: flex;
            justify-content: space-between;
            margin-bottom: 10px;
        }
        
        .compression-ratio {
            color: #27ae60;
            font-weight: bold;
        }
        
        .time-saved {
            color: #e74c3c;
            font-weight: bold;
        }
        
        .algorithm-info {
            background-color: #f8f9fa;
            border-radius: 12px;
            padding: 25px;
            margin-top: 30px;
        }
        
        .algorithm-info h3 {
            color: #2c3e50;
            margin-bottom: 15px;
            font-size: 1.5rem;
        }
        
        .info-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            margin-top: 20px;
        }
        
        .info-item {
            padding: 15px;
            background-color: white;
            border-radius: 8px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.05);
        }
        
        .info-item h4 {
            color: #4a6ee0;
            margin-bottom: 10px;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        footer {
            text-align: center;
            margin-top: 50px;
            padding-top: 20px;
            border-top: 1px solid #ddd;
            color: #7f8c8d;
            font-size: 0.9rem;
        }
        
        .loading {
            display: none;
            text-align: center;
            margin: 20px 0;
        }
        
        .loading.active {
            display: block;
        }
        
        .spinner {
            border: 5px solid #f3f3f3;
            border-top: 5px solid #4a6ee0;
            border-radius: 50%;
            width: 50px;
            height: 50px;
            animation: spin 1s linear infinite;
            margin: 0 auto 15px;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        .toast {
            position: fixed;
            bottom: 20px;
            right: 20px;
            background-color: #27ae60;
            color: white;
            padding: 15px 25px;
            border-radius: 8px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.2);
            display: flex;
            align-items: center;
            gap: 10px;
            transform: translateY(100px);
            opacity: 0;
            transition: all 0.3s ease;
            z-index: 1000;
        }
        
        .toast.show {
            transform: translateY(0);
            opacity: 1;
        }
        
        .toast.error {
            background-color: #e74c3c;
        }
        
        .toast.warning {
            background-color: #f39c12;
        }
        
        .performance-metrics {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 15px;
            margin-top: 20px;
        }
        
        .metric {
            background-color: #f8f9fa;
            padding: 15px;
            border-radius: 8px;
            text-align: center;
        }
        
        .metric-value {
            font-size: 1.5rem;
            font-weight: bold;
            color: #4a6ee0;
            margin-bottom: 5px;
        }
        
        .metric-label {
            font-size: 0.9rem;
            color: #7f8c8d;
        }
        
        @media (max-width: 768px) {
            .performance-metrics {
                grid-template-columns: 1fr;
            }
            
            .buttons {
                flex-direction: column;
            }
            
            .btn {
                width: 100%;
            }
        }
        
        .format-selector {
            margin-bottom: 20px;
            display: flex;
            gap: 15px;
            align-items: center;
        }
        
        .format-option {
            display: flex;
            align-items: center;
            gap: 5px;
            cursor: pointer;
        }
        
        .format-radio {
            accent-color: #4a6ee0;
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <div class="logo">
                <i class="fas fa-file-archive logo-icon"></i>
                <h1>DEFLATE分段压缩解压工具</h1>
            </div>
            <p class="subtitle">支持<span class="highlight">单个文件压缩</span>和<span class="highlight">文件夹打包压缩</span>，基于pako.js和JSZip实现</p>
        </header>
        
        <div class="mode-selector" id="mode-selector">
            <button class="mode-btn active" data-mode="single">单个文件压缩</button>
            <button class="mode-btn" data-mode="folder">文件夹压缩</button>
        </div>
        
        <div class="app-container">
            <!-- 压缩部分 -->
            <div class="card">
                <h2 class="card-title"><i class="fas fa-compress-alt"></i> 压缩文件</h2>
                
                <div class="format-selector" id="compress-format-selector">
                    <div class="format-option">
                        <input type="radio" id="format-deflate" name="compress-format" class="format-radio" value="deflate" checked>
                        <label for="format-deflate">DEFLATE格式（单个文件）</label>
                    </div>
                    <div class="format-option">
                        <input type="radio" id="format-zip" name="compress-format" class="format-radio" value="zip">
                        <label for="format-zip">ZIP格式（支持文件夹）</label>
                    </div>
                </div>
                
                <div class="upload-area" id="compress-upload">
                    <i class="fas fa-cloud-upload-alt upload-icon"></i>
                    <p class="upload-text" id="compress-upload-text">点击或拖拽文件到此处上传</p>
                    <p id="compress-upload-hint">支持所有文件类型</p>
                    <p class="folder-upload-hint" id="folder-hint" style="display: none;">
                        <i class="fas fa-folder-open"></i> 可选择整个文件夹（需使用文件夹选择模式）
                    </p>
                </div>
                
                <div class="file-info" id="compress-file-info">
                    <div class="file-info-row">
                        <span>文件/文件夹:</span>
                        <span id="compress-filename">未选择</span>
                    </div>
                    <div class="file-info-row">
                        <span>文件数量:</span>
                        <span id="compress-filecount">0</span>
                    </div>
                    <div class="file-info-row">
                        <span>总大小:</span>
                        <span id="compress-filesize">0 KB</span>
                    </div>
                    <div class="file-info-row">
                        <span>压缩格式:</span>
                        <span id="compress-filetype">DEFLATE</span>
                    </div>
                    
                    <div class="folder-info" id="folder-info" style="display: none;"></div>
                </div>
                
                <div class="settings">
                    <div class="setting-group">
                        <label class="setting-label">分段大小 (KB)</label>
                        <div class="slider-container">
                            <input type="range" id="chunk-size" min="64" max="2048" value="512" step="64">
                            <span class="slider-value" id="chunk-size-value">512 KB</span>
                        </div>
                        <p class="setting-description">较小的分段可以提高处理速度，但可能降低压缩率</p>
                    </div>
                    
                    <div class="setting-group">
                        <label class="setting-label">压缩级别</label>
                        <div class="slider-container">
                            <input type="range" id="compression-level" min="1" max="9" value="6">
                            <span class="slider-value" id="compression-level-value">6 (平衡)</span>
                        </div>
                        <p class="setting-description">级别越高压缩率越好，但处理时间更长</p>
                    </div>
                    
                    <div class="performance-metrics" id="compress-metrics" style="display: none;">
                        <div class="metric">
                            <div class="metric-value" id="compress-speed">0</div>
                            <div class="metric-label">压缩速度 (KB/s)</div>
                        </div>
                        <div class="metric">
                            <div class="metric-value" id="memory-usage">0</div>
                            <div class="metric-label">内存使用 (MB)</div>
                        </div>
                        <div class="metric">
                            <div class="metric-value" id="throughput">0</div>
                            <div class="metric-label">吞吐量 (MB/s)</div>
                        </div>
                    </div>
                </div>
                
                <div class="buttons">
                    <button class="btn btn-primary" id="compress-btn">
                        <i class="fas fa-compress-alt"></i> 开始压缩
                    </button>
                    <button class="btn btn-secondary" id="cancel-compress-btn" disabled>
                        <i class="fas fa-stop-circle"></i> 取消
                    </button>
                    <button class="btn btn-secondary" id="test-compress">
                        <i class="fas fa-vial"></i> 测试压缩
                    </button>
                </div>
                
                <div class="loading" id="compress-loading">
                    <div class="spinner"></div>
                    <p>正在压缩文件，请稍候...</p>
                </div>
                
                <div class="progress-section">
                    <div class="progress-header">
                        <span class="progress-label">压缩进度</span>
                        <span class="progress-percentage" id="compress-percentage">0%</span>
                    </div>
                    <div class="progress-bar">
                        <div class="progress-fill" id="compress-progress"></div>
                    </div>
                    
                    <div class="segments-container" id="compress-segments"></div>
                </div>
                
                <div class="result-section" id="compress-result">
                    <div class="result-info">
                        <div class="result-row">
                            <span>压缩后大小:</span>
                            <span id="compressed-size">0 KB</span>
                        </div>
                        <div class="result-row">
                            <span>压缩率:</span>
                            <span class="compression-ratio" id="compression-ratio">0%</span>
                        </div>
                        <div class="result-row">
                            <span>处理时间:</span>
                            <span id="compress-time">0 秒</span>
                        </div>
                        <div class="result-row">
                            <span>文件数量:</span>
                            <span id="segment-count">0</span>
                        </div>
                        <div class="result-row">
                            <span>平均压缩速度:</span>
                            <span id="avg-compress-speed">0 KB/s</span>
                        </div>
                    </div>
                    
                    <div class="buttons">
                        <button class="btn btn-primary" id="download-compressed">
                            <i class="fas fa-download"></i> 下载压缩文件
                        </button>
                    </div>
                </div>
            </div>
            
            <!-- 解压部分 -->
            <div class="card">
                <h2 class="card-title"><i class="fas fa-expand-alt"></i> 解压文件</h2>
                
                <div class="upload-area" id="decompress-upload">
                    <i class="fas fa-cloud-upload-alt upload-icon"></i>
                    <p class="upload-text">点击或拖拽压缩文件到此处上传</p>
                    <p>支持 .deflate 和 .zip 格式</p>
                </div>
                
                <div class="file-info" id="decompress-file-info">
                    <div class="file-info-row">
                        <span>文件名:</span>
                        <span id="decompress-filename">未选择文件</span>
                    </div>
                    <div class="file-info-row">
                        <span>文件大小:</span>
                        <span id="decompress-filesize">0 KB</span>
                    </div>
                    <div class="file-info-row">
                        <span>压缩格式:</span>
                        <span id="decompress-format">未知</span>
                    </div>
                    <div class="file-info-row" id="zip-content-info" style="display: none;">
                        <span>ZIP内容:</span>
                        <span id="zip-filecount">0 个文件</span>
                    </div>
                </div>
                
                <div class="performance-metrics" id="decompress-metrics" style="display: none;">
                    <div class="metric">
                        <div class="metric-value" id="decompress-speed">0</div>
                        <div class="metric-label">解压速度 (KB/s)</div>
                    </div>
                    <div class="metric">
                        <div class="metric-value" id="decompress-memory">0</div>
                        <div class="metric-label">内存使用 (MB)</div>
                    </div>
                    <div class="metric">
                        <div class="metric-value" id="decompress-throughput">0</div>
                        <div class="metric-label">吞吐量 (MB/s)</div>
                    </div>
                </div>
                
                <div class="buttons">
                    <button class="btn btn-primary" id="decompress-btn">
                        <i class="fas fa-expand-alt"></i> 开始解压
                    </button>
                    <button class="btn btn-secondary" id="cancel-decompress-btn" disabled>
                        <i class="fas fa-stop-circle"></i> 取消
                    </button>
                    <button class="btn btn-secondary" id="test-decompress">
                        <i class="fas fa-vial"></i> 测试解压
                    </button>
                </div>
                
                <div class="loading" id="decompress-loading">
                    <div class="spinner"></div>
                    <p>正在解压文件，请稍候...</p>
                </div>
                
                <div class="progress-section">
                    <div class="progress-header">
                        <span class="progress-label">解压进度</span>
                        <span class="progress-percentage" id="decompress-percentage">0%</span>
                    </div>
                    <div class="progress-bar">
                        <div class="progress-fill" id="decompress-progress"></div>
                    </div>
                    
                    <div class="segments-container" id="decompress-segments"></div>
                </div>
                
                <div class="result-section" id="decompress-result">
                    <div class="result-info">
                        <div class="result-row">
                            <span>解压后大小:</span>
                            <span id="decompressed-size">0 KB</span>
                        </div>
                        <div class="result-row">
                            <span>文件/文件夹:</span>
                            <span id="original-filename">未知</span>
                        </div>
                        <div class="result-row">
                            <span>处理时间:</span>
                            <span id="decompress-time">0 秒</span>
                        </div>
                        <div class="result-row">
                            <span>文件数量:</span>
                            <span id="decompress-segment-count">0</span>
                        </div>
                        <div class="result-row">
                            <span>平均解压速度:</span>
                            <span id="avg-decompress-speed">0 KB/s</span>
                        </div>
                    </div>
                    
                    <div class="buttons">
                        <button class="btn btn-primary" id="download-decompressed">
                            <i class="fas fa-download"></i> 下载解压文件
                        </button>
                        <button class="btn btn-secondary" id="download-zip-folder" style="display: none;">
                            <i class="fas fa-folder-download"></i> 下载ZIP包
                        </button>
                    </div>
                </div>
            </div>
        </div>
        
        <div class="algorithm-info">
            <h3>DEFLATE分段压缩算法 - 支持文件夹压缩</h3>
            <p>本工具使用pako.js实现DEFLATE算法，JSZip库实现ZIP格式，支持两种压缩模式：</p>
            
            <div class="info-grid">
                <div class="info-item">
                    <h4><i class="fas fa-file"></i> 单个文件压缩</h4>
                    <p>使用DEFLATE算法直接压缩单个文件，生成.deflate格式文件，保持原始DEFLATE压缩率。</p>
                </div>
                <div class="info-item">
                    <h4><i class="fas fa-folder"></i> 文件夹压缩</h4>
                    <p>使用JSZip库打包文件夹，内部使用DEFLATE算法压缩每个文件，生成标准ZIP格式文件。</p>
                </div>
                <div class="info-item">
                    <h4><i class="fas fa-sitemap"></i> 文件夹结构保持</h4>
                    <p>ZIP格式能够保持文件夹层级结构，解压后可以恢复原始目录布局。</p>
                </div>
                <div class="info-item">
                    <h4><i class="fas fa-shield-alt"></i> 浏览器安全限制</h4>
                    <p>由于浏览器安全限制，不能直接读取文件夹，需要通过特殊方法获取文件夹内容。</p>
                </div>
            </div>
        </div>
        
        <footer>
            <p>DEFLATE分段压缩解压工具 &copy; 2023 | 支持单个文件和文件夹压缩</p>
            <p>注意：由于浏览器安全限制，文件夹压缩需要用户主动选择文件夹，不能自动遍历目录</p>
        </footer>
    </div>
    
    <div class="toast" id="toast"></div>

    <script>
        // 全局变量
        let compressFile = null;
        let compressFiles = []; // 用于存储多个文件（文件夹）
        let decompressFile = null;
        let compressMode = 'single'; // 'single' 或 'folder'
        let compressFormat = 'deflate'; // 'deflate' 或 'zip'
        let isCompressing = false;
        let isDecompressing = false;
        let compressCancelled = false;
        let decompressCancelled = false;
        let compressStartTime = 0;
        
        // DOM元素
        const compressUpload = document.getElementById('compress-upload');
        const decompressUpload = document.getElementById('decompress-upload');
        const compressFileInfo = document.getElementById('compress-file-info');
        const decompressFileInfo = document.getElementById('decompress-file-info');
        const compressBtn = document.getElementById('compress-btn');
        const decompressBtn = document.getElementById('decompress-btn');
        const cancelCompressBtn = document.getElementById('cancel-compress-btn');
        const cancelDecompressBtn = document.getElementById('cancel-decompress-btn');
        const compressLoading = document.getElementById('compress-loading');
        const decompressLoading = document.getElementById('decompress-loading');
        const compressResult = document.getElementById('compress-result');
        const decompressResult = document.getElementById('decompress-result');
        const compressSegments = document.getElementById('compress-segments');
        const decompressSegments = document.getElementById('decompress-segments');
        const chunkSizeSlider = document.getElementById('chunk-size');
        const chunkSizeValue = document.getElementById('chunk-size-value');
        const compressionLevelSlider = document.getElementById('compression-level');
        const compressionLevelValue = document.getElementById('compression-level-value');
        const compressMetrics = document.getElementById('compress-metrics');
        const decompressMetrics = document.getElementById('decompress-metrics');
        const toast = document.getElementById('toast');
        const folderInfo = document.getElementById('folder-info');
        const folderHint = document.getElementById('folder-hint');
        const compressUploadText = document.getElementById('compress-upload-text');
        const compressUploadHint = document.getElementById('compress-upload-hint');
        const modeSelector = document.getElementById('mode-selector');
        const compressFormatSelector = document.getElementById('compress-format-selector');
        
        // 初始化
        document.addEventListener('DOMContentLoaded', function() {
            // 设置滑块值显示
            chunkSizeSlider.addEventListener('input', updateChunkSizeValue);
            compressionLevelSlider.addEventListener('input', updateCompressionLevelValue);
            
            // 初始化显示值
            updateChunkSizeValue();
            updateCompressionLevelValue();
            
            // 文件上传事件
            setupFileUpload(compressUpload, handleCompressFileUpload);
            setupFileUpload(decompressUpload, handleDecompressFileUpload);
            
            // 模式选择
            modeSelector.addEventListener('click', (e) => {
                if (e.target.classList.contains('mode-btn')) {
                    const mode = e.target.dataset.mode;
                    setCompressMode(mode);
                }
            });
            
            // 格式选择
            compressFormatSelector.addEventListener('change', (e) => {
                if (e.target.name === 'compress-format') {
                    compressFormat = e.target.value;
                    updateFormatDisplay();
                }
            });
            
            // 按钮事件
            compressBtn.addEventListener('click', startCompression);
            decompressBtn.addEventListener('click', startDecompression);
            cancelCompressBtn.addEventListener('click', cancelCompression);
            cancelDecompressBtn.addEventListener('click', cancelDecompression);
            
            document.getElementById('download-compressed').addEventListener('click', downloadCompressedFile);
            document.getElementById('download-decompressed').addEventListener('click', downloadDecompressedFile);
            document.getElementById('download-zip-folder').addEventListener('click', downloadZipFolder);
            document.getElementById('test-compress').addEventListener('click', generateTestFiles);
            document.getElementById('test-decompress').addEventListener('click', testDecompression);
            
            // 初始化分段显示
            updateSegmentsDisplay(compressSegments, 0);
            updateSegmentsDisplay(decompressSegments, 0);
            
            // 初始化性能监控
            initPerformanceMonitoring();
            
            showToast('DEFLATE压缩解压工具已加载，支持文件夹压缩', 'warning');
        });
        
        // 设置压缩模式
        function setCompressMode(mode) {
            compressMode = mode;
            
            // 更新按钮状态
            document.querySelectorAll('.mode-btn').forEach(btn => {
                btn.classList.remove('active');
            });
            document.querySelector(`[data-mode="${mode}"]`).classList.add('active');
            
            // 更新界面显示
            if (mode === 'folder') {
                compressUploadText.textContent = '点击或拖拽文件夹到此处上传';
                compressUploadHint.textContent = '支持选择整个文件夹';
                folderHint.style.display = 'block';
                document.getElementById('format-zip').checked = true;
                compressFormat = 'zip';
            } else {
                compressUploadText.textContent = '点击或拖拽文件到此处上传';
                compressUploadHint.textContent = '支持所有文件类型';
                folderHint.style.display = 'none';
            }
            
            updateFormatDisplay();
            
            // 清空之前的选择
            compressFile = null;
            compressFiles = [];
            compressFileInfo.classList.remove('active');
            folderInfo.style.display = 'none';
            compressBtn.disabled = true;
            
            showToast(`已切换到${mode === 'folder' ? '文件夹' : '单个文件'}压缩模式`);
        }
        
        // 更新格式显示
        function updateFormatDisplay() {
            document.getElementById('compress-filetype').textContent = 
                compressFormat === 'zip' ? 'ZIP（支持文件夹）' : 'DEFLATE（单个文件）';
        }
        
        // 更新分段大小显示
        function updateChunkSizeValue() {
            const value = chunkSizeSlider.value;
            chunkSizeValue.textContent = `${value} KB`;
        }
        
        // 更新压缩级别显示
        function updateCompressionLevelValue() {
            const value = compressionLevelSlider.value;
            let levelText = '';
            if (value <= 3) levelText = '快速';
            else if (value <= 6) levelText = '平衡';
            else levelText = '最佳';
            
            compressionLevelValue.textContent = `${value} (${levelText})`;
        }
        
        // 设置文件上传区域
        function setupFileUpload(uploadArea, callback) {
            // 点击上传
            uploadArea.addEventListener('click', () => {
                const input = document.createElement('input');
                input.type = 'file';
                
                if (uploadArea.id === 'decompress-upload') {
                    input.accept = '.deflate,.zip,.gz';
                } else if (compressMode === 'folder') {
                    // 文件夹选择模式
                    input.setAttribute('webkitdirectory', '');
                    input.setAttribute('directory', '');
                    input.setAttribute('multiple', '');
                } else {
                    input.accept = '*';
                    input.multiple = compressFormat === 'zip'; // ZIP格式允许多文件
                }
                
                input.click();
                
                input.addEventListener('change', (e) => {
                    if (e.target.files.length > 0) {
                        callback(e.target.files);
                    }
                });
            });
            
            // 拖拽上传
            uploadArea.addEventListener('dragover', (e) => {
                e.preventDefault();
                uploadArea.style.borderColor = '#4a6ee0';
                uploadArea.style.backgroundColor = '#f8f9ff';
            });
            
            uploadArea.addEventListener('dragleave', (e) => {
                e.preventDefault();
                uploadArea.style.borderColor = '#d1d8e0';
                uploadArea.style.backgroundColor = 'white';
            });
            
            uploadArea.addEventListener('drop', (e) => {
                e.preventDefault();
                uploadArea.style.borderColor = '#d1d8e0';
                uploadArea.style.backgroundColor = 'white';
                
                if (e.dataTransfer.items) {
                    // 处理文件夹拖拽（仅限Chrome）
                    const items = e.dataTransfer.items;
                    const files = [];
                    
                    for (let i = 0; i < items.length; i++) {
                        const item = items[i];
                        if (item.kind === 'file') {
                            const entry = item.webkitGetAsEntry();
                            if (entry) {
                                if (entry.isFile) {
                                    files.push(item.getAsFile());
                                } else if (entry.isDirectory && compressMode === 'folder') {
                                    // 处理文件夹
                                    traverseDirectory(entry, '', files).then(() => {
                                        callback(files);
                                    });
                                    return;
                                }
                            }
                        }
                    }
                    
                    if (files.length > 0) {
                        callback(files);
                    }
                } else if (e.dataTransfer.files.length > 0) {
                    callback(e.dataTransfer.files);
                }
            });
        }
        
        // 遍历目录（用于拖拽文件夹）
        async function traverseDirectory(entry, path, fileList) {
            if (entry.isFile) {
                return new Promise((resolve) => {
                    entry.file((file) => {
                        file.relativePath = path + file.name;
                        fileList.push(file);
                        resolve();
                    });
                });
            } else if (entry.isDirectory) {
                const dirReader = entry.createReader();
                const entries = await new Promise((resolve) => {
                    dirReader.readEntries(resolve);
                });
                
                for (let i = 0; i < entries.length; i++) {
                    await traverseDirectory(entries[i], path + entry.name + '/', fileList);
                }
            }
        }
        
        // 处理压缩文件上传
        function handleCompressFileUpload(files) {
            if (compressMode === 'single' && compressFormat === 'deflate') {
                // 单个文件DEFLATE模式
                if (files.length > 1) {
                    showToast('DEFLATE格式只支持单个文件，已选择第一个文件', 'warning');
                }
                compressFile = files[0];
                compressFiles = [compressFile];
                
                updateSingleFileInfo(compressFile);
            } else {
                // 多文件或ZIP模式
                compressFiles = Array.from(files);
                
                if (compressMode === 'single' && compressFiles.length === 1) {
                    compressFile = compressFiles[0];
                    updateSingleFileInfo(compressFile);
                } else {
                    updateMultipleFilesInfo(compressFiles);
                }
            }
            
            compressFileInfo.classList.add('active');
            compressBtn.disabled = false;
            compressResult.classList.remove('active');
            
            // 计算分段数量并更新显示（对于多文件，显示文件数量）
            const chunkCount = compressFiles.length;
            updateSegmentsDisplay(compressSegments, Math.min(chunkCount, 50)); // 最多显示50个分段
            
            showToast(`已选择${compressFiles.length}个文件，可以开始压缩`);
        }
        
        // 更新单个文件信息
        function updateSingleFileInfo(file) {
            document.getElementById('compress-filename').textContent = file.name;
            document.getElementById('compress-filecount').textContent = '1';
            document.getElementById('compress-filesize').textContent = formatFileSize(file.size);
            document.getElementById('compress-filetype').textContent = 
                compressFormat === 'zip' ? 'ZIP（单个文件）' : 'DEFLATE';
            
            folderInfo.style.display = 'none';
        }
        
        // 更新多个文件信息
        function updateMultipleFilesInfo(files) {
            const totalSize = files.reduce((sum, file) => sum + file.size, 0);
            const folderName = files.length > 0 ? 
                (files[0].webkitRelativePath ? files[0].webkitRelativePath.split('/')[0] : '文件夹') : 
                '文件夹';
            
            document.getElementById('compress-filename').textContent = `${folderName} (${files.length}个文件)`;
            document.getElementById('compress-filecount').textContent = files.length;
            document.getElementById('compress-filesize').textContent = formatFileSize(totalSize);
            document.getElementById('compress-filetype').textContent = 'ZIP（多文件）';
            
            // 显示文件列表（最多显示10个）
            folderInfo.innerHTML = '';
            const maxDisplay = 10;
            for (let i = 0; i < Math.min(files.length, maxDisplay); i++) {
                const file = files[i];
                const div = document.createElement('div');
                div.className = 'folder-item';
                div.innerHTML = `
                    <span class="folder-path">${file.name || file.webkitRelativePath || `文件${i+1}`}</span>
                    <span class="folder-size">${formatFileSize(file.size)}</span>
                `;
                folderInfo.appendChild(div);
            }
            
            if (files.length > maxDisplay) {
                const div = document.createElement('div');
                div.className = 'folder-item';
                div.innerHTML = `<span class="folder-path">... 还有${files.length - maxDisplay}个文件</span>`;
                folderInfo.appendChild(div);
            }
            
            folderInfo.style.display = 'block';
        }
        
        // 处理解压文件上传
        function handleDecompressFileUpload(files) {
            if (files.length > 1) {
                showToast('每次只能解压一个文件，已选择第一个文件', 'warning');
            }
            
            decompressFile = files[0];
            
            // 更新文件信息显示
            document.getElementById('decompress-filename').textContent = decompressFile.name;
            document.getElementById('decompress-filesize').textContent = formatFileSize(decompressFile.size);
            
            // 检测文件格式
            const fileName = decompressFile.name.toLowerCase();
            let format = '未知';
            if (fileName.endsWith('.deflate')) {
                format = 'DEFLATE 格式';
                document.getElementById('zip-content-info').style.display = 'none';
            } else if (fileName.endsWith('.zip')) {
                format = 'ZIP 格式';
                // 尝试读取ZIP文件信息
                readZipInfo(decompressFile);
            } else {
                format = '未知格式（尝试作为DEFLATE处理）';
                document.getElementById('zip-content-info').style.display = 'none';
            }
            
            document.getElementById('decompress-format').textContent = format;
            
            decompressFileInfo.classList.add('active');
            decompressBtn.disabled = false;
            decompressResult.classList.remove('active');
            
            showToast(`压缩文件 "${decompressFile.name}" 已准备就绪，可以开始解压`);
        }
        
        // 读取ZIP文件信息
        async function readZipInfo(file) {
            try {
                const arrayBuffer = await readFileAsArrayBuffer(file);
                const zip = await JSZip.loadAsync(arrayBuffer);
                const fileCount = Object.keys(zip.files).length;
                document.getElementById('zip-filecount').textContent = `${fileCount} 个文件`;
                document.getElementById('zip-content-info').style.display = 'flex';
            } catch (error) {
                console.error('读取ZIP信息失败:', error);
            }
        }
        
        // 开始压缩
        async function startCompression() {
            if ((compressMode === 'single' && !compressFile) || 
                (compressMode === 'folder' && compressFiles.length === 0) ||
                isCompressing) return;
            
            isCompressing = true;
            compressCancelled = false;
            compressBtn.disabled = true;
            cancelCompressBtn.disabled = false;
            compressLoading.classList.add('active');
            compressResult.classList.remove('active');
            compressMetrics.style.display = 'grid';
            
            // 重置进度和性能监控
            updateProgress('compress', 0);
            resetPerformanceMetrics('compress');
            
            // 开始计时
            compressStartTime = Date.now();
            
            try {
                let compressedFile;
                
                if (compressFormat === 'zip' || compressFiles.length > 1) {
                    // 使用ZIP格式压缩（多文件或文件夹）
                    compressedFile = await compressWithZip();
                } else {
                    // 使用DEFLATE格式压缩（单个文件）
                    compressedFile = await compressWithDeflate();
                }
                
                if (!compressCancelled) {
                    // 完成压缩
                    finishCompression(compressedFile);
                }
                
            } catch (error) {
                if (error.message === '压缩已取消') {
                    showToast('压缩已取消', 'error');
                } else {
                    console.error('压缩失败:', error);
                    showToast('压缩失败: ' + error.message, 'error');
                }
                
                isCompressing = false;
                compressBtn.disabled = false;
                cancelCompressBtn.disabled = true;
                compressLoading.classList.remove('active');
            }
        }
        
        // 使用DEFLATE压缩单个文件
        async function compressWithDeflate() {
            if (!compressFile) throw new Error('没有选择文件');
            
            const chunkSize = parseInt(chunkSizeSlider.value) * 1024;
            const compressionLevel = parseInt(compressionLevelSlider.value);
            const chunkCount = Math.ceil(compressFile.size / chunkSize);
            
            // 更新分段显示
            updateSegmentsDisplay(compressSegments, chunkCount);
            
            // 读取文件为ArrayBuffer
            const arrayBuffer = await readFileAsArrayBuffer(compressFile);
            
            // 创建文件头
            const header = {
                MAGIC: "DFLT",
                VERSION: 1,
                ORIGINAL_FILE_NAME: compressFile.name,
                ORIGINAL_FILE_SIZE: compressFile.size,
                SEGMENT_COUNT: chunkCount,
                SEGMENTS: []
            };
            
            // 分段压缩
            const compressedChunks = [];
            let totalCompressedSize = 0;
            let processedBytes = 0;
            
            for (let i = 0; i < chunkCount; i++) {
                if (compressCancelled) {
                    throw new Error('压缩已取消');
                }
                
                // 计算当前分段的偏移量和大小
                const start = i * chunkSize;
                const end = Math.min(start + chunkSize, compressFile.size);
                const chunkLength = end - start;
                
                // 获取当前分段的数据
                const chunkData = arrayBuffer.slice(start, end);
                
                // 更新分段显示状态
                updateSegmentStatus(compressSegments, i, 'compressing');
                
                // 使用pako进行DEFLATE压缩
                const compressedData = pako.deflate(new Uint8Array(chunkData), { level: compressionLevel });
                
                // 更新性能监控
                processedBytes += chunkLength;
                updatePerformanceMetrics('compress', processedBytes, compressStartTime);
                
                // 保存压缩后的数据和分段信息
                compressedChunks.push(compressedData);
                header.SEGMENTS.push({
                    originalSize: chunkLength,
                    compressedSize: compressedData.length,
                    offset: totalCompressedSize
                });
                
                totalCompressedSize += compressedData.length;
                
                // 更新进度
                const progress = Math.round(((i + 1) / chunkCount) * 100);
                updateProgress('compress', progress);
                
                // 更新分段显示状态
                updateSegmentStatus(compressSegments, i, 'processed');
                
                // 让出控制权，避免UI阻塞
                await delay(10);
            }
            
            // 构建最终文件
            return createCompressedFile(header, compressedChunks, '.deflate');
        }
        
        // 使用ZIP压缩多个文件
        async function compressWithZip() {
            if (compressFiles.length === 0) throw new Error('没有选择文件');
            
            const compressionLevel = parseInt(compressionLevelSlider.value);
            
            // 更新分段显示（每个文件一个分段）
            updateSegmentsDisplay(compressSegments, Math.min(compressFiles.length, 50));
            
            // 创建ZIP实例
            const zip = new JSZip();
            let processedFiles = 0;
            let totalOriginalSize = 0;
            let totalCompressedSize = 0;
            
            // 添加文件到ZIP
            for (let i = 0; i < compressFiles.length; i++) {
                if (compressCancelled) {
                    throw new Error('压缩已取消');
                }
                
                const file = compressFiles[i];
                totalOriginalSize += file.size;
                
                // 更新分段显示状态
                if (i < 50) {
                    updateSegmentStatus(compressSegments, i, 'compressing');
                }
                
                try {
                    // 读取文件内容
                    const arrayBuffer = await readFileAsArrayBuffer(file);
                    
                    // 确定文件在ZIP中的路径
                    let filePath = file.name;
                    if (file.webkitRelativePath) {
                        filePath = file.webkitRelativePath;
                    } else if (compressFiles.length > 1) {
                        // 如果是多个单独文件，放在根目录
                        filePath = file.name;
                    }
                    
                    // 添加到ZIP（JSZip内部使用DEFLATE算法）
                    zip.file(filePath, arrayBuffer, {
                        compression: "DEFLATE",
                        compressionOptions: {
                            level: compressionLevel
                        }
                    });
                    
                    // 更新进度
                    processedFiles++;
                    const progress = Math.round((processedFiles / compressFiles.length) * 100);
                    updateProgress('compress', progress);
                    
                    // 更新性能监控
                    updatePerformanceMetrics('compress', totalOriginalSize, compressStartTime);
                    
                    // 更新分段显示状态
                    if (i < 50) {
                        updateSegmentStatus(compressSegments, i, 'processed');
                    }
                    
                    // 让出控制权，避免UI阻塞
                    await delay(10);
                    
                } catch (error) {
                    console.error(`处理文件 ${file.name} 失败:`, error);
                    // 继续处理其他文件
                }
            }
            
            // 生成ZIP文件
            const zipContent = await zip.generateAsync({
                type: "blob",
                compression: "DEFLATE",
                compressionOptions: {
                    level: compressionLevel
                }
            });
            
            totalCompressedSize = zipContent.size;
            
            // 保存统计信息
            window.compressionStats = {
                originalSize: totalOriginalSize,
                compressedSize: totalCompressedSize,
                fileCount: compressFiles.length,
                format: 'zip'
            };
            
            return zipContent;
        }
        
        // 创建压缩文件（DEFLATE格式）
        function createCompressedFile(header, compressedChunks, extension = '.deflate') {
            // 将头部转换为JSON字符串
            const headerStr = JSON.stringify(header);
            const headerEncoder = new TextEncoder();
            const headerData = headerEncoder.encode(headerStr);
            
            // 计算头部长度（4字节）
            const headerLength = headerData.length;
            const headerLengthArray = new Uint8Array(4);
            new DataView(headerLengthArray.buffer).setUint32(0, headerLength, true);
            
            // 计算总大小
            let totalSize = 4 + headerLength; // 头部长度 + 头部数据
            for (const chunk of compressedChunks) {
                totalSize += chunk.length;
            }
            
            // 创建ArrayBuffer
            const finalBuffer = new ArrayBuffer(totalSize);
            const finalArray = new Uint8Array(finalBuffer);
            
            // 写入头部长度
            let offset = 0;
            finalArray.set(headerLengthArray, offset);
            offset += 4;
            
            // 写入头部数据
            finalArray.set(headerData, offset);
            offset += headerLength;
            
            // 写入所有压缩数据
            for (const chunk of compressedChunks) {
                finalArray.set(chunk, offset);
                offset += chunk.length;
            }
            
            const fileName = compressFile ? compressFile.name : 'compressed';
            return new Blob([finalBuffer], { type: 'application/octet-stream' });
        }
        
        // 开始解压
        async function startDecompression() {
            if (!decompressFile || isDecompressing) return;
            
            isDecompressing = true;
            decompressCancelled = false;
            decompressBtn.disabled = true;
            cancelDecompressBtn.disabled = false;
            decompressLoading.classList.add('active');
            decompressResult.classList.remove('active');
            decompressMetrics.style.display = 'grid';
            
            // 重置进度和性能监控
            updateProgress('decompress', 0);
            resetPerformanceMetrics('decompress');
            
            // 开始计时
            const decompressStartTime = Date.now();
            
            try {
                // 检测文件格式
                const fileName = decompressFile.name.toLowerCase();
                let result;
                
                if (fileName.endsWith('.zip')) {
                    // ZIP格式解压
                    result = await decompressZip(decompressStartTime);
                } else {
                    // DEFLATE格式解压
                    result = await decompressDeflate(decompressStartTime);
                }
                
                if (!decompressCancelled) {
                    // 完成解压
                    finishDecompression(result.file, result.info, decompressStartTime);
                }
                
            } catch (error) {
                if (error.message === '解压已取消') {
                    showToast('解压已取消', 'error');
                } else {
                    console.error('解压失败:', error);
                    showToast('解压失败: ' + error.message, 'error');
                }
                
                isDecompressing = false;
                decompressBtn.disabled = false;
                cancelDecompressBtn.disabled = true;
                decompressLoading.classList.remove('active');
            }
        }
        
        // 解压DEFLATE文件
        async function decompressDeflate(startTime) {
            // 读取压缩文件
            const arrayBuffer = await readFileAsArrayBuffer(decompressFile);
            
            // 解析文件头
            const { header, dataOffset } = parseFileHeader(arrayBuffer);
            
            // 检查魔数
            if (header.MAGIC !== "DFLT") {
                throw new Error('不是有效的DEFLATE压缩文件');
            }
            
            // 更新分段显示
            updateSegmentsDisplay(decompressSegments, header.SEGMENT_COUNT);
            
            // 分段解压
            const decompressedChunks = [];
            let totalDecompressedSize = 0;
            let processedBytes = 0;
            
            for (let i = 0; i < header.SEGMENT_COUNT; i++) {
                if (decompressCancelled) {
                    throw new Error('解压已取消');
                }
                
                const segmentInfo = header.SEGMENTS[i];
                
                // 更新分段显示状态
                updateSegmentStatus(decompressSegments, i, 'compressing');
                
                // 获取压缩数据
                const segmentStart = dataOffset + segmentInfo.offset;
                const segmentEnd = segmentStart + segmentInfo.compressedSize;
                const compressedData = arrayBuffer.slice(segmentStart, segmentEnd);
                
                // 使用pako进行DEFLATE解压
                const decompressedData = pako.inflate(new Uint8Array(compressedData));
                
                // 更新性能监控
                processedBytes += segmentInfo.compressedSize;
                updatePerformanceMetrics('decompress', processedBytes, startTime);
                
                // 保存解压后的数据
                decompressedChunks.push(decompressedData);
                totalDecompressedSize += decompressedData.length;
                
                // 更新进度
                const progress = Math.round(((i + 1) / header.SEGMENT_COUNT) * 100);
                updateProgress('decompress', progress);
                
                // 更新分段显示状态
                updateSegmentStatus(decompressSegments, i, 'processed');
                
                // 让出控制权，避免UI阻塞
                await delay(10);
            }
            
            // 合并所有分段数据
            const finalFile = mergeChunksToFile(decompressedChunks, header.ORIGINAL_FILE_NAME);
            
            return {
                file: finalFile,
                info: {
                    originalName: header.ORIGINAL_FILE_NAME,
                    originalSize: header.ORIGINAL_FILE_SIZE,
                    fileCount: 1,
                    format: 'deflate'
                }
            };
        }
        
        // 解压ZIP文件
        async function decompressZip(startTime) {
            // 读取ZIP文件
            const arrayBuffer = await readFileAsArrayBuffer(decompressFile);
            const zip = await JSZip.loadAsync(arrayBuffer);
            
            const files = Object.keys(zip.files);
            const fileCount = files.length;
            
            // 更新分段显示
            updateSegmentsDisplay(decompressSegments, Math.min(fileCount, 50));
            
            // 解压所有文件
            const fileBlobs = {};
            let totalDecompressedSize = 0;
            let processedFiles = 0;
            
            for (let i = 0; i < files.length; i++) {
                if (decompressCancelled) {
                    throw new Error('解压已取消');
                }
                
                const fileName = files[i];
                const zipEntry = zip.files[fileName];
                
                // 跳过目录
                if (zipEntry.dir) continue;
                
                // 更新分段显示状态
                if (i < 50) {
                    updateSegmentStatus(decompressSegments, i, 'compressing');
                }
                
                try {
                    // 解压文件
                    const fileData = await zipEntry.async("blob");
                    fileBlobs[fileName] = fileData;
                    totalDecompressedSize += fileData.size;
                    
                    // 更新进度
                    processedFiles++;
                    const progress = Math.round((processedFiles / fileCount) * 100);
                    updateProgress('decompress', progress);
                    
                    // 更新性能监控
                    updatePerformanceMetrics('decompress', totalDecompressedSize, startTime);
                    
                    // 更新分段显示状态
                    if (i < 50) {
                        updateSegmentStatus(decompressSegments, i, 'processed');
                    }
                    
                    // 让出控制权，避免UI阻塞
                    await delay(10);
                    
                } catch (error) {
                    console.error(`解压文件 ${fileName} 失败:`, error);
                }
            }
            
            // 保存ZIP文件内容供下载
            window.zipContents = fileBlobs;
            window.zipFileName = decompressFile.name.replace('.zip', '') || 'extracted';
            
            // 创建第一个文件的Blob（用于单个文件下载）
            const firstFile = fileBlobs[Object.keys(fileBlobs)[0]];
            
            return {
                file: firstFile || new Blob([]),
                info: {
                    originalName: decompressFile.name.replace('.zip', ''),
                    originalSize: totalDecompressedSize,
                    fileCount: Object.keys(fileBlobs).length,
                    format: 'zip',
                    isMultiFile: Object.keys(fileBlobs).length > 1
                }
            };
        }
        
        // 解析文件头部（DEFLATE格式）
        function parseFileHeader(arrayBuffer) {
            const dataView = new DataView(arrayBuffer);
            
            // 读取头部长度
            const headerLength = dataView.getUint32(0, true);
            
            // 读取头部数据
            const headerData = new Uint8Array(arrayBuffer, 4, headerLength);
            const headerStr = new TextDecoder().decode(headerData);
            const header = JSON.parse(headerStr);
            
            return {
                header,
                dataOffset: 4 + headerLength
            };
        }
        
        // 合并分段数据为文件
        function mergeChunksToFile(chunks, originalFileName) {
            // 计算总大小
            let totalSize = 0;
            for (const chunk of chunks) {
                totalSize += chunk.length;
            }
            
            // 创建ArrayBuffer
            const finalBuffer = new ArrayBuffer(totalSize);
            const finalArray = new Uint8Array(finalBuffer);
            
            // 合并所有数据
            let offset = 0;
            for (const chunk of chunks) {
                finalArray.set(chunk, offset);
                offset += chunk.length;
            }
            
            return new Blob([finalBuffer], { type: 'application/octet-stream' });
        }
        
        // 完成压缩
        function finishCompression(compressedFile) {
            isCompressing = false;
            compressBtn.disabled = false;
            cancelCompressBtn.disabled = true;
            compressLoading.classList.remove('active');
            compressResult.classList.add('active');
            
            const endTime = Date.now();
            const processingTime = (endTime - compressStartTime) / 1000;
            
            // 计算压缩率
            let originalSize, compressedSize, compressionRatio;
            
            if (compressFormat === 'zip' || compressFiles.length > 1) {
                // ZIP格式
                originalSize = window.compressionStats?.originalSize || 
                    compressFiles.reduce((sum, file) => sum + file.size, 0);
                compressedSize = compressedFile.size;
                compressionRatio = originalSize > 0 ? 
                    Math.round((1 - compressedSize / originalSize) * 100) : 0;
            } else {
                // DEFLATE格式
                originalSize = compressFile.size;
                compressedSize = compressedFile.size;
                compressionRatio = Math.round((1 - compressedSize / originalSize) * 100);
            }
            
            // 计算平均速度
            const avgSpeed = originalSize > 0 ? Math.round(originalSize / processingTime / 1024) : 0;
            
            // 更新结果显示
            document.getElementById('compressed-size').textContent = formatFileSize(compressedSize);
            document.getElementById('compression-ratio').textContent = `${compressionRatio}%`;
            document.getElementById('compress-time').textContent = `${processingTime.toFixed(2)} 秒`;
            document.getElementById('segment-count').textContent = compressFiles.length;
            document.getElementById('avg-compress-speed').textContent = `${avgSpeed} KB/s`;
            
            // 保存压缩文件供下载
            window.compressedFileBlob = compressedFile;
            
            // 确定文件名
            if (compressFormat === 'zip' || compressFiles.length > 1) {
                const folderName = compressFiles.length > 0 ? 
                    (compressFiles[0].webkitRelativePath ? 
                     compressFiles[0].webkitRelativePath.split('/')[0] : 'archive') : 
                    'archive';
                window.compressedFileName = `${folderName}.zip`;
            } else {
                window.compressedFileName = compressFile.name + '.deflate';
            }
            
            showToast(`文件压缩完成！压缩率: ${compressionRatio}%`);
        }
        
        // 完成解压
        function finishDecompression(decompressedFile, info, startTime) {
            isDecompressing = false;
            decompressBtn.disabled = false;
            cancelDecompressBtn.disabled = true;
            decompressLoading.classList.remove('active');
            decompressResult.classList.add('active');
            
            const endTime = Date.now();
            const processingTime = (endTime - startTime) / 1000;
            
            // 计算平均速度
            const compressedSize = decompressFile.size;
            const avgSpeed = compressedSize > 0 ? Math.round(compressedSize / processingTime / 1024) : 0;
            
            // 更新结果显示
            document.getElementById('decompressed-size').textContent = formatFileSize(info.originalSize);
            document.getElementById('original-filename').textContent = 
                info.fileCount > 1 ? `${info.originalName} (${info.fileCount}个文件)` : info.originalName;
            document.getElementById('decompress-time').textContent = `${processingTime.toFixed(2)} 秒`;
            document.getElementById('decompress-segment-count').textContent = info.fileCount;
            document.getElementById('avg-decompress-speed').textContent = `${avgSpeed} KB/s`;
            
            // 保存解压文件供下载
            if (info.format === 'zip' && info.isMultiFile) {
                // 对于多文件ZIP，显示ZIP包下载按钮
                window.decompressedFileBlob = decompressedFile;
                window.decompressedFileName = info.originalName || 'extracted';
                document.getElementById('download-zip-folder').style.display = 'flex';
            } else {
                // 单个文件
                window.decompressedFileBlob = decompressedFile;
                window.decompressedFileName = info.originalName || 'extracted';
                document.getElementById('download-zip-folder').style.display = 'none';
            }
            
            showToast(`文件解压完成！共${info.fileCount}个文件`);
        }
        
        // 下载ZIP文件夹（多文件情况）
        function downloadZipFolder() {
            if (!window.zipContents || Object.keys(window.zipContents).length === 0) {
                showToast('没有可下载的ZIP文件内容', 'error');
                return;
            }
            
            // 创建新的ZIP包供下载
            const zip = new JSZip();
            
            // 添加所有文件到ZIP
            Object.keys(window.zipContents).forEach(fileName => {
                zip.file(fileName, window.zipContents[fileName]);
            });
            
            // 生成ZIP文件
            zip.generateAsync({ type: "blob" })
                .then(function(zipContent) {
                    const url = URL.createObjectURL(zipContent);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = `${window.zipFileName}_extracted.zip`;
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);
                    
                    showToast('ZIP文件夹已开始下载');
                })
                .catch(error => {
                    console.error('创建ZIP文件失败:', error);
                    showToast('下载ZIP文件夹失败: ' + error.message, 'error');
                });
        }
        
        // 取消压缩
        function cancelCompression() {
            compressCancelled = true;
            isCompressing = false;
            compressBtn.disabled = false;
            cancelCompressBtn.disabled = true;
            compressLoading.classList.remove('active');
            
            showToast('压缩已取消', 'error');
        }
        
        // 取消解压
        function cancelDecompression() {
            decompressCancelled = true;
            isDecompressing = false;
            decompressBtn.disabled = false;
            cancelDecompressBtn.disabled = true;
            decompressLoading.classList.remove('active');
            
            showToast('解压已取消', 'error');
        }
        
        // 下载压缩文件
        function downloadCompressedFile() {
            if (!window.compressedFileBlob) {
                showToast('没有可下载的压缩文件', 'error');
                return;
            }
            
            const url = URL.createObjectURL(window.compressedFileBlob);
            const a = document.createElement('a');
            a.href = url;
            a.download = window.compressedFileName;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            
            showToast('压缩文件已开始下载');
        }
        
        // 下载解压文件
        function downloadDecompressedFile() {
            if (!window.decompressedFileBlob) {
                showToast('没有可下载的解压文件', 'error');
                return;
            }
            
            const url = URL.createObjectURL(window.decompressedFileBlob);
            const a = document.createElement('a');
            a.href = url;
            a.download = window.decompressedFileName;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            
            showToast('解压文件已开始下载');
        }
        
        // 读取文件为ArrayBuffer
        function readFileAsArrayBuffer(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = () => resolve(reader.result);
                reader.onerror = reject;
                reader.readAsArrayBuffer(file);
            });
        }
        
        // 初始化性能监控
        function initPerformanceMonitoring() {
            // 定期更新内存使用情况
            setInterval(() => {
                if (isCompressing) {
                    updateMemoryUsage('compress');
                }
                if (isDecompressing) {
                    updateMemoryUsage('decompress');
                }
            }, 1000);
        }
        
        // 重置性能指标
        function resetPerformanceMetrics(type) {
            if (type === 'compress') {
                document.getElementById('compress-speed').textContent = '0';
                document.getElementById('memory-usage').textContent = '0';
                document.getElementById('throughput').textContent = '0';
            } else {
                document.getElementById('decompress-speed').textContent = '0';
                document.getElementById('decompress-memory').textContent = '0';
                document.getElementById('decompress-throughput').textContent = '0';
            }
        }
        
        // 更新性能指标
        function updatePerformanceMetrics(type, processedBytes, startTime) {
            const currentTime = Date.now();
            const elapsedTime = (currentTime - startTime) / 1000; // 秒
            
            if (elapsedTime > 0) {
                const speed = Math.round(processedBytes / elapsedTime / 1024); // KB/s
                const throughput = Math.round(processedBytes / elapsedTime / (1024 * 1024) * 100) / 100; // MB/s
                
                if (type === 'compress') {
                    document.getElementById('compress-speed').textContent = speed;
                    document.getElementById('throughput').textContent = throughput;
                } else {
                    document.getElementById('decompress-speed').textContent = speed;
                    document.getElementById('decompress-throughput').textContent = throughput;
                }
            }
        }
        
        // 更新内存使用情况
        function updateMemoryUsage(type) {
            // 使用performance.memory API（仅Chrome支持）
            if (performance.memory) {
                const usedMB = Math.round(performance.memory.usedJSHeapSize / (1024 * 1024));
                const totalMB = Math.round(performance.memory.totalJSHeapSize / (1024 * 1024));
                
                if (type === 'compress') {
                    document.getElementById('memory-usage').textContent = `${usedMB}/${totalMB}`;
                } else {
                    document.getElementById('decompress-memory').textContent = `${usedMB}/${totalMB}`;
                }
            }
        }
        
        // 更新进度显示
        function updateProgress(type, percentage) {
            const progressBar = document.getElementById(`${type}-progress`);
            const percentageText = document.getElementById(`${type}-percentage`);
            
            progressBar.style.width = `${percentage}%`;
            percentageText.textContent = `${percentage}%`;
        }
        
        // 更新分段显示
        function updateSegmentsDisplay(container, count) {
            container.innerHTML = '';
            
            for (let i = 0; i < count; i++) {
                const segment = document.createElement('div');
                segment.className = 'segment';
                segment.textContent = i + 1;
                segment.dataset.index = i;
                container.appendChild(segment);
            }
        }
        
        // 更新分段状态
        function updateSegmentStatus(container, index, status) {
            const segment = container.querySelector(`[data-index="${index}"]`);
            if (segment) {
                segment.className = 'segment';
                if (status === 'processed') {
                    segment.classList.add('processed');
                } else if (status === 'compressing') {
                    segment.classList.add('compressing');
                }
            }
        }
        
        // 格式化文件大小
        function formatFileSize(bytes) {
            if (bytes === 0) return '0 Bytes';
            
            const k = 1024;
            const sizes = ['Bytes', 'KB', 'MB', 'GB'];
            const i = Math.floor(Math.log(bytes) / Math.log(k));
            
            return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
        }
        
        // 延迟函数
        function delay(ms) {
            return new Promise(resolve => setTimeout(resolve, ms));
        }
        
        // 显示提示消息
        function showToast(message, type = 'success') {
            toast.textContent = message;
            toast.className = 'toast';
            toast.classList.add(type);
            toast.classList.add('show');
            
            setTimeout(() => {
                toast.classList.remove('show');
            }, 3000);
        }
        
        // 生成测试文件
        function generateTestFiles() {
            if (compressMode === 'single') {
                // 生成一个简单的文本文件用于测试
                const text = "这是一个测试文件，用于测试DEFLATE压缩算法的效果。\n".repeat(1000);
                const blob = new Blob([text], { type: 'text/plain' });
                const file = new File([blob], 'test_file.txt', { type: 'text/plain', lastModified: Date.now() });
                
                // 模拟文件上传
                handleCompressFileUpload([file]);
                
                showToast('已生成1个测试文本文件 (约50KB)', 'warning');
            } else {
                // 生成多个测试文件模拟文件夹
                const files = [];
                
                // 创建一些测试文件
                const fileContents = [
                    { name: 'document.txt', content: '这是一个文本文档\n'.repeat(100) },
                    { name: 'data.json', content: JSON.stringify({ test: true, count: 42, message: '测试数据' }, null, 2) },
                    { name: 'notes.md', content: '# 测试文档\n\n这是一个Markdown测试文件。\n\n' },
                    { name: 'images/photo1.txt', content: '模拟图片文件 1\n'.repeat(50) },
                    { name: 'images/photo2.txt', content: '模拟图片文件 2\n'.repeat(50) },
                    { name: 'docs/readme.txt', content: '说明文档\n'.repeat(30) }
                ];
                
                fileContents.forEach(item => {
                    const blob = new Blob([item.content], { type: 'text/plain' });
                    const file = new File([blob], item.name, { 
                        type: 'text/plain', 
                        lastModified: Date.now() 
                    });
                    
                    // 模拟文件夹结构
                    if (item.name.includes('/')) {
                        file.webkitRelativePath = `test_folder/${item.name}`;
                    } else {
                        file.webkitRelativePath = `test_folder/${item.name}`;
                    }
                    
                    files.push(file);
                });
                
                // 模拟文件上传
                handleCompressFileUpload(files);
                
                showToast('已生成测试文件夹 (6个文件)', 'warning');
            }
        }
        
        // 测试解压功能
        async function testDecompression() {
            // 先创建一个测试ZIP文件
            const zip = new JSZip();
            
            // 添加一些测试文件
            zip.file("test1.txt", "这是一个测试文件1。");
            zip.file("test2.txt", "这是一个测试文件2，内容稍长一些。");
            zip.file("folder/test3.txt", "这是在文件夹中的测试文件。");
            
            // 生成ZIP文件
            const zipContent = await zip.generateAsync({ type: "blob" });
            
            // 创建File对象
            const decompressTestFile = new File([zipContent], 'test_folder.zip', 
                { type: 'application/zip', lastModified: Date.now() });
            
            // 模拟上传
            handleDecompressFileUpload([decompressTestFile]);
            
            showToast('测试ZIP文件已创建，可以开始解压测试', 'warning');
        }
    </script>
</body>
</html>