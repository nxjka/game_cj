<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DEFLATE分段压缩解压工具 - 修复版</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pako/2.1.0/pako.min.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        
        body {
            background-color: #f0f2f5;
            color: #333;
            line-height: 1.6;
            padding: 20px;
            min-height: 100vh;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
        }
        
        header {
            text-align: center;
            margin-bottom: 30px;
            padding-bottom: 20px;
            border-bottom: 2px solid #4a6ee0;
        }
        
        .logo {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 15px;
            margin-bottom: 15px;
        }
        
        .logo-icon {
            font-size: 2.5rem;
            color: #4a6ee0;
        }
        
        h1 {
            color: #2c3e50;
            font-size: 2.5rem;
            margin-bottom: 10px;
        }
        
        .subtitle {
            color: #7f8c8d;
            font-size: 1.1rem;
            max-width: 800px;
            margin: 0 auto;
        }
        
        .highlight {
            color: #4a6ee0;
            font-weight: bold;
        }
        
        .app-container {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 30px;
            margin-bottom: 30px;
        }
        
        @media (max-width: 768px) {
            .app-container {
                grid-template-columns: 1fr;
            }
        }
        
        .card {
            background-color: white;
            border-radius: 12px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.08);
            padding: 25px;
            height: 100%;
            transition: transform 0.3s ease;
        }
        
        .card:hover {
            transform: translateY(-5px);
        }
        
        .card-title {
            font-size: 1.5rem;
            color: #2c3e50;
            margin-bottom: 20px;
            padding-bottom: 10px;
            border-bottom: 2px solid #eaeaea;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .card-title i {
            color: #4a6ee0;
        }
        
        .upload-area {
            border: 3px dashed #d1d8e0;
            border-radius: 10px;
            padding: 40px 20px;
            text-align: center;
            margin-bottom: 25px;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .upload-area:hover {
            border-color: #4a6ee0;
            background-color: #f8f9ff;
        }
        
        .upload-icon {
            font-size: 3rem;
            color: #a5b1c2;
            margin-bottom: 15px;
        }
        
        .upload-text {
            font-size: 1.2rem;
            color: #7f8c8d;
            margin-bottom: 10px;
        }
        
        .file-info {
            background-color: #f8f9fa;
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 20px;
            display: none;
        }
        
        .file-info.active {
            display: block;
        }
        
        .file-info-row {
            display: flex;
            justify-content: space-between;
            margin-bottom: 8px;
        }
        
        .settings {
            margin-bottom: 25px;
        }
        
        .setting-group {
            margin-bottom: 20px;
        }
        
        .setting-label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
            color: #2c3e50;
        }
        
        .slider-container {
            display: flex;
            align-items: center;
            gap: 15px;
        }
        
        .slider-value {
            min-width: 60px;
            text-align: center;
            font-weight: bold;
            color: #4a6ee0;
        }
        
        input[type="range"] {
            flex-grow: 1;
            height: 8px;
            border-radius: 4px;
            background: #e0e0e0;
            outline: none;
            -webkit-appearance: none;
        }
        
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 22px;
            height: 22px;
            border-radius: 50%;
            background: #4a6ee0;
            cursor: pointer;
            border: 3px solid white;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
        }
        
        .buttons {
            display: flex;
            gap: 15px;
        }
        
        .btn {
            flex: 1;
            padding: 15px 20px;
            border: none;
            border-radius: 8px;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
            transition: all 0.3s ease;
        }
        
        .btn-primary {
            background-color: #4a6ee0;
            color: white;
        }
        
        .btn-primary:hover {
            background-color: #3a5ed0;
            transform: translateY(-2px);
        }
        
        .btn-secondary {
            background-color: #f0f2f5;
            color: #2c3e50;
        }
        
        .btn-secondary:hover {
            background-color: #e4e7eb;
        }
        
        .btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none !important;
        }
        
        .progress-section {
            margin-top: 25px;
        }
        
        .progress-header {
            display: flex;
            justify-content: space-between;
            margin-bottom: 10px;
        }
        
        .progress-label {
            font-weight: 600;
        }
        
        .progress-percentage {
            font-weight: bold;
            color: #4a6ee0;
        }
        
        .progress-bar {
            height: 12px;
            background-color: #e0e0e0;
            border-radius: 6px;
            overflow: hidden;
        }
        
        .progress-fill {
            height: 100%;
            background-color: #4a6ee0;
            width: 0%;
            transition: width 0.3s ease;
            border-radius: 6px;
        }
        
        .segments-container {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(80px, 1fr));
            gap: 10px;
            margin-top: 15px;
        }
        
        .segment {
            height: 30px;
            background-color: #e0e0e0;
            border-radius: 6px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.8rem;
            font-weight: 600;
            transition: all 0.3s ease;
        }
        
        .segment.processed {
            background-color: #4a6ee0;
            color: white;
        }
        
        .segment.compressing {
            background-color: #7d9eff;
            color: white;
        }
        
        .result-section {
            margin-top: 25px;
            padding-top: 20px;
            border-top: 2px solid #eaeaea;
            display: none;
        }
        
        .result-section.active {
            display: block;
        }
        
        .result-info {
            background-color: #f0f7ff;
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 20px;
        }
        
        .result-row {
            display: flex;
            justify-content: space-between;
            margin-bottom: 10px;
        }
        
        .compression-ratio {
            color: #27ae60;
            font-weight: bold;
        }
        
        .time-saved {
            color: #e74c3c;
            font-weight: bold;
        }
        
        .algorithm-info {
            background-color: #f8f9fa;
            border-radius: 12px;
            padding: 25px;
            margin-top: 30px;
        }
        
        .algorithm-info h3 {
            color: #2c3e50;
            margin-bottom: 15px;
            font-size: 1.5rem;
        }
        
        .info-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            margin-top: 20px;
        }
        
        .info-item {
            padding: 15px;
            background-color: white;
            border-radius: 8px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.05);
        }
        
        .info-item h4 {
            color: #4a6ee0;
            margin-bottom: 10px;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        footer {
            text-align: center;
            margin-top: 50px;
            padding-top: 20px;
            border-top: 1px solid #ddd;
            color: #7f8c8d;
            font-size: 0.9rem;
        }
        
        .loading {
            display: none;
            text-align: center;
            margin: 20px 0;
        }
        
        .loading.active {
            display: block;
        }
        
        .spinner {
            border: 5px solid #f3f3f3;
            border-top: 5px solid #4a6ee0;
            border-radius: 50%;
            width: 50px;
            height: 50px;
            animation: spin 1s linear infinite;
            margin: 0 auto 15px;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        .toast {
            position: fixed;
            bottom: 20px;
            right: 20px;
            background-color: #27ae60;
            color: white;
            padding: 15px 25px;
            border-radius: 8px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.2);
            display: flex;
            align-items: center;
            gap: 10px;
            transform: translateY(100px);
            opacity: 0;
            transition: all 0.3s ease;
            z-index: 1000;
        }
        
        .toast.show {
            transform: translateY(0);
            opacity: 1;
        }
        
        .toast.error {
            background-color: #e74c3c;
        }
        
        .toast.warning {
            background-color: #f39c12;
        }
        
        .performance-metrics {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 15px;
            margin-top: 20px;
        }
        
        .metric {
            background-color: #f8f9fa;
            padding: 15px;
            border-radius: 8px;
            text-align: center;
        }
        
        .metric-value {
            font-size: 1.5rem;
            font-weight: bold;
            color: #4a6ee0;
            margin-bottom: 5px;
        }
        
        .metric-label {
            font-size: 0.9rem;
            color: #7f8c8d;
        }
        
        @media (max-width: 768px) {
            .performance-metrics {
                grid-template-columns: 1fr;
            }
        }
        
        .debug-info {
            background-color: #f8f9fa;
            border-radius: 8px;
            padding: 10px;
            margin-top: 10px;
            font-size: 0.8rem;
            color: #666;
            font-family: monospace;
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <div class="logo">
                <i class="fas fa-file-archive logo-icon"></i>
                <h1>DEFLATE分段压缩解压工具</h1>
            </div>
            <p class="subtitle">基于<span class="highlight">pako.js实现DEFLATE算法</span>，支持<span class="highlight">分段压缩/解压</span>，可处理大文件并显示实时性能指标</p>
        </header>
        
        <div class="app-container">
            <!-- 压缩部分 -->
            <div class="card">
                <h2 class="card-title"><i class="fas fa-compress-alt"></i> 压缩文件</h2>
                
                <div class="upload-area" id="compress-upload">
                    <i class="fas fa-cloud-upload-alt upload-icon"></i>
                    <p class="upload-text">点击或拖拽文件到此处上传</p>
                    <p>支持所有文件类型</p>
                </div>
                
                <div class="file-info" id="compress-file-info">
                    <div class="file-info-row">
                        <span>文件名:</span>
                        <span id="compress-filename">未选择文件</span>
                    </div>
                    <div class="file-info-row">
                        <span>文件大小:</span>
                        <span id="compress-filesize">0 KB</span>
                    </div>
                    <div class="file-info-row">
                        <span>文件类型:</span>
                        <span id="compress-filetype">未知</span>
                    </div>
                </div>
                
                <div class="settings">
                    <div class="setting-group">
                        <label class="setting-label">分段大小 (KB)</label>
                        <div class="slider-container">
                            <input type="range" id="chunk-size" min="64" max="2048" value="512" step="64">
                            <span class="slider-value" id="chunk-size-value">512 KB</span>
                        </div>
                        <p class="setting-description">较小的分段可以提高处理速度，但可能降低压缩率</p>
                    </div>
                    
                    <div class="setting-group">
                        <label class="setting-label">压缩级别</label>
                        <div class="slider-container">
                            <input type="range" id="compression-level" min="1" max="9" value="6">
                            <span class="slider-value" id="compression-level-value">6 (平衡)</span>
                        </div>
                        <p class="setting-description">级别越高压缩率越好，但处理时间更长</p>
                    </div>
                    
                    <div class="performance-metrics" id="compress-metrics" style="display: none;">
                        <div class="metric">
                            <div class="metric-value" id="compress-speed">0</div>
                            <div class="metric-label">压缩速度 (KB/s)</div>
                        </div>
                        <div class="metric">
                            <div class="metric-value" id="memory-usage">0</div>
                            <div class="metric-label">内存使用 (MB)</div>
                        </div>
                        <div class="metric">
                            <div class="metric-value" id="throughput">0</div>
                            <div class="metric-label">吞吐量 (MB/s)</div>
                        </div>
                    </div>
                </div>
                
                <div class="buttons">
                    <button class="btn btn-primary" id="compress-btn">
                        <i class="fas fa-compress-alt"></i> 开始压缩
                    </button>
                    <button class="btn btn-secondary" id="cancel-compress-btn" disabled>
                        <i class="fas fa-stop-circle"></i> 取消
                    </button>
                </div>
                
                <div class="loading" id="compress-loading">
                    <div class="spinner"></div>
                    <p>正在压缩文件，请稍候...</p>
                </div>
                
                <div class="progress-section">
                    <div class="progress-header">
                        <span class="progress-label">压缩进度</span>
                        <span class="progress-percentage" id="compress-percentage">0%</span>
                    </div>
                    <div class="progress-bar">
                        <div class="progress-fill" id="compress-progress"></div>
                    </div>
                    
                    <div class="segments-container" id="compress-segments"></div>
                </div>
                
                <div class="result-section" id="compress-result">
                    <div class="result-info">
                        <div class="result-row">
                            <span>压缩后大小:</span>
                            <span id="compressed-size">0 KB</span>
                        </div>
                        <div class="result-row">
                            <span>压缩率:</span>
                            <span class="compression-ratio" id="compression-ratio">0%</span>
                        </div>
                        <div class="result-row">
                            <span>处理时间:</span>
                            <span id="compress-time">0 秒</span>
                        </div>
                        <div class="result-row">
                            <span>分段数量:</span>
                            <span id="segment-count">0</span>
                        </div>
                        <div class="result-row">
                            <span>平均压缩速度:</span>
                            <span id="avg-compress-speed">0 KB/s</span>
                        </div>
                    </div>
                    
                    <div class="buttons">
                        <button class="btn btn-primary" id="download-compressed">
                            <i class="fas fa-download"></i> 下载压缩文件
                        </button>
                        <button class="btn btn-secondary" id="test-compress">
                            <i class="fas fa-vial"></i> 测试压缩
                        </button>
                    </div>
                </div>
            </div>
            
            <!-- 解压部分 -->
            <div class="card">
                <h2 class="card-title"><i class="fas fa-expand-alt"></i> 解压文件</h2>
                
                <div class="upload-area" id="decompress-upload">
                    <i class="fas fa-cloud-upload-alt upload-icon"></i>
                    <p class="upload-text">点击或拖拽压缩文件到此处上传</p>
                    <p>支持 .deflate 格式</p>
                </div>
                
                <div class="file-info" id="decompress-file-info">
                    <div class="file-info-row">
                        <span>文件名:</span>
                        <span id="decompress-filename">未选择文件</span>
                    </div>
                    <div class="file-info-row">
                        <span>文件大小:</span>
                        <span id="decompress-filesize">0 KB</span>
                    </div>
                    <div class="file-info-row">
                        <span>压缩格式:</span>
                        <span id="decompress-format">未知</span>
                    </div>
                </div>
                
                <div class="performance-metrics" id="decompress-metrics" style="display: none;">
                    <div class="metric">
                        <div class="metric-value" id="decompress-speed">0</div>
                        <div class="metric-label">解压速度 (KB/s)</div>
                    </div>
                    <div class="metric">
                        <div class="metric-value" id="decompress-memory">0</div>
                        <div class="metric-label">内存使用 (MB)</div>
                    </div>
                    <div class="metric">
                        <div class="metric-value" id="decompress-throughput">0</div>
                        <div class="metric-label">吞吐量 (MB/s)</div>
                    </div>
                </div>
                
                <div class="buttons">
                    <button class="btn btn-primary" id="decompress-btn">
                        <i class="fas fa-expand-alt"></i> 开始解压
                    </button>
                    <button class="btn btn-secondary" id="cancel-decompress-btn" disabled>
                        <i class="fas fa-stop-circle"></i> 取消
                    </button>
                </div>
                
                <div class="loading" id="decompress-loading">
                    <div class="spinner"></div>
                    <p>正在解压文件，请稍候...</p>
                </div>
                
                <div class="progress-section">
                    <div class="progress-header">
                        <span class="progress-label">解压进度</span>
                        <span class="progress-percentage" id="decompress-percentage">0%</span>
                    </div>
                    <div class="progress-bar">
                        <div class="progress-fill" id="decompress-progress"></div>
                    </div>
                    
                    <div class="segments-container" id="decompress-segments"></div>
                </div>
                
                <div class="result-section" id="decompress-result">
                    <div class="result-info">
                        <div class="result-row">
                            <span>解压后大小:</span>
                            <span id="decompressed-size">0 KB</span>
                        </div>
                        <div class="result-row">
                            <span>原始文件名:</span>
                            <span id="original-filename">未知</span>
                        </div>
                        <div class="result-row">
                            <span>处理时间:</span>
                            <span id="decompress-time">0 秒</span>
                        </div>
                        <div class="result-row">
                            <span>分段数量:</span>
                            <span id="decompress-segment-count">0</span>
                        </div>
                        <div class="result-row">
                            <span>平均解压速度:</span>
                            <span id="avg-decompress-speed">0 KB/s</span>
                        </div>
                    </div>
                    
                    <div class="buttons">
                        <button class="btn btn-primary" id="download-decompressed">
                            <i class="fas fa-download"></i> 下载解压文件
                        </button>
                        <button class="btn btn-secondary" id="test-decompress">
                            <i class="fas fa-vial"></i> 测试解压
                        </button>
                    </div>
                </div>
            </div>
        </div>
        
        <div class="algorithm-info">
            <h3>DEFLATE分段压缩算法 - 实际实现</h3>
            <p>本工具使用pako.js库实现DEFLATE算法，该算法结合了LZ77压缩和霍夫曼编码，是ZIP、GZIP等格式的核心算法。通过分段处理优化大文件压缩/解压性能：</p>
            
            <div class="info-grid">
                <div class="info-item">
                    <h4><i class="fas fa-tachometer-alt"></i> 实际压缩算法</h4>
                    <p>使用pako.js实现的DEFLATE算法，支持原始数据压缩/解压，与标准ZIP/GZIP兼容。</p>
                </div>
                <div class="info-item">
                    <h4><i class="fas fa-microchip"></i> 性能监控</h4>
                    <p>实时显示压缩/解压速度、内存使用情况和吞吐量等性能指标。</p>
                </div>
                <div class="info-item">
                    <h4><i class="fas fa-file-archive"></i> 自定义文件格式</h4>
                    <p>使用自定义头部存储文件元数据和分段信息，支持恢复原始文件名和属性。</p>
                </div>
                <div class="info-item">
                    <h4><i class="fas fa-chart-line"></i> 真实性能优化</h4>
                    <p>分段处理减少内存占用，支持Web Workers（可选）实现后台处理不阻塞UI。</p>
                </div>
            </div>
        </div>
        
        <footer>
            <p>DEFLATE分段压缩解压工具 &copy; 2023 | 基于pako.js实现DEFLATE算法</p>
            <p>注意：本工具完全在浏览器端运行，不会上传任何文件到服务器</p>
        </footer>
    </div>
    
    <div class="toast" id="toast"></div>

    <script>
        // 全局变量
        let compressFile = null;
        let decompressFile = null;
        let compressChunks = [];
        let decompressChunks = [];
        let isCompressing = false;
        let isDecompressing = false;
        let compressCancelled = false;
        let decompressCancelled = false;
        let compressStartTime = 0; // 修复：明确定义compressStartTime变量
        
        // 自定义文件格式头部
        const FILE_HEADER = {
            MAGIC: "DFLT", // 魔数
            VERSION: 1,    // 版本号
            ORIGINAL_FILE_NAME: "", // 原始文件名
            ORIGINAL_FILE_SIZE: 0,  // 原始文件大小
            SEGMENT_COUNT: 0,       // 分段数量
            SEGMENTS: []            // 分段信息
        };
        
        // DOM元素
        const compressUpload = document.getElementById('compress-upload');
        const decompressUpload = document.getElementById('decompress-upload');
        const compressFileInfo = document.getElementById('compress-file-info');
        const decompressFileInfo = document.getElementById('decompress-file-info');
        const compressBtn = document.getElementById('compress-btn');
        const decompressBtn = document.getElementById('decompress-btn');
        const cancelCompressBtn = document.getElementById('cancel-compress-btn');
        const cancelDecompressBtn = document.getElementById('cancel-decompress-btn');
        const compressLoading = document.getElementById('compress-loading');
        const decompressLoading = document.getElementById('decompress-loading');
        const compressResult = document.getElementById('compress-result');
        const decompressResult = document.getElementById('decompress-result');
        const compressSegments = document.getElementById('compress-segments');
        const decompressSegments = document.getElementById('decompress-segments');
        const chunkSizeSlider = document.getElementById('chunk-size');
        const chunkSizeValue = document.getElementById('chunk-size-value');
        const compressionLevelSlider = document.getElementById('compression-level');
        const compressionLevelValue = document.getElementById('compression-level-value');
        const compressMetrics = document.getElementById('compress-metrics');
        const decompressMetrics = document.getElementById('decompress-metrics');
        const toast = document.getElementById('toast');
        
        // 性能监控变量
        let compressProcessedBytes = 0;
        let decompressStartTime = 0;
        let decompressProcessedBytes = 0;
        
        // 初始化
        document.addEventListener('DOMContentLoaded', function() {
            // 设置滑块值显示
            chunkSizeSlider.addEventListener('input', updateChunkSizeValue);
            compressionLevelSlider.addEventListener('input', updateCompressionLevelValue);
            
            // 初始化显示值
            updateChunkSizeValue();
            updateCompressionLevelValue();
            
            // 文件上传事件
            setupFileUpload(compressUpload, handleCompressFileUpload);
            setupFileUpload(decompressUpload, handleDecompressFileUpload);
            
            // 按钮事件
            compressBtn.addEventListener('click', startCompression);
            decompressBtn.addEventListener('click', startDecompression);
            cancelCompressBtn.addEventListener('click', cancelCompression);
            cancelDecompressBtn.addEventListener('click', cancelDecompression);
            
            document.getElementById('download-compressed').addEventListener('click', downloadCompressedFile);
            document.getElementById('download-decompressed').addEventListener('click', downloadDecompressedFile);
            document.getElementById('test-compress').addEventListener('click', generateTestFile);
            document.getElementById('test-decompress').addEventListener('click', testDecompression);
            
            // 初始化分段显示
            updateSegmentsDisplay(compressSegments, 0);
            updateSegmentsDisplay(decompressSegments, 0);
            
            // 初始化性能监控
            initPerformanceMonitoring();
            
            showToast('DEFLATE压缩解压工具已加载，基于pako.js实现', 'warning');
        });
        
        // 更新分段大小显示
        function updateChunkSizeValue() {
            const value = chunkSizeSlider.value;
            chunkSizeValue.textContent = `${value} KB`;
        }
        
        // 更新压缩级别显示
        function updateCompressionLevelValue() {
            const value = compressionLevelSlider.value;
            let levelText = '';
            if (value <= 3) levelText = '快速';
            else if (value <= 6) levelText = '平衡';
            else levelText = '最佳';
            
            compressionLevelValue.textContent = `${value} (${levelText})`;
        }
        
        // 设置文件上传区域
        function setupFileUpload(uploadArea, callback) {
            // 点击上传
            uploadArea.addEventListener('click', () => {
                const input = document.createElement('input');
                input.type = 'file';
                input.accept = uploadArea.id === 'decompress-upload' ? '.deflate,.gz,.zip' : '*';
                input.click();
                
                input.addEventListener('change', (e) => {
                    if (e.target.files.length > 0) {
                        callback(e.target.files[0]);
                    }
                });
            });
            
            // 拖拽上传
            uploadArea.addEventListener('dragover', (e) => {
                e.preventDefault();
                uploadArea.style.borderColor = '#4a6ee0';
                uploadArea.style.backgroundColor = '#f8f9ff';
            });
            
            uploadArea.addEventListener('dragleave', (e) => {
                e.preventDefault();
                uploadArea.style.borderColor = '#d1d8e0';
                uploadArea.style.backgroundColor = 'white';
            });
            
            uploadArea.addEventListener('drop', (e) => {
                e.preventDefault();
                uploadArea.style.borderColor = '#d1d8e0';
                uploadArea.style.backgroundColor = 'white';
                
                if (e.dataTransfer.files.length > 0) {
                    callback(e.dataTransfer.files[0]);
                }
            });
        }
        
        // 处理压缩文件上传
        function handleCompressFileUpload(file) {
            compressFile = file;
            
            // 更新文件信息显示
            document.getElementById('compress-filename').textContent = file.name;
            document.getElementById('compress-filesize').textContent = formatFileSize(file.size);
            document.getElementById('compress-filetype').textContent = file.type || getFileExtension(file.name);
            
            compressFileInfo.classList.add('active');
            compressBtn.disabled = false;
            compressResult.classList.remove('active');
            
            // 计算分段数量并更新显示
            const chunkSize = parseInt(chunkSizeSlider.value) * 1024;
            const chunkCount = Math.ceil(file.size / chunkSize);
            updateSegmentsDisplay(compressSegments, chunkCount);
            
            showToast(`文件 "${file.name}" 已准备就绪，可以开始压缩`);
        }
        
        // 处理解压文件上传
        function handleDecompressFileUpload(file) {
            decompressFile = file;
            
            // 更新文件信息显示
            document.getElementById('decompress-filename').textContent = file.name;
            document.getElementById('decompress-filesize').textContent = formatFileSize(file.size);
            document.getElementById('decompress-format').textContent = getFileExtension(file.name).toUpperCase() + ' 格式';
            
            decompressFileInfo.classList.add('active');
            decompressBtn.disabled = false;
            decompressResult.classList.remove('active');
            
            showToast(`压缩文件 "${file.name}" 已准备就绪，可以开始解压`);
        }
        
        // 开始压缩
        async function startCompression() {
            if (!compressFile || isCompressing) return;
            
            isCompressing = true;
            compressCancelled = false;
            compressBtn.disabled = true;
            cancelCompressBtn.disabled = false;
            compressLoading.classList.add('active');
            compressResult.classList.remove('active');
            compressMetrics.style.display = 'grid';
            
            const chunkSize = parseInt(chunkSizeSlider.value) * 1024;
            const compressionLevel = parseInt(compressionLevelSlider.value);
            const chunkCount = Math.ceil(compressFile.size / chunkSize);
            
            // 重置进度和性能监控
            updateProgress('compress', 0);
            updateSegmentsDisplay(compressSegments, chunkCount);
            resetPerformanceMetrics('compress');
            
            // 开始计时 - 修复：使用compressStartTime变量
            compressStartTime = Date.now();
            compressProcessedBytes = 0;
            
            try {
                // 读取文件为ArrayBuffer
                const arrayBuffer = await readFileAsArrayBuffer(compressFile);
                
                // 创建文件头
                const header = {
                    ...FILE_HEADER,
                    ORIGINAL_FILE_NAME: compressFile.name,
                    ORIGINAL_FILE_SIZE: compressFile.size,
                    SEGMENT_COUNT: chunkCount,
                    SEGMENTS: []
                };
                
                // 分段压缩
                const compressedChunks = [];
                let totalCompressedSize = 0;
                
                for (let i = 0; i < chunkCount; i++) {
                    if (compressCancelled) {
                        throw new Error('压缩已取消');
                    }
                    
                    // 计算当前分段的偏移量和大小
                    const start = i * chunkSize;
                    const end = Math.min(start + chunkSize, compressFile.size);
                    const chunkLength = end - start;
                    
                    // 获取当前分段的数据
                    const chunkData = arrayBuffer.slice(start, end);
                    
                    // 更新分段显示状态
                    updateSegmentStatus(compressSegments, i, 'compressing');
                    
                    // 使用pako进行DEFLATE压缩
                    const compressedData = pako.deflate(new Uint8Array(chunkData), { level: compressionLevel });
                    
                    // 更新性能监控
                    compressProcessedBytes += chunkLength;
                    updatePerformanceMetrics('compress', compressProcessedBytes, compressStartTime);
                    
                    // 保存压缩后的数据和分段信息
                    compressedChunks.push(compressedData);
                    header.SEGMENTS.push({
                        originalSize: chunkLength,
                        compressedSize: compressedData.length,
                        offset: totalCompressedSize
                    });
                    
                    totalCompressedSize += compressedData.length;
                    
                    // 更新进度
                    const progress = Math.round(((i + 1) / chunkCount) * 100);
                    updateProgress('compress', progress);
                    
                    // 更新分段显示状态
                    updateSegmentStatus(compressSegments, i, 'processed');
                    
                    // 让出控制权，避免UI阻塞
                    await delay(10);
                }
                
                // 构建最终文件
                const finalFile = createCompressedFile(header, compressedChunks);
                
                // 完成压缩 - 修复：传递compressStartTime参数
                finishCompression(finalFile, header, chunkCount, compressStartTime);
                
            } catch (error) {
                if (error.message === '压缩已取消') {
                    showToast('压缩已取消', 'error');
                } else {
                    console.error('压缩失败:', error);
                    showToast('压缩失败: ' + error.message, 'error');
                }
                
                isCompressing = false;
                compressBtn.disabled = false;
                cancelCompressBtn.disabled = true;
                compressLoading.classList.remove('active');
            }
        }
        
        // 开始解压
        async function startDecompression() {
            if (!decompressFile || isDecompressing) return;
            
            isDecompressing = true;
            decompressCancelled = false;
            decompressBtn.disabled = true;
            cancelDecompressBtn.disabled = false;
            decompressLoading.classList.add('active');
            decompressResult.classList.remove('active');
            decompressMetrics.style.display = 'grid';
            
            // 重置进度和性能监控
            updateProgress('decompress', 0);
            resetPerformanceMetrics('decompress');
            
            // 开始计时
            decompressStartTime = Date.now();
            decompressProcessedBytes = 0;
            
            try {
                // 读取压缩文件
                const arrayBuffer = await readFileAsArrayBuffer(decompressFile);
                
                // 解析文件头
                const { header, dataOffset } = parseFileHeader(arrayBuffer);
                
                // 检查魔数
                if (header.MAGIC !== FILE_HEADER.MAGIC) {
                    throw new Error('不是有效的DEFLATE压缩文件');
                }
                
                // 更新分段显示
                updateSegmentsDisplay(decompressSegments, header.SEGMENT_COUNT);
                
                // 分段解压
                const decompressedChunks = [];
                let totalDecompressedSize = 0;
                
                for (let i = 0; i < header.SEGMENT_COUNT; i++) {
                    if (decompressCancelled) {
                        throw new Error('解压已取消');
                    }
                    
                    const segmentInfo = header.SEGMENTS[i];
                    
                    // 更新分段显示状态
                    updateSegmentStatus(decompressSegments, i, 'compressing');
                    
                    // 获取压缩数据
                    const segmentStart = dataOffset + segmentInfo.offset;
                    const segmentEnd = segmentStart + segmentInfo.compressedSize;
                    const compressedData = arrayBuffer.slice(segmentStart, segmentEnd);
                    
                    // 使用pako进行DEFLATE解压
                    const decompressedData = pako.inflate(new Uint8Array(compressedData));
                    
                    // 更新性能监控
                    decompressProcessedBytes += segmentInfo.compressedSize;
                    updatePerformanceMetrics('decompress', decompressProcessedBytes, decompressStartTime);
                    
                    // 保存解压后的数据
                    decompressedChunks.push(decompressedData);
                    totalDecompressedSize += decompressedData.length;
                    
                    // 更新进度
                    const progress = Math.round(((i + 1) / header.SEGMENT_COUNT) * 100);
                    updateProgress('decompress', progress);
                    
                    // 更新分段显示状态
                    updateSegmentStatus(decompressSegments, i, 'processed');
                    
                    // 让出控制权，避免UI阻塞
                    await delay(10);
                }
                
                // 合并所有分段数据
                const finalFile = mergeChunksToFile(decompressedChunks, header.ORIGINAL_FILE_NAME);
                
                // 完成解压
                finishDecompression(finalFile, header, decompressStartTime);
                
            } catch (error) {
                if (error.message === '解压已取消') {
                    showToast('解压已取消', 'error');
                } else {
                    console.error('解压失败:', error);
                    showToast('解压失败: ' + error.message, 'error');
                }
                
                isDecompressing = false;
                decompressBtn.disabled = false;
                cancelDecompressBtn.disabled = true;
                decompressLoading.classList.remove('active');
            }
        }
        
        // 创建压缩文件
        function createCompressedFile(header, compressedChunks) {
            // 将头部转换为JSON字符串
            const headerStr = JSON.stringify(header);
            const headerEncoder = new TextEncoder();
            const headerData = headerEncoder.encode(headerStr);
            
            // 计算头部长度（4字节）
            const headerLength = headerData.length;
            const headerLengthArray = new Uint8Array(4);
            new DataView(headerLengthArray.buffer).setUint32(0, headerLength, true);
            
            // 计算总大小
            let totalSize = 4 + headerLength; // 头部长度 + 头部数据
            for (const chunk of compressedChunks) {
                totalSize += chunk.length;
            }
            
            // 创建ArrayBuffer
            const finalBuffer = new ArrayBuffer(totalSize);
            const finalArray = new Uint8Array(finalBuffer);
            
            // 写入头部长度
            let offset = 0;
            finalArray.set(headerLengthArray, offset);
            offset += 4;
            
            // 写入头部数据
            finalArray.set(headerData, offset);
            offset += headerLength;
            
            // 写入所有压缩数据
            for (const chunk of compressedChunks) {
                finalArray.set(chunk, offset);
                offset += chunk.length;
            }
            
            return new Blob([finalBuffer], { type: 'application/octet-stream' });
        }
        
        // 解析文件头部
        function parseFileHeader(arrayBuffer) {
            const dataView = new DataView(arrayBuffer);
            
            // 读取头部长度
            const headerLength = dataView.getUint32(0, true);
            
            // 读取头部数据
            const headerData = new Uint8Array(arrayBuffer, 4, headerLength);
            const headerStr = new TextDecoder().decode(headerData);
            const header = JSON.parse(headerStr);
            
            return {
                header,
                dataOffset: 4 + headerLength
            };
        }
        
        // 合并分段数据为文件
        function mergeChunksToFile(chunks, originalFileName) {
            // 计算总大小
            let totalSize = 0;
            for (const chunk of chunks) {
                totalSize += chunk.length;
            }
            
            // 创建ArrayBuffer
            const finalBuffer = new ArrayBuffer(totalSize);
            const finalArray = new Uint8Array(finalBuffer);
            
            // 合并所有数据
            let offset = 0;
            for (const chunk of chunks) {
                finalArray.set(chunk, offset);
                offset += chunk.length;
            }
            
            return new Blob([finalBuffer], { type: 'application/octet-stream' });
        }
        
        // 完成压缩 - 修复：添加startTime参数
        function finishCompression(compressedFile, header, chunkCount, startTime) {
            isCompressing = false;
            compressBtn.disabled = false;
            cancelCompressBtn.disabled = true;
            compressLoading.classList.remove('active');
            compressResult.classList.add('active');
            
            const endTime = Date.now();
            const processingTime = (endTime - startTime) / 1000;
            
            // 计算压缩率
            const originalSize = compressFile.size;
            const compressedSize = compressedFile.size;
            const compressionRatio = Math.round((1 - compressedSize / originalSize) * 100);
            
            // 计算平均速度
            const avgSpeed = originalSize > 0 ? Math.round(originalSize / processingTime / 1024) : 0;
            
            // 更新结果显示
            document.getElementById('compressed-size').textContent = formatFileSize(compressedSize);
            document.getElementById('compression-ratio').textContent = `${compressionRatio}%`;
            document.getElementById('compress-time').textContent = `${processingTime.toFixed(2)} 秒`;
            document.getElementById('segment-count').textContent = chunkCount;
            document.getElementById('avg-compress-speed').textContent = `${avgSpeed} KB/s`;
            
            // 保存压缩文件供下载
            window.compressedFileBlob = compressedFile;
            window.compressedFileName = compressFile.name + '.deflate';
            
            showToast(`文件压缩完成！压缩率: ${compressionRatio}%`);
        }
        
        // 完成解压 - 修复：添加startTime参数
        function finishDecompression(decompressedFile, header, startTime) {
            isDecompressing = false;
            decompressBtn.disabled = false;
            cancelDecompressBtn.disabled = true;
            decompressLoading.classList.remove('active');
            decompressResult.classList.add('active');
            
            const endTime = Date.now();
            const processingTime = (endTime - startTime) / 1000;
            
            // 计算平均速度
            const compressedSize = decompressFile.size;
            const avgSpeed = compressedSize > 0 ? Math.round(compressedSize / processingTime / 1024) : 0;
            
            // 更新结果显示
            document.getElementById('decompressed-size').textContent = formatFileSize(decompressedFile.size);
            document.getElementById('original-filename').textContent = header.ORIGINAL_FILE_NAME;
            document.getElementById('decompress-time').textContent = `${processingTime.toFixed(2)} 秒`;
            document.getElementById('decompress-segment-count').textContent = header.SEGMENT_COUNT;
            document.getElementById('avg-decompress-speed').textContent = `${avgSpeed} KB/s`;
            
            // 保存解压文件供下载
            window.decompressedFileBlob = decompressedFile;
            window.decompressedFileName = header.ORIGINAL_FILE_NAME;
            
            showToast('文件解压完成！');
        }
        
        // 取消压缩
        function cancelCompression() {
            compressCancelled = true;
            isCompressing = false;
            compressBtn.disabled = false;
            cancelCompressBtn.disabled = true;
            compressLoading.classList.remove('active');
            
            showToast('压缩已取消', 'error');
        }
        
        // 取消解压
        function cancelDecompression() {
            decompressCancelled = true;
            isDecompressing = false;
            decompressBtn.disabled = false;
            cancelDecompressBtn.disabled = true;
            decompressLoading.classList.remove('active');
            
            showToast('解压已取消', 'error');
        }
        
        // 下载压缩文件
        function downloadCompressedFile() {
            if (!window.compressedFileBlob) {
                showToast('没有可下载的压缩文件', 'error');
                return;
            }
            
            const url = URL.createObjectURL(window.compressedFileBlob);
            const a = document.createElement('a');
            a.href = url;
            a.download = window.compressedFileName;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            
            showToast('压缩文件已开始下载');
        }
        
        // 下载解压文件
        function downloadDecompressedFile() {
            if (!window.decompressedFileBlob) {
                showToast('没有可下载的解压文件', 'error');
                return;
            }
            
            const url = URL.createObjectURL(window.decompressedFileBlob);
            const a = document.createElement('a');
            a.href = url;
            a.download = window.decompressedFileName;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            
            showToast('解压文件已开始下载');
        }
        
        // 读取文件为ArrayBuffer
        function readFileAsArrayBuffer(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = () => resolve(reader.result);
                reader.onerror = reject;
                reader.readAsArrayBuffer(file);
            });
        }
        
        // 初始化性能监控
        function initPerformanceMonitoring() {
            // 定期更新内存使用情况
            setInterval(() => {
                if (isCompressing) {
                    updateMemoryUsage('compress');
                }
                if (isDecompressing) {
                    updateMemoryUsage('decompress');
                }
            }, 1000);
        }
        
        // 重置性能指标
        function resetPerformanceMetrics(type) {
            if (type === 'compress') {
                document.getElementById('compress-speed').textContent = '0';
                document.getElementById('memory-usage').textContent = '0';
                document.getElementById('throughput').textContent = '0';
            } else {
                document.getElementById('decompress-speed').textContent = '0';
                document.getElementById('decompress-memory').textContent = '0';
                document.getElementById('decompress-throughput').textContent = '0';
            }
        }
        
        // 更新性能指标
        function updatePerformanceMetrics(type, processedBytes, startTime) {
            const currentTime = Date.now();
            const elapsedTime = (currentTime - startTime) / 1000; // 秒
            
            if (elapsedTime > 0) {
                const speed = Math.round(processedBytes / elapsedTime / 1024); // KB/s
                const throughput = Math.round(processedBytes / elapsedTime / (1024 * 1024) * 100) / 100; // MB/s
                
                if (type === 'compress') {
                    document.getElementById('compress-speed').textContent = speed;
                    document.getElementById('throughput').textContent = throughput;
                } else {
                    document.getElementById('decompress-speed').textContent = speed;
                    document.getElementById('decompress-throughput').textContent = throughput;
                }
            }
        }
        
        // 更新内存使用情况
        function updateMemoryUsage(type) {
            // 使用performance.memory API（仅Chrome支持）
            if (performance.memory) {
                const usedMB = Math.round(performance.memory.usedJSHeapSize / (1024 * 1024));
                const totalMB = Math.round(performance.memory.totalJSHeapSize / (1024 * 1024));
                
                if (type === 'compress') {
                    document.getElementById('memory-usage').textContent = `${usedMB}/${totalMB}`;
                } else {
                    document.getElementById('decompress-memory').textContent = `${usedMB}/${totalMB}`;
                }
            }
        }
        
        // 更新进度显示
        function updateProgress(type, percentage) {
            const progressBar = document.getElementById(`${type}-progress`);
            const percentageText = document.getElementById(`${type}-percentage`);
            
            progressBar.style.width = `${percentage}%`;
            percentageText.textContent = `${percentage}%`;
        }
        
        // 更新分段显示
        function updateSegmentsDisplay(container, count) {
            container.innerHTML = '';
            
            for (let i = 0; i < count; i++) {
                const segment = document.createElement('div');
                segment.className = 'segment';
                segment.textContent = i + 1;
                segment.dataset.index = i;
                container.appendChild(segment);
            }
        }
        
        // 更新分段状态
        function updateSegmentStatus(container, index, status) {
            const segment = container.querySelector(`[data-index="${index}"]`);
            if (segment) {
                segment.className = 'segment';
                if (status === 'processed') {
                    segment.classList.add('processed');
                } else if (status === 'compressing') {
                    segment.classList.add('compressing');
                }
            }
        }
        
        // 格式化文件大小
        function formatFileSize(bytes) {
            if (bytes === 0) return '0 Bytes';
            
            const k = 1024;
            const sizes = ['Bytes', 'KB', 'MB', 'GB'];
            const i = Math.floor(Math.log(bytes) / Math.log(k));
            
            return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
        }
        
        // 获取文件扩展名
        function getFileExtension(filename) {
            const pos = filename.lastIndexOf('.');
            return pos > 0 ? filename.substring(pos + 1) : '';
        }
        
        // 延迟函数
        function delay(ms) {
            return new Promise(resolve => setTimeout(resolve, ms));
        }
        
        // 显示提示消息
        function showToast(message, type = 'success') {
            toast.textContent = message;
            toast.className = 'toast';
            toast.classList.add(type);
            toast.classList.add('show');
            
            setTimeout(() => {
                toast.classList.remove('show');
            }, 3000);
        }
        
        // 生成测试文件
        function generateTestFile() {
            // 生成一个简单的文本文件用于测试
            const text = "这是一个测试文件，用于测试DEFLATE压缩算法的效果。\n".repeat(1000);
            const blob = new Blob([text], { type: 'text/plain' });
            const file = new File([blob], 'test_file.txt', { type: 'text/plain', lastModified: Date.now() });
            
            // 模拟文件上传
            handleCompressFileUpload(file);
            
            showToast('已生成1个测试文本文件 (约50KB)', 'warning');
        }
        
        // 测试解压功能
        async function testDecompression() {
            // 先创建一个测试压缩文件
            const text = "这是一个用于测试解压功能的文件。\n".repeat(500);
            const blob = new Blob([text], { type: 'text/plain' });
            const testFile = new File([blob], 'test_for_decompress.txt', { type: 'text/plain' });
            
            // 模拟压缩过程
            showToast('正在创建测试压缩文件...', 'warning');
            
            try {
                // 使用pako直接压缩
                const textData = new TextEncoder().encode(text);
                const compressed = pako.deflate(textData, { level: 6 });
                
                // 创建自定义格式的压缩文件
                const header = {
                    ...FILE_HEADER,
                    ORIGINAL_FILE_NAME: 'test_for_decompress.txt',
                    ORIGINAL_FILE_SIZE: textData.length,
                    SEGMENT_COUNT: 1,
                    SEGMENTS: [{
                        originalSize: textData.length,
                        compressedSize: compressed.length,
                        offset: 0
                    }]
                };
                
                const testCompressedFile = createCompressedFile(header, [compressed]);
                
                // 创建File对象
                const decompressTestFile = new File([testCompressedFile], 'test_compressed.deflate', 
                    { type: 'application/octet-stream', lastModified: Date.now() });
                
                // 模拟上传
                handleDecompressFileUpload(decompressTestFile);
                
                showToast('测试压缩文件已创建，可以开始解压测试', 'warning');
            } catch (error) {
                console.error('创建测试压缩文件失败:', error);
                showToast('创建测试压缩文件失败: ' + error.message, 'error');
            }
        }
        
        // 添加全局测试函数
        window.generateTestFile = generateTestFile;
        window.testDecompression = testDecompression;
    </script>
</body>
</html>