<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ç»˜å›¾å·¥å…·</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        
        body {
            background: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
        }
        
        .container {
            max-width: 1200px;
            width: 100%;
            background-color: white;
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.1);
            overflow: hidden;
        }
        
        header {
            background: linear-gradient(90deg, #6a11cb 0%, #2575fc 100%);
            color: white;
            padding: 20px;
            text-align: center;
        }
        
        h1 {
            font-size: 2.2rem;
            margin-bottom: 10px;
        }
        
        .subtitle {
            font-size: 1rem;
            opacity: 0.9;
        }
        
        .app-body {
            display: flex;
            flex-wrap: wrap;
            padding: 20px;
        }
        
        .toolbar {
            flex: 1;
            min-width: 200px;
            padding: 15px;
            background-color: #f8f9fa;
            border-radius: 10px;
            margin-right: 20px;
            max-height: 600px;
            overflow-y: auto;
        }
        
        .tool-section {
            margin-bottom: 25px;
        }
        
        .tool-section h3 {
            margin-bottom: 15px;
            color: #444;
            font-size: 1.1rem;
            border-bottom: 1px solid #ddd;
            padding-bottom: 8px;
        }
        
        .tools {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
        }
        
        .tool-btn {
            width: 45px;
            height: 45px;
            border: none;
            border-radius: 8px;
            background-color: white;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
            transition: all 0.2s;
        }
        
        .tool-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0,0,0,0.15);
        }
        
        .tool-btn.active {
            background-color: #4d7cfe;
            color: white;
        }
        
        .color-palette {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
        }
        
        .color-option {
            width: 30px;
            height: 30px;
            border-radius: 50%;
            cursor: pointer;
            transition: transform 0.2s;
            border: 2px solid transparent;
        }
        
        .color-option:hover {
            transform: scale(1.1);
        }
        
        .color-option.active {
            border: 2px solid #333;
            transform: scale(1.1);
        }
        
        .slider-container {
            margin-top: 10px;
        }
        
        .slider-container label {
            display: block;
            margin-bottom: 8px;
            color: #555;
        }
        
        input[type="range"] {
            width: 100%;
        }
        
        select {
            width: 100%;
            padding: 8px;
            border-radius: 5px;
            border: 1px solid #ddd;
            background-color: white;
        }
        
        .canvas-container {
            flex: 3;
            min-width: 300px;
            background-color: #f0f0f0;
            border-radius: 10px;
            overflow: hidden;
            box-shadow: 0 5px 15px rgba(0,0,0,0.05);
            position: relative;
            height: 600px;
        }
        
        canvas {
            display: block;
            background-color: white;
            cursor: crosshair;
        }
        
        .text-input-container {
            position: absolute;
            display: none;
            border: 2px dashed #4d7cfe;
            padding: 5px;
            background-color: rgba(255, 255, 255, 0.9);
            box-shadow: 0 0 10px rgba(0,0,0,0.1);
        }
        
        .text-input {
            width: 100%;
            height: 100%;
            border: none;
            outline: none;
            background: transparent;
            resize: none;
            font-family: Arial, sans-serif;
            font-size: 16px;
        }
        
        .zoom-controls {
            position: absolute;
            bottom: 15px;
            right: 15px;
            display: flex;
            gap: 10px;
            background: rgba(255, 255, 255, 0.8);
            padding: 8px;
            border-radius: 8px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }
        
        .zoom-btn {
            width: 36px;
            height: 36px;
            border: none;
            border-radius: 50%;
            background-color: #4d7cfe;
            color: white;
            font-weight: bold;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
        }
        
        .zoom-level {
            display: flex;
            align-items: center;
            padding: 0 10px;
            font-weight: bold;
            color: #333;
        }
        
        .pan-controls {
            position: absolute;
            bottom: 15px;
            left: 15px;
            display: flex;
            flex-direction: column;
            gap: 5px;
            background: rgba(255, 255, 255, 0.8);
            padding: 8px;
            border-radius: 8px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }
        
        .pan-btn {
            width: 36px;
            height: 36px;
            border: none;
            border-radius: 50%;
            background-color: #4d7cfe;
            color: white;
            font-weight: bold;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
        }
        
        .pan-btn:hover {
            background-color: #3a6ae0;
        }
        
        .actions {
            display: flex;
            justify-content: center;
            gap: 15px;
            margin-top: 20px;
            padding: 0 20px 20px;
        }
        
        .action-btn {
            padding: 12px 25px;
            border: none;
            border-radius: 8px;
            background: linear-gradient(90deg, #6a11cb 0%, #2575fc 100%);
            color: white;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
            box-shadow: 0 4px 10px rgba(37, 117, 252, 0.3);
        }
        
        .action-btn:hover {
            transform: translateY(-3px);
            box-shadow: 0 6px 15px rgba(37, 117, 252, 0.4);
        }
        
        .action-btn.clear {
            background: linear-gradient(90deg, #ff416c 0%, #ff4b2b 100%);
            box-shadow: 0 4px 10px rgba(255, 65, 108, 0.3);
        }
        
        .action-btn.clear:hover {
            box-shadow: 0 6px 15px rgba(255, 65, 108, 0.4);
        }
        
        .shortcuts {
            margin-top: 20px;
            font-size: 0.85rem;
            color: #666;
        }
        
        .shortcuts h4 {
            margin-bottom: 10px;
            color: #444;
        }
        
        .shortcut-item {
            display: flex;
            justify-content: space-between;
            margin-bottom: 5px;
        }
        
        footer {
            margin-top: 20px;
            text-align: center;
            color: #666;
            font-size: 0.9rem;
        }
        
        @media (max-width: 768px) {
            .app-body {
                flex-direction: column;
            }
            
            .toolbar {
                margin-right: 0;
                margin-bottom: 20px;
            }
        }
        
        .fullscreen-mode {
            position: fixed !important;
            top: 0; left: 0; width: 100vw; height: 100vh;
            z-index: 9999;
            background: #fff;
            box-shadow: none;
            border-radius: 0;
            max-width: none;
            overflow: hidden;
            display: flex !important;
            flex-direction: column;
        }
        .fullscreen-toolbar-collapsed {
            width: 48px !important;
            min-width: 0 !important;
            padding: 0 !important;
            overflow: hidden !important;
            transition: width 0.2s;
        }
        .fullscreen-toolbar-expanded {
            width: 260px !important;
            min-width: 200px !important;
            transition: width 0.2s;
        }
        .fullscreen-actions-collapsed {
            height: 48px !important;
            overflow: hidden !important;
            transition: height 0.2s;
        }
        .fullscreen-actions-expanded {
            height: auto !important;
            transition: height 0.2s;
        }
        .fullscreen-toggle-btn {
            position: absolute;
            top: 8px;
            left: 8px;
            z-index: 10001;
            background: #2575fc;
            color: #fff;
            border: none;
            border-radius: 50%;
            width: 36px;
            height: 36px;
            font-size: 22px;
            cursor: pointer;
            box-shadow: 0 2px 8px rgba(0,0,0,0.12);
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .fullscreen-actions-toggle-btn {
            position: absolute;
            bottom: 8px;
            right: 8px;
            z-index: 10001;
            background: #2575fc;
            color: #fff;
            border: none;
            border-radius: 50%;
            width: 36px;
            height: 36px;
            font-size: 22px;
            cursor: pointer;
            box-shadow: 0 2px 8px rgba(0,0,0,0.12);
            display: flex;
            align-items: center;
            justify-content: center;
        }

        /* å†å²æŠ˜å æ ·å¼ */
        #historyContent.collapsed { display: none; }
        #historySection h3 { display:flex; align-items:center; justify-content:space-between; gap:8px; }
        .history-toggle-btn {
            padding:6px 8px;
            font-size:0.9rem;
            border-radius:6px;
            background: #f1f3f8;
            border: 1px solid #e2e6ef;
            cursor: pointer;
        }
        .history-toggle-btn:hover { background:#e8ecff; }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>ç»˜å›¾å·¥å…·</h1>
            <p class="subtitle">å¤šå½©ç»˜å›¾</p>
        </header>
        
        <div class="app-body">
            <div class="toolbar">
                <div class="tool-section">
                    <h3>ç»˜å›¾å·¥å…·</h3>
                    <div class="tools">
                        <button class="tool-btn active" id="pencil" title="ç”»ç¬”">âœï¸</button>
                        <button class="tool-btn" id="eraser" title="æ©¡çš®æ“¦">ğŸ©½</button>
                        <button class="tool-btn" id="line" title="ç›´çº¿">ğŸ“</button>
                        <button class="tool-btn" id="rectangle" title="çŸ©å½¢">â¬œ</button>
                        <button class="tool-btn" id="circle" title="åœ†å½¢">â­•</button>
                        <button class="tool-btn" id="text" title="æ–‡æœ¬">T</button>
                        <button class="tool-btn" id="mindmap" title="æ€ç»´å¯¼å›¾">ğŸ§ </button>
                        <button class="tool-btn" id="pan" title="ç§»åŠ¨ç”»å¸ƒ">âœ‹</button>
                    </div>
                </div>

                <div class="tool-section">
                    <h3>å¯¼å‡ºè®¾ç½®</h3>
                    <div style="display:flex;gap:8px;align-items:center;">
                        <input type="checkbox" id="watermarkToggle">
                        <label for="watermarkToggle">æ·»åŠ æ°´å°</label>
                    </div>
                    <div style="margin-top:8px;">
                        <input type="text" id="watermarkText" placeholder="æ°´å°æ–‡æœ¬ï¼ˆä¾‹å¦‚: Â© æˆ‘ï¼‰" style="width:100%;padding:6px;border-radius:4px;border:1px solid #ddd;">
                    </div>
                    <div style="margin-top:8px;display:flex;gap:8px;align-items:center;">
                        <label for="watermarkOpacity">é€æ˜åº¦</label>
                        <input id="watermarkOpacity" type="range" min="0" max="1" step="0.1" value="0.5" style="flex:1;">
                    </div>
                    <div style="margin-top:8px;display:flex;gap:8px;align-items:center;">
                        <label for="watermarkColor">é¢œè‰²</label>
                        <input id="watermarkColor" type="color" value="#000000" style="width:40px;height:30px;">
                    </div>
                    <div style="margin-top:8px;display:flex;gap:8px;align-items:center;">
                        <label for="watermarkFontSize">å­—å·</label>
                        <input id="watermarkFontSize" type="range" min="12" max="80" value="24" style="flex:1;">
                        <span id="watermarkFontSizeValue">24</span>px
                    </div>
                    <div style="margin-top:8px;display:flex;gap:8px;align-items:center;">
                        <label for="watermarkPosition">ä½ç½®</label>
                        <select id="watermarkPosition" style="flex:1;">
                            <option value="right-bottom">å³ä¸‹</option>
                            <option value="left-bottom">å·¦ä¸‹</option>
                            <option value="right-top">å³ä¸Š</option>
                            <option value="left-top">å·¦ä¸Š</option>
                            <option value="center">å±…ä¸­</option>
                        </select>
                    </div>
                </div>
                
                <div class="tool-section">
                    <h3>é¢œè‰²é€‰æ‹©</h3>
                    <div class="color-palette" id="colorPalette">
                        <div class="color-option active" style="background-color: #000000;" data-color="#000000"></div>
                        <div class="color-option" style="background-color: #ff3b30;" data-color="#ff3b30"></div>
                        <div class="color-option" style="background-color: #4cd964;" data-color="#4cd964"></div>
                        <div class="color-option" style="background-color: #007aff;" data-color="#007aff"></div>
                        <div class="color-option" style="background-color: #5856d6;" data-color="#5856d6"></div>
                        <div class="color-option" style="background-color: #ff9500;" data-color="#ff9500"></div>
                        <div class="color-option" style="background-color: #ffcc00;" data-color="#ffcc00"></div>
                        <div class="color-option" style="background-color: #8e8e93;" data-color="#8e8e93"></div>
                        <button id="addCustomColorBtn" style="width:30px;height:30px;border-radius:50%;border:2px dashed #aaa;background:#fff;cursor:pointer;display:flex;align-items:center;justify-content:center;">+</button>
                    </div>
                </div>

                <div class="tool-section" id="layersSection">
                    <h3>å›¾å±‚</h3>
                    <div style="display:flex;gap:8px;margin-bottom:8px;">
                        <button id="addLayerBtn" class="tool-btn" style="width:auto;padding:6px 8px;">æ·»åŠ å›¾å±‚</button>
                        <button id="removeLayerBtn" class="tool-btn" style="width:auto;padding:6px 8px;">åˆ é™¤å›¾å±‚</button>
                        <button id="uploadLayerBtn" class="tool-btn" style="width:auto;padding:6px 8px;">ä¸Šä¼ å›¾å±‚</button>
                    </div>
                    <div style="margin-bottom:8px;">
                        <label for="backgroundColorPicker" style="font-size:0.95em;">èƒŒæ™¯é¢œè‰²ï¼š</label>
                        <input type="color" id="backgroundColorPicker" value="#ffffff" style="width:40px;height:30px;">
                    </div>
                    <div id="layersList" style="max-height:180px;overflow:auto;border:1px solid #eee;padding:6px;background:#fff;"></div>
                </div>
                
                <div class="tool-section">
                    <h3>ç”»ç¬”è®¾ç½®</h3>
                    <div class="slider-container">
                        <label for="brushSize">ç”»ç¬”ç²—ç»†: <span id="brushSizeValue">5</span>px</label>
                        <input type="range" id="brushSize" min="1" max="50" value="5">
                    </div>
                </div>
                
                <div class="tool-section" id="textSettings">
                    <h3>æ–‡æœ¬è®¾ç½®</h3>
                    <div class="slider-container">
                        <label for="fontSize">å­—ä½“å¤§å°: <span id="fontSizeValue">16</span>px</label>
                        <input type="range" id="fontSize" min="10" max="72" value="16">
                    </div>
                    <div style="margin-top: 15px;">
                        <label for="fontFamily">å­—ä½“ç±»å‹:</label>
                        <select id="fontFamily">
                            <option value="Arial">Arial</option>
                            <option value="Helvetica">Helvetica</option>
                            <option value="Times New Roman">Times New Roman</option>
                            <option value="Georgia">Georgia</option>
                            <option value="Courier New">Courier New</option>
                            <option value="Verdana">Verdana</option>
                            <option value="Impact">Impact</option>
                            <option value="Comic Sans MS">Comic Sans MS</option>
                        </select>
                    </div>
                </div>
                
                <div class="tool-section shortcuts">
                    <h4>å¿«æ·é”®</h4>
                    <div class="shortcut-item">
                        <span>ç§»åŠ¨ç”»å¸ƒ</span>
                        <span>ç©ºæ ¼é”® + æ‹–æ‹½ æˆ– é€‰æ‹©ç§»åŠ¨å·¥å…·</span>
                    </div>
                    <div class="shortcut-item">
                        <span>æ”¾å¤§</span>
                        <span>Ctrl + + æˆ– é¼ æ ‡æ»šè½®å‘ä¸Š</span>
                    </div>
                    <div class="shortcut-item">
                        <span>ç¼©å°</span>
                        <span>Ctrl + - æˆ– é¼ æ ‡æ»šè½®å‘ä¸‹</span>
                    </div>
                    <div class="shortcut-item">
                        <span>é‡ç½®ç¼©æ”¾</span>
                        <span>Ctrl + 0</span>
                    </div>
                    <div class="shortcut-item">
                        <span>ä¿å­˜</span>
                        <span>Ctrl + S</span>
                    </div>
                    <div class="shortcut-item">
                        <span>æ¸…ç©º</span>
                        <span>Ctrl + D</span>
                    </div>
                </div>
            </div>
            <div class="tool-section" id="historySection">
                <h3>
                    <span>æ“ä½œå†å²</span>
                    <div style="display:flex;align-items:center;gap:8px;">
                        <button id="historyToggleBtn" class="history-toggle-btn" title="æŠ˜å /å±•å¼€å†å²">æŠ˜å </button>
                    </div>
                </h3>
                <div id="historyContent">
                    <div style="display:flex;gap:8px;align-items:center;margin-bottom:6px;">
                        <button id="clearHistoryBtn" class="tool-btn" title="æ¸…ç©ºå†å²" style="width:auto;padding:6px 8px;">æ¸…ç©ºå†å²</button>
                        <div style="font-size:0.85rem;color:#666;">ç‚¹å‡»å†å²é¡¹å¯ä»¥å›åˆ°è¯¥æ­¥</div>
                    </div>
                    <div id="historyList" style="max-height:200px;overflow:auto;border:1px solid #eee;padding:6px;background:#fff;"></div>
                </div>
            </div>
            
            <div class="canvas-container">
                <canvas id="drawingCanvas"></canvas>
                <div class="text-input-container" id="textInputContainer">
                    <textarea class="text-input" id="textInput" placeholder="è¾“å…¥æ–‡æœ¬..."></textarea>
                </div>
                <div class="zoom-controls">
                    <button class="zoom-btn" id="zoomOut">-</button>
                    <div class="zoom-level"><span id="zoomLevel">100%</span></div>
                    <button class="zoom-btn" id="zoomIn">+</button>
                </div>
                <div class="pan-controls">
                    <button class="pan-btn" id="panUp">â†‘</button>
                    <div style="display: flex; gap: 5px;">
                        <button class="pan-btn" id="panLeft">â†</button>
                        <button class="pan-btn" id="panReset">â†º</button>
                        <button class="pan-btn" id="panRight">â†’</button>
                    </div>
                    <button class="pan-btn" id="panDown">â†“</button>
                </div>
            </div>
        </div>
        
        <div class="actions">
            <button class="action-btn" id="saveBtn">ä¿å­˜å›¾ç‰‡</button>
            <button class="action-btn" id="saveViewportBtn">ä¿å­˜è§†å£</button>
            <button class="action-btn" id="undoBtn">æ’¤é”€</button>
            <button class="action-btn" id="redoBtn">é‡åš</button>
            <button class="action-btn" id="deleteNodeBtn">åˆ é™¤èŠ‚ç‚¹</button>
            <button class="action-btn" id="autoLayoutBtn">è‡ªåŠ¨å¸ƒå±€</button>
            <button class="action-btn clear" id="clearBtn">æ¸…ç©ºç”»å¸ƒ</button>
            <button class="action-btn" id="fullscreenBtn" style="background:linear-gradient(90deg,#2575fc 0%,#6a11cb 100%);">å…¨å±</button>
        </div>
    </div>
    
    <footer>
        <p>ç»˜å›¾å·¥å…· &copy; 2025</p>
    </footer>

    <script>
        document.addEventListener('DOMContentLoaded', function() {
            // è‡ªå®šä¹‰é¢œè‰²æ·»åŠ é€»è¾‘
            const colorPalette = document.getElementById('colorPalette');
            const addCustomColorBtn = document.getElementById('addCustomColorBtn');
            if (addCustomColorBtn) {
                addCustomColorBtn.addEventListener('click', function() {
                    const colorInput = document.createElement('input');
                    colorInput.type = 'color';
                    colorInput.style.display = 'none';
                    document.body.appendChild(colorInput);
                    colorInput.addEventListener('input', function() {
                        const newColor = colorInput.value;
                        // åˆ›å»ºæ–°çš„é¢œè‰²é€‰é¡¹å®¹å™¨
                        const optionWrapper = document.createElement('div');
                        optionWrapper.style.position = 'relative';
                        optionWrapper.style.display = 'inline-block';
                        // é¢œè‰²åœ†ç‚¹
                        const newOption = document.createElement('div');
                        newOption.className = 'color-option';
                        newOption.style.backgroundColor = newColor;
                        newOption.setAttribute('data-color', newColor);
                        // åˆ é™¤æŒ‰é’®
                        const delBtn = document.createElement('span');
                        delBtn.textContent = 'Ã—';
                        delBtn.title = 'åˆ é™¤æ­¤é¢œè‰²';
                        delBtn.style.position = 'absolute';
                        delBtn.style.top = '-8px';
                        delBtn.style.right = '-8px';
                        delBtn.style.width = '18px';
                        delBtn.style.height = '18px';
                        delBtn.style.background = '#fff';
                        delBtn.style.color = '#d00';
                        delBtn.style.borderRadius = '50%';
                        delBtn.style.fontSize = '14px';
                        delBtn.style.display = 'flex';
                        delBtn.style.alignItems = 'center';
                        delBtn.style.justifyContent = 'center';
                        delBtn.style.cursor = 'pointer';
                        delBtn.style.border = '1px solid #eee';
                        delBtn.style.boxShadow = '0 1px 4px rgba(0,0,0,0.08)';
                        delBtn.addEventListener('click', function(e) {
                            e.stopPropagation();
                            if (optionWrapper.parentNode) optionWrapper.parentNode.removeChild(optionWrapper);
                        });
                        // ç»‘å®šç‚¹å‡»äº‹ä»¶
                        newOption.addEventListener('click', function() {
                            document.querySelectorAll('.color-option').forEach(opt => opt.classList.remove('active'));
                            newOption.classList.add('active');
                            currentColor = newColor;
                        });
                        optionWrapper.appendChild(newOption);
                        optionWrapper.appendChild(delBtn);
                        // æ’å…¥åˆ°è‡ªå®šä¹‰æŒ‰é’®å‰
                        colorPalette.insertBefore(optionWrapper, addCustomColorBtn);
                        // è‡ªåŠ¨é€‰ä¸­
                        document.querySelectorAll('.color-option').forEach(opt => opt.classList.remove('active'));
                        newOption.classList.add('active');
                        currentColor = newColor;
                        // æ¸…ç†
                        if (colorInput.parentNode) colorInput.parentNode.removeChild(colorInput);
                    });
                    colorInput.click();
                });
            }
            const canvas = document.getElementById('drawingCanvas');
            const ctx = canvas.getContext('2d');
            const brushSize = document.getElementById('brushSize');
            const brushSizeValue = document.getElementById('brushSizeValue');
            const fontSize = document.getElementById('fontSize');
            const fontSizeValue = document.getElementById('fontSizeValue');
            const fontFamily = document.getElementById('fontFamily');
            const colorOptions = document.querySelectorAll('.color-option');
            const toolButtons = document.querySelectorAll('.tool-btn');
            const saveBtn = document.getElementById('saveBtn');
            const clearBtn = document.getElementById('clearBtn');
            const textInputContainer = document.getElementById('textInputContainer');
            const textInput = document.getElementById('textInput');
            const zoomInBtn = document.getElementById('zoomIn');
            const zoomOutBtn = document.getElementById('zoomOut');
            const zoomLevel = document.getElementById('zoomLevel');
            const panUpBtn = document.getElementById('panUp');
            const panDownBtn = document.getElementById('panDown');
            const panLeftBtn = document.getElementById('panLeft');
            const panRightBtn = document.getElementById('panRight');
            const panResetBtn = document.getElementById('panReset');

            // é€»è¾‘ï¼ˆè¶…å¤§ï¼‰ç”»å¸ƒå°ºå¯¸ï¼ˆè®¾ç½®ä¸ºå¾ˆå¤§ä»¥æ¨¡æ‹Ÿâ€œæ— é™â€ï¼‰
            const LOGICAL_WIDTH = 16000; // å¯æ ¹æ®éœ€è¦æ”¾å¤§
            const LOGICAL_HEIGHT = 9000;

            // çŸ¢é‡å­˜å‚¨ï¼šæ¯ä¸ª stroke è¡¨ç¤ºä¸€ç¬”æˆ–ä¸€ä¸ªå¯¹è±¡
            // stroke = { tool: 'pencil'|'eraser'|'line'|'rectangle'|'circle'|'text', color, lineWidth, points: [{x,y}], start:{x,y}, end:{x,y}, text, fontSize, fontFamily }
            const strokes = [];
            let currentStroke = null;

            // æ€ç»´å¯¼å›¾æ•°æ®
            // node = { id, x, y, w, h, text }
            // edge = { from, to }
            const mindNodes = [];
            const mindEdges = [];
            let mindNextId = 1;
            let draggingNode = null;
            let dragStartPos = null; // {x,y}
            let dragOffset = { x: 0, y: 0 };
            let creatingEdgeFrom = null;
            

            // æ°´å° UI å…ƒç´ 
            const watermarkToggle = document.getElementById('watermarkToggle');
            const watermarkTextInput = document.getElementById('watermarkText');
            const watermarkColorInput = document.getElementById('watermarkColor');
            const watermarkFontSizeInput = document.getElementById('watermarkFontSize');
            const watermarkFontSizeValue = document.getElementById('watermarkFontSizeValue');
            const watermarkPositionSelect = document.getElementById('watermarkPosition');

            // å›¾å±‚ç³»ç»Ÿ
            // layer = { id, name, visible: true, locked: false }
            const layers = [];
            let currentLayerId = null;

            function createLayer(name) {
                const id = 'layer_' + Date.now() + '_' + Math.floor(Math.random() * 1000);
                const layer = { id, name: name || 'å›¾å±‚ ' + (layers.length + 1), visible: true, locked: false, color: '#ffffff', image: null };
                layers.push(layer);
                if (!currentLayerId) currentLayerId = id;
                renderLayersPanel();
                return layer;
            }

            function removeLayer(id) {
                const idx = layers.findIndex(l => l.id === id);
                if (idx === -1) return false;
                layers.splice(idx, 1);
                if (currentLayerId === id) currentLayerId = layers.length ? layers[0].id : null;
                renderLayersPanel();
                return true;
            }

            function toggleLayerVisibility(id) {
                const l = layers.find(x => x.id === id); if (!l) return; l.visible = !l.visible; renderLayersPanel(); invalidateStaticCache(); redrawCanvas();
            }

            function toggleLayerLock(id) { const l = layers.find(x => x.id === id); if (!l) return; l.locked = !l.locked; renderLayersPanel(); }

            function selectLayer(id) { if (!layers.find(l => l.id === id)) return; currentLayerId = id; renderLayersPanel(); }

            const layersListEl = document.getElementById('layersList');
            const addLayerBtn = document.getElementById('addLayerBtn');
            const removeLayerBtn = document.getElementById('removeLayerBtn');
            const uploadLayerBtn = document.getElementById('uploadLayerBtn');

            // ä¸Šä¼ å›¾å±‚æŒ‰é’®é€»è¾‘
            uploadLayerBtn.addEventListener('click', function() {
                const fileInput = document.createElement('input');
                fileInput.type = 'file';
                fileInput.accept = 'image/*';
                fileInput.style.display = 'none';
                document.body.appendChild(fileInput);
                fileInput.addEventListener('change', function() {
                    const file = fileInput.files[0];
                    if (!file) return;
                    const reader = new FileReader();
                    reader.onload = function(e) {
                        const img = new Image();
                        img.onload = function() {
                            // æ–°å»ºå›¾å±‚ï¼Œimageå­—æ®µèµ‹å€¼
                            const name = prompt('è¾“å…¥å›¾å±‚åç§°ï¼ˆå¯é€‰ï¼‰ï¼š', 'å›¾ç‰‡å›¾å±‚');
                            const layer = createLayer(name || 'å›¾ç‰‡å›¾å±‚');
                            layer.image = img;
                            // å¯é€‰ï¼šè®¾ç½®å›¾å±‚é¢œè‰²
                            const color = prompt('è®¾ç½®å›¾å±‚é¢œè‰²ï¼ˆå¦‚ #ff0000ï¼Œå¯ç©ºï¼‰ï¼š', '#ffffff');
                            if (color && /^#([0-9a-fA-F]{3}|[0-9a-fA-F]{6})$/.test(color)) layer.color = color;
                            pushHistory('ä¸Šä¼ è‡ªå®šä¹‰å›¾å±‚');
                            invalidateStaticCache();
                            redrawCanvas();
                        };
                        img.src = e.target.result;
                    };
                    reader.readAsDataURL(file);
                    if (fileInput.parentNode) fileInput.parentNode.removeChild(fileInput);
                });
                fileInput.click();
            });

            // å›¾å±‚é¢æ¿æ¸²æŸ“ï¼Œæ˜¾ç¤ºå›¾ç‰‡é¢„è§ˆå’Œæ‚¬åœé¢„è§ˆ
            function renderLayersPanel() {
                layersListEl.innerHTML = '';
                for (let i = 0; i < layers.length; i++) {
                    const l = layers[i];
                    const row = document.createElement('div');
                    row.style.display = 'flex'; row.style.alignItems = 'center'; row.style.gap = '8px'; row.style.padding = '6px'; row.style.borderBottom = '1px solid #f1f1f1';
                    // color swatch
                    const sw = document.createElement('div'); sw.style.width='18px'; sw.style.height='18px'; sw.style.borderRadius='4px'; sw.style.background = l.color || '#ffffff'; sw.title='å›¾å±‚é¢œè‰²'; sw.style.border='1px solid #ddd';
                    sw.style.cursor = 'pointer';
                    sw.addEventListener('click', function(){
                        const colorInput = document.createElement('input'); colorInput.type = 'color';
                        try { colorInput.value = (l.color && l.color.startsWith && l.color.startsWith('#')) ? l.color : '#ffffff'; } catch(e) { colorInput.value = '#ffffff'; }
                        colorInput.style.display = 'none'; document.body.appendChild(colorInput);
                        colorInput.addEventListener('input', function() {
                            l.color = colorInput.value; renderLayersPanel(); invalidateStaticCache(); redrawCanvas();
                            if (colorInput.parentNode) colorInput.parentNode.removeChild(colorInput);
                        });
                        colorInput.click();
                    });
                    row.appendChild(sw);
                    // å›¾ç‰‡é¢„è§ˆ
                    if (l.image) {
                        const imgThumb = document.createElement('img');
                        imgThumb.src = l.image.src;
                        imgThumb.style.width = '32px';
                        imgThumb.style.height = '32px';
                        imgThumb.style.objectFit = 'cover';
                        imgThumb.title = 'å›¾å±‚å›¾ç‰‡é¢„è§ˆ';
                        row.appendChild(imgThumb);
                    }
                    // visibility checkbox
                    const vis = document.createElement('input'); vis.type='checkbox'; vis.checked = !!l.visible; vis.addEventListener('change', function(){ toggleLayerVisibility(l.id); }); row.appendChild(vis);
                    // lock checkbox
                    const lock = document.createElement('input'); lock.type='checkbox'; lock.title='é”å®š'; lock.checked = !!l.locked; lock.addEventListener('change', function(){ toggleLayerLock(l.id); }); row.appendChild(lock);
                    const label = document.createElement('div'); label.textContent = l.name; label.style.flex='1'; label.style.cursor='pointer'; if (l.id === currentLayerId) label.style.fontWeight='700'; label.addEventListener('click', function(){ selectLayer(l.id); }); row.appendChild(label);
                    // rename button
                    const renameBtn = document.createElement('button'); renameBtn.className='tool-btn'; renameBtn.style.width='auto'; renameBtn.style.padding='4px 6px'; renameBtn.textContent='é‡å‘½å'; renameBtn.addEventListener('click', function(){ const nm = prompt('å›¾å±‚æ–°åç§°ï¼š', l.name); if (nm !== null) { l.name = nm; renderLayersPanel(); pushHistory('é‡å‘½åå›¾å±‚'); } }); row.appendChild(renameBtn);
                    // move up/down
                    const upBtn = document.createElement('button'); upBtn.className='tool-btn'; upBtn.style.width='auto'; upBtn.style.padding='4px 6px'; upBtn.textContent='â†‘'; upBtn.addEventListener('click', function(){ if (i === 0) return; layers.splice(i,1); layers.splice(i-1,0,l); renderLayersPanel(); invalidateStaticCache(); redrawCanvas(); pushHistory('ä¸Šç§»å›¾å±‚'); }); row.appendChild(upBtn);
                    const downBtn = document.createElement('button'); downBtn.className='tool-btn'; downBtn.style.width='auto'; downBtn.style.padding='4px 6px'; downBtn.textContent='â†“'; downBtn.addEventListener('click', function(){ if (i === layers.length -1) return; layers.splice(i,1); layers.splice(i+1,0,l); renderLayersPanel(); invalidateStaticCache(); redrawCanvas(); pushHistory('ä¸‹ç§»å›¾å±‚'); }); row.appendChild(downBtn);
                    // æ‚¬åœé¢„è§ˆ
                    row.addEventListener('mouseenter', function() {
                        previewLayerId = l.id;
                        redrawCanvas();
                    });
                    row.addEventListener('mouseleave', function() {
                        previewLayerId = null;
                        redrawCanvas();
                    });
                    layersListEl.appendChild(row);
                }
            }

            // åˆå§‹åŒ–é»˜è®¤å›¾å±‚
            createLayer('é»˜è®¤å›¾å±‚');
            renderLayersPanel();

            // å›¾å±‚æŒ‰é’®é€»è¾‘
            addLayerBtn.addEventListener('click', function(){
	// å¼¹çª—è¿”å› null è¡¨ç¤ºç”¨æˆ·ç‚¹å‡»äº† å–æ¶ˆï¼Œå–æ¶ˆæ—¶ä¸åˆ›å»ºå›¾å±‚
	const name = prompt('å›¾å±‚åç§°ï¼ˆå¯é€‰ï¼‰ï¼š','æ–°å›¾å±‚');
	if (name === null) return; // ç”¨æˆ·å–æ¶ˆï¼Œç›´æ¥è¿”å›
	const l = createLayer(name.trim() ? name.trim() : undefined);
	pushHistory('æ·»åŠ å›¾å±‚');
	invalidateStaticCache();
});
            removeLayerBtn.addEventListener('click', function(){ if (!currentLayerId) return alert('æ²¡æœ‰å¯åˆ é™¤çš„å›¾å±‚');
                if (!confirm('åˆ é™¤å½“å‰å›¾å±‚ï¼Ÿä½ å¯ä»¥é€‰æ‹©å°†è¯¥å›¾å±‚å†…å®¹è¿ç§»åˆ°å¦ä¸€ä¸ªå›¾å±‚ï¼Œæˆ–ç›´æ¥åˆ é™¤ã€‚æ˜¯å¦ç»§ç»­ï¼Ÿ')) return;
                // è®°å½•åˆ é™¤å‰å®Œæ•´å¿«ç…§ï¼Œä»¥æ”¯æŒæ’¤é”€
                const prevSnapshot = { strokes: deepClone(strokes), mindNodes: deepClone(mindNodes), layers: deepClone(layers), currentLayerId };
                // é€‰æ‹©è¿ç§»ç›®æ ‡
                const other = layers.filter(x => x.id !== currentLayerId);
                let migrateTo = null;
                if (other.length > 0) {
                    const opts = other.map((o,idx) => `${idx+1}. ${o.name}`).join('\n');
                    const sel = prompt('è¾“å…¥è¦è¿ç§»åˆ°çš„å›¾å±‚åºå·ï¼Œç•™ç©ºåˆ™åˆ é™¤å…ƒç´ ï¼š\n' + opts, '');
                    if (sel !== null && sel.trim() !== '') {
                        const idx = parseInt(sel, 10) - 1;
                        if (idx >= 0 && idx < other.length) migrateTo = other[idx].id;
                    }
                }
                // æ‰§è¡Œè¿ç§»æˆ–åˆ é™¤
                if (migrateTo) {
                    for (let i = 0; i < strokes.length; i++) if (strokes[i].layerId === currentLayerId) strokes[i].layerId = migrateTo;
                    for (let i = 0; i < mindNodes.length; i++) if (mindNodes[i].layerId === currentLayerId) mindNodes[i].layerId = migrateTo;
                } else {
                    for (let i = strokes.length - 1; i >= 0; i--) if (strokes[i].layerId === currentLayerId) strokes.splice(i,1);
                    for (let i = mindNodes.length - 1; i >= 0; i--) if (mindNodes[i].layerId === currentLayerId) mindNodes.splice(i,1);
                }
                // æ‰§è¡Œå›¾å±‚åˆ é™¤
                const removedLayerId = currentLayerId;
                removeLayer(removedLayerId);
                const nextSnapshot = { strokes: deepClone(strokes), mindNodes: deepClone(mindNodes), layers: deepClone(layers), currentLayerId };
                // å°†æ“ä½œå‹å…¥ undo æ ˆï¼Œæ”¯æŒæ’¤é”€æ¢å¤ä¸º prevSnapshot
                undoStack.push({ type: 'layer-delete', prev: prevSnapshot, next: nextSnapshot });
                redoStack.length = 0; updateUndoRedoButtons();
                pushHistory('åˆ é™¤/è¿ç§»å›¾å±‚'); invalidateStaticCache(); redrawCanvas(); });


            // è§†å£ä¸äº¤äº’çŠ¶æ€
            let currentZoom = 1; // ç¼©æ”¾æ¯”ä¾‹
            let viewX = 0, viewY = 0; // è§†å£å·¦ä¸Šè§’åœ¨é€»è¾‘åæ ‡ç³»çš„ä½ç½®
            let isPanning = false;
            let lastPanX = 0, lastPanY = 0;
            // åˆ†å±‚ç¼“å­˜ï¼šé™æ€è§†å£å¿«ç…§ï¼Œç”¨äºåŠ é€Ÿ redraw
            const staticCache = document.createElement('canvas');
            const staticCacheCtx = staticCache.getContext('2d');
            let staticCacheValid = false;
            let staticCacheView = { viewX: 0, viewY: 0, zoom: 1, w: 0, h: 0 };

            function invalidateStaticCache() {
                staticCacheValid = false;
                scheduleRedraw();
            }

            // å‡å°‘é‡å¤é‡ç»˜ï¼šä½¿ç”¨ requestAnimationFrame æ‰¹é‡è°ƒåº¦ redraw
            let scheduled = false;
            function scheduleRedraw() {
                if (scheduled) return;
                scheduled = true;
                requestAnimationFrame(() => { scheduled = false; redrawCanvas(); });
            }

            function setupCanvas() {
                const container = canvas.parentElement;
                const newWidth = Math.max(300, container.clientWidth);
                const newHeight = Math.max(200, container.clientHeight);
                canvas.width = newWidth;
                canvas.height = newHeight;

                // é™åˆ¶è§†å£
                viewX = Math.min(Math.max(0, viewX), LOGICAL_WIDTH - canvas.width / currentZoom);
                viewY = Math.min(Math.max(0, viewY), LOGICAL_HEIGHT - canvas.height / currentZoom);
                redrawCanvas();
            }

            function drawGrid() {
                const gridSize = 20;
                ctx.save();
                ctx.strokeStyle = '#f0f0f0';
                ctx.lineWidth = 1;

                const startX = Math.floor(viewX / gridSize) * gridSize;
                const startY = Math.floor(viewY / gridSize) * gridSize;
                const endX = viewX + canvas.width / currentZoom + gridSize;
                const endY = viewY + canvas.height / currentZoom + gridSize;

                ctx.beginPath();
                for (let x = startX; x < endX; x += gridSize) {
                    const sx = (x - viewX) * currentZoom;
                    ctx.moveTo(sx, (startY - viewY) * currentZoom);
                    ctx.lineTo(sx, (endY - viewY) * currentZoom);
                }
                for (let y = startY; y < endY; y += gridSize) {
                    const sy = (y - viewY) * currentZoom;
                    ctx.moveTo((startX - viewX) * currentZoom, sy);
                    ctx.lineTo((endX - viewX) * currentZoom, sy);
                }
                ctx.stroke();
                ctx.restore();
            }

            // å°† screen (canvas åƒç´ ) è½¬ä¸ºé€»è¾‘åæ ‡
            function screenToLogical(rawX, rawY) {
                return [viewX + rawX / currentZoom, viewY + rawY / currentZoom];
            }

            function getEventCoordinates(e) {
                let clientX, clientY;
                if (e.type && e.type.includes('touch')) {
                    clientX = e.touches[0].clientX;
                    clientY = e.touches[0].clientY;
                } else {
                    clientX = e.clientX;
                    clientY = e.clientY;
                }
                const rect = canvas.getBoundingClientRect();
                return [clientX - rect.left, clientY - rect.top];
            }

            // ç»˜åˆ¶å•ä¸ª stroke åˆ°ä»»æ„ ctxã€‚è‹¥æä¾› view/zoom å‚æ•°åˆ™æŒ‰è§†å£è½¬æ¢ç»˜åˆ¶ï¼Œå¦åˆ™æŒ‰é€»è¾‘åæ ‡ç›´æ¥ç»˜åˆ¶ï¼ˆç”¨äºå¯¼å‡ºï¼‰

            function drawStrokeToCtx(targetCtx, stroke, opts = {}) {
                const isExport = !!opts.export;
                const vx = opts.viewX || 0;
                const vy = opts.viewY || 0;
                const zoom = typeof opts.zoom === 'number' ? opts.zoom : 1;

                targetCtx.save();
                targetCtx.lineJoin = 'round';
                targetCtx.lineCap = 'round';
                // å°†ç¬”å®½æŒ‰å½“å‰ zoom ç¼©æ”¾ï¼ˆåœ¨å¯¼å‡ºæˆ–ä¼ å…¥ç‰¹å®š zoom æ—¶ä¼šæ­£ç¡®è¡¨ç°ï¼‰
                targetCtx.lineWidth = (stroke.lineWidth || 1) * zoom;
                if (stroke.tool === 'eraser') {
                    targetCtx.globalCompositeOperation = 'destination-out';
                    targetCtx.strokeStyle = 'rgba(0,0,0,1)';
                } else {
                    targetCtx.globalCompositeOperation = 'source-over';
                    targetCtx.strokeStyle = stroke.color || '#000';
                }

                if (stroke.tool === 'pencil' || stroke.tool === 'eraser') {
                    const pts = stroke.points || [];
                    if (pts.length === 1) {
                        const x = (pts[0].x - vx) * zoom;
                        const y = (pts[0].y - vy) * zoom;
                        targetCtx.beginPath();
                        targetCtx.arc(x, y, (stroke.lineWidth || 1) / 2 * zoom, 0, Math.PI * 2);
                        targetCtx.fillStyle = stroke.color || '#000';
                        if (stroke.tool === 'eraser') {
                            // å¯¹äºæ©¡çš®ä½¿ç”¨æ“¦é™¤å¤åˆæ¨¡å¼
                            targetCtx.globalCompositeOperation = 'destination-out';
                            targetCtx.fill();
                        } else {
                            targetCtx.fill();
                        }
                    } else if (pts.length > 1) {
                        targetCtx.beginPath();
                        for (let i = 0; i < pts.length; i++) {
                            const p = pts[i];
                            const x = (p.x - vx) * zoom;
                            const y = (p.y - vy) * zoom;
                            if (i === 0) targetCtx.moveTo(x, y);
                            else targetCtx.lineTo(x, y);
                        }
                        targetCtx.stroke();
                    }
                } else if (stroke.tool === 'line') {
                    const sx = (stroke.start.x - vx) * zoom;
                    const sy = (stroke.start.y - vy) * zoom;
                    const ex = (stroke.end.x - vx) * zoom;
                    const ey = (stroke.end.y - vy) * zoom;
                    targetCtx.beginPath(); targetCtx.moveTo(sx, sy); targetCtx.lineTo(ex, ey); targetCtx.stroke();
                } else if (stroke.tool === 'rectangle') {
                    const sx = (stroke.start.x - vx) * zoom;
                    const sy = (stroke.start.y - vy) * zoom;
                    const w = (stroke.end.x - stroke.start.x) * zoom;
                    const h = (stroke.end.y - stroke.start.y) * zoom;
                    targetCtx.strokeRect(sx, sy, w, h);
                } else if (stroke.tool === 'circle') {
                    const cx = (stroke.start.x - vx) * zoom;
                    const cy = (stroke.start.y - vy) * zoom;
                    const r = Math.sqrt(Math.pow(stroke.end.x - stroke.start.x, 2) + Math.pow(stroke.end.y - stroke.start.y, 2)) * zoom;
                    targetCtx.beginPath(); targetCtx.arc(cx, cy, r, 0, Math.PI * 2); targetCtx.stroke();
                } else if (stroke.tool === 'text') {
                    const tx = (stroke.x - vx) * zoom;
                    const ty = (stroke.y - vy) * zoom;
                    const fSize = (stroke.fontSize || 16) * (isExport ? 1 : zoom);
                    targetCtx.fillStyle = stroke.color || '#000';
                    targetCtx.font = `${fSize}px ${stroke.fontFamily || 'Arial'}`;
                    targetCtx.textBaseline = 'top';
                    targetCtx.fillText(stroke.text || '', tx, ty);
                }

                targetCtx.restore();
            }

            // èƒŒæ™¯è‰²
            let backgroundColor = "#ffffff";
            const backgroundColorPicker = document.getElementById('backgroundColorPicker');
            backgroundColorPicker.addEventListener('input', function() {
                backgroundColor = backgroundColorPicker.value;
                invalidateStaticCache();
                redrawCanvas();
            });

            // å›¾å±‚æ‚¬åœé¢„è§ˆç›¸å…³å˜é‡
            let previewLayerId = null;

            function redrawCanvas() {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                ctx.fillStyle = backgroundColor;
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                drawGrid();

                // é™æ€ç¼“å­˜é‡å»º
                if (!staticCacheValid || staticCacheView.viewX !== viewX || staticCacheView.viewY !== viewY || staticCacheView.zoom !== currentZoom || staticCacheView.w !== canvas.width || staticCacheView.h !== canvas.height) {
                    staticCache.width = canvas.width;
                    staticCache.height = canvas.height;
                    staticCacheCtx.clearRect(0, 0, staticCache.width, staticCache.height);
                    staticCacheCtx.fillStyle = backgroundColor;
                    staticCacheCtx.fillRect(0, 0, staticCache.width, staticCache.height);
                    for (let li = 0; li < layers.length; li++) {
                        const layer = layers[li];
                        // æ‚¬åœé¢„è§ˆæ—¶åªæ˜¾ç¤ºå½“å‰æ‚¬åœå›¾å±‚
                        if (previewLayerId && layer.id !== previewLayerId) continue;
                        if (!layer.visible) continue;
                        if (layer.image) {
                            const imgW = layer.image.width;
                            const imgH = layer.image.height;
                            const sx = Math.max(0, (0 - viewX) * currentZoom);
                            const sy = Math.max(0, (0 - viewY) * currentZoom);
                            const sw = imgW * currentZoom;
                            const sh = imgH * currentZoom;
                            staticCacheCtx.save();
                            staticCacheCtx.globalAlpha = 0.85;
                            staticCacheCtx.drawImage(layer.image, sx, sy, sw, sh);
                            staticCacheCtx.restore();
                        }
                        for (let i = 0; i < strokes.length; i++) {
                            const s = strokes[i];
                            if (s.layerId !== layer.id) continue;
                            if (!isStrokeVisible(s, viewX, viewY, canvas.width / currentZoom, canvas.height / currentZoom)) continue;
                            drawStrokeToCtx(staticCacheCtx, s, { viewX, viewY, zoom: currentZoom });
                        }
                    }
                    staticCacheValid = true;
                    staticCacheView = { viewX, viewY, zoom: currentZoom, w: canvas.width, h: canvas.height };
                }
                ctx.drawImage(staticCache, 0, 0);
                // ç»˜åˆ¶æ€ç»´å¯¼å›¾è¾¹å’ŒèŠ‚ç‚¹ï¼ŒæŒ‰å›¾å±‚é¡ºåºç»˜åˆ¶ä»¥ä¿è¯æ­£ç¡®é®æŒ¡
                for (let li = 0; li < layers.length; li++) {
                    const layer = layers[li];
                    if (!layer.visible) continue;
                    // edges å±‚çº§è¿‡æ»¤ï¼šä»…ç»˜åˆ¶å±äºå½“å‰å›¾å±‚ä¸­èŠ‚ç‚¹çš„è¾¹ï¼ˆè‹¥è¾¹çš„ä¸¤ç«¯èŠ‚ç‚¹éƒ½åœ¨å¯è§å›¾å±‚ï¼‰
                    ctx.save();
                    ctx.strokeStyle = '#444';
                    ctx.lineWidth = 2 * currentZoom;
                    for (let e of mindEdges) {
                        const from = mindNodes.find(n => n.id === e.from);
                        const to = mindNodes.find(n => n.id === e.to);
                        if (!from || !to) continue;
                        // è‹¥è¾¹æ‰€å±å›¾å±‚ä¸åœ¨å½“å‰ layerï¼ˆä»¥ from.node çš„ layer ä¸ºå‡†ï¼‰åˆ™è·³è¿‡
                        if (from.layerId !== layer.id && to.layerId !== layer.id) continue;
                        const fx = (from.x - viewX) * currentZoom;
                        const fy = (from.y - viewY) * currentZoom;
                        const tx = (to.x - viewX) * currentZoom;
                        const ty = (to.y - viewY) * currentZoom;
                        ctx.beginPath(); ctx.moveTo(fx, fy); ctx.lineTo(tx, ty); ctx.stroke();
                    }
                    ctx.restore();

                    // nodes
                    for (let n of mindNodes) {
                        if (n.layerId !== layer.id) continue;
                        const nx = (n.x - viewX) * currentZoom;
                        const ny = (n.y - viewY) * currentZoom;
                        const w = (n.w || 120) * currentZoom;
                        const h = (n.h || 40) * currentZoom;
                        ctx.save();
                        ctx.fillStyle = '#fff8dc';
                        ctx.strokeStyle = '#333';
                        ctx.lineWidth = 1;
                        roundRect(ctx, nx - w/2, ny - h/2, w, h, 8 * currentZoom, true, true);
                        ctx.restore();
                        ctx.save();
                        ctx.fillStyle = '#111';
                        ctx.font = `${14 * currentZoom}px Arial`;
                        ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
                        ctx.fillText(n.text || ('èŠ‚ç‚¹ ' + n.id), nx, ny);
                        ctx.restore();
                    }
                }

                // ç»˜åˆ¶å½“å‰æ­£åœ¨ç»˜åˆ¶çš„ stroke ä½œä¸ºé¢„è§ˆ
                if (currentStroke) {
                    // å¦‚æœæ˜¯å›¾å½¢å‹ï¼Œä½¿ç”¨è™šçº¿é¢„è§ˆ
                    ctx.save();
                    if (currentStroke.tool === 'line' || currentStroke.tool === 'rectangle' || currentStroke.tool === 'circle') {
                        ctx.setLineDash([6, 4]);
                    }
                    drawStrokeToCtx(ctx, currentStroke, { viewX, viewY, zoom: currentZoom });
                    ctx.restore();
                }

                // å¦‚æœæ­£åœ¨åˆ›å»ºè¿çº¿ï¼Œæ˜¾ç¤ºé¢„è§ˆçº¿
                if (creatingEdgeFrom) {
                    const fromNode = mindNodes.find(n => n.id === creatingEdgeFrom.id);
                    if (fromNode) {
                        const fx = (fromNode.x - viewX) * currentZoom;
                        const fy = (fromNode.y - viewY) * currentZoom;
                        ctx.save(); ctx.strokeStyle = '#666'; ctx.setLineDash([4,4]); ctx.beginPath(); ctx.moveTo(fx, fy);
                        const m = lastPointerPos || { x: fx, y: fy };
                        ctx.lineTo(m.x, m.y); ctx.stroke(); ctx.restore();
                    }
                }
            }

            // helper: draw rounded rect
            function roundRect(ctx, x, y, width, height, radius, fill, stroke) {
                if (typeof stroke === 'undefined') { stroke = true; }
                if (typeof radius === 'undefined') { radius = 5; }
                ctx.beginPath();
                ctx.moveTo(x + radius, y);
                ctx.arcTo(x + width, y, x + width, y + height, radius);
                ctx.arcTo(x + width, y + height, x, y + height, radius);
                ctx.arcTo(x, y + height, x, y, radius);
                ctx.arcTo(x, y, x + width, y, radius);
                ctx.closePath();
                if (fill) ctx.fill();
                if (stroke) ctx.stroke();
            }

            // åˆå§‹åŒ–
            setupCanvas();
            window.addEventListener('resize', setupCanvas);

            // ç»˜åˆ¶çŠ¶æ€
            let isDrawing = false;
            // æåˆç¼©æ”¾çŠ¶æ€ï¼ˆè§¦æ§ï¼‰
            let isPinching = false;
            let pinchStartDist = 0;
            let pinchStartZoom = 1;
            let pinchCenter = { x: 0, y: 0 };
            let lastX = 0, lastY = 0;
            let startX = 0, startY = 0;
            let currentTool = 'pencil';
            let currentColor = '#000000';
            let lastPointerPos = null;

            // UI æ§ä»¶åŒæ­¥
            // æ°´å°å­—å·åŒæ­¥
            watermarkFontSizeInput.addEventListener('input', function() {
                watermarkFontSizeValue.textContent = watermarkFontSizeInput.value;
            });
            brushSizeValue.textContent = brushSize.value;
            fontSizeValue.textContent = fontSize.value;
            brushSize.addEventListener('input', () => brushSizeValue.textContent = brushSize.value);
            fontSize.addEventListener('input', () => fontSizeValue.textContent = fontSize.value);

            colorOptions.forEach(option => {
                option.addEventListener('click', function() {
                    colorOptions.forEach(opt => opt.classList.remove('active'));
                    this.classList.add('active');
                    currentColor = this.getAttribute('data-color');
                });
            });

            toolButtons.forEach(button => {
                button.addEventListener('click', function() {
                    toolButtons.forEach(btn => btn.classList.remove('active'));
                    this.classList.add('active');
                    currentTool = this.id;
                    if (currentTool !== 'text') hideTextInput();
                    if (currentTool === 'text') canvas.style.cursor = 'text';
                    else if (currentTool === 'pan') canvas.style.cursor = 'grab';
                    else canvas.style.cursor = 'crosshair';
                });
            });

            function startDrawing(e) {
                if (currentTool === 'text') { showTextInput(e); return; }
                if (currentTool === 'pan') { isPanning = true; [lastPanX, lastPanY] = getEventCoordinates(e); canvas.style.cursor = 'grabbing'; return; }
                if (currentTool === 'mindmap') {
                    const [rawX, rawY] = getEventCoordinates(e);
                    const [x, y] = screenToLogical(rawX, rawY);
                    // æ£€æŸ¥æ˜¯å¦ç‚¹å‡»åœ¨èŠ‚ç‚¹ä¸Š
                    const node = findNodeAtLogical(x, y);
                    if (node) {
                        // å¦‚æœèŠ‚ç‚¹æ‰€åœ¨å›¾å±‚è¢«é”å®šï¼Œé˜»æ­¢æ‹–åŠ¨/ç¼–è¾‘
                        const nodeLayer = layers.find(l => l.id === node.layerId);
                        if (nodeLayer && nodeLayer.locked) {
                            alert('è¯¥å›¾å±‚å·²é”å®šï¼Œæ— æ³•ç§»åŠ¨/ç¼–è¾‘èŠ‚ç‚¹');
                            return;
                        }
                        // å¼€å§‹æ‹–åŠ¨èŠ‚ç‚¹
                        draggingNode = node;
                        dragStartPos = { x, y };
                        dragOffset = { x: x - node.x, y: y - node.y };
                        return;
                    } else {
                        // åˆ›å»ºæ–°èŠ‚ç‚¹ï¼ˆæ£€æŸ¥å½“å‰å›¾å±‚é”å®šï¼‰
                        const curLayer = layers.find(l => l.id === currentLayerId);
                        if (curLayer && curLayer.locked) { alert('å½“å‰å›¾å±‚å·²é”å®šï¼Œæ— æ³•æ·»åŠ èŠ‚ç‚¹'); return; }
                        const newNode = createMindNode(x, y);
                        undoStack.push({ type: 'mind-add-node', node: deepClone(newNode) });
                        redoStack.length = 0;
                        updateUndoRedoButtons();
                        pushHistory('æ€ç»´å¯¼å›¾ï¼šæ·»åŠ èŠ‚ç‚¹');
                        redrawCanvas();
                        return;
                    }
                }

                const [rawX, rawY] = getEventCoordinates(e);
                const [x, y] = screenToLogical(rawX, rawY);
                isDrawing = true; startX = x; startY = y; lastX = x; lastY = y;

                if (currentTool === 'pencil' || currentTool === 'eraser') {
                    const layer = layers.find(l => l.id === currentLayerId);
                    if (layer && layer.locked) { isDrawing = false; return; }
                    currentStroke = {
                        tool: currentTool,
                        color: currentColor,
                        lineWidth: parseFloat(brushSize.value),
                        points: [{ x, y }],
                        layerId: currentLayerId
                    };
                } else if (currentTool === 'line' || currentTool === 'rectangle' || currentTool === 'circle') {
                    const layer = layers.find(l => l.id === currentLayerId);
                    if (layer && layer.locked) { isDrawing = false; return; }
                    currentStroke = {
                        tool: currentTool,
                        color: currentColor,
                        lineWidth: parseFloat(brushSize.value),
                        start: { x, y },
                        end: { x, y },
                        layerId: currentLayerId
                    };
                }
                redrawCanvas();
            }

            function drawing(e) {
                // update lastPointerPos for mindmap preview
                const [prx, pry] = getEventCoordinates(e);
                lastPointerPos = { x: prx, y: pry };

                if (isPanning) {
                    const [sx, sy] = getEventCoordinates(e);
                    viewX -= (sx - lastPanX) / currentZoom;
                    viewY -= (sy - lastPanY) / currentZoom;
                    lastPanX = sx; lastPanY = sy;
                    viewX = Math.max(0, Math.min(viewX, LOGICAL_WIDTH - canvas.width / currentZoom));
                    viewY = Math.max(0, Math.min(viewY, LOGICAL_HEIGHT - canvas.height / currentZoom));
                    redrawCanvas();
                    return;
                }
                if (currentTool === 'mindmap' && draggingNode) {
                    const [rawX, rawY] = getEventCoordinates(e);
                    const [x, y] = screenToLogical(rawX, rawY);
                    // ç§»åŠ¨èŠ‚ç‚¹ä½ç½®
                    const prev = { x: draggingNode.x, y: draggingNode.y };
                    draggingNode.x = x - dragOffset.x;
                    draggingNode.y = y - dragOffset.y;
                    // è®°å½•ç§»åŠ¨æ“ä½œï¼ˆå®æ—¶ä¸è®°å½•åˆ° undoï¼Œåœä¸‹æ—¶è®°å½•ä¸€æ¬¡ï¼‰
                    redrawCanvas();
                    return;
                }
                if (!isDrawing || currentTool === 'text') return;

                const [rawX, rawY] = getEventCoordinates(e);
                const [x, y] = screenToLogical(rawX, rawY);

                if (currentTool === 'pencil' || currentTool === 'eraser') {
                    if (currentStroke && currentStroke.points) {
                        currentStroke.points.push({ x, y });
                    }
                } else if (currentTool === 'line' || currentTool === 'rectangle' || currentTool === 'circle') {
                    if (currentStroke) currentStroke.end = { x, y };
                }
                lastX = x; lastY = y;
                redrawCanvas();
            }

            function stopDrawing(e) {
                if (isPanning) { isPanning = false; canvas.style.cursor = 'grab'; return; }
                // mindmap ç‰¹æ®Šå¤„ç†ï¼šåœæ­¢æ‹–åŠ¨èŠ‚ç‚¹æˆ–å®Œæˆè¿çº¿
                if (currentTool === 'mindmap') {
                    if (draggingNode) {
                        // è®°å½•èŠ‚ç‚¹ç§»åŠ¨åˆ° undoï¼ˆè®°å½• from/toï¼‰
                        const node = deepClone(draggingNode);
                        // for simplicity, we push a move op with previous pos stored in op.prev
                        // (we need previous pos - assume dragStartPos stores start)
                        undoStack.push({ type: 'mind-move-node', id: node.id, from: dragStartPos, to: { x: node.x, y: node.y } });
                        redoStack.length = 0;
                        updateUndoRedoButtons();
                        pushHistory('æ€ç»´å¯¼å›¾ï¼šç§»åŠ¨èŠ‚ç‚¹');
                        draggingNode = null; dragStartPos = null;
                        redrawCanvas();
                        return;
                    }
                    // å¦‚æœæ­£åœ¨åˆ›å»ºè¿çº¿ï¼Œå°è¯•ç»“æŸè¿çº¿
                    if (creatingEdgeFrom) {
                        const [rawX, rawY] = getEventCoordinates(e);
                        const [x, y] = screenToLogical(rawX, rawY);
                        const targetNode = findNodeAtLogical(x, y);
                        if (targetNode && targetNode.id !== creatingEdgeFrom.id) {
                            // åˆ›å»ºè¾¹
                            mindEdges.push({ from: creatingEdgeFrom.id, to: targetNode.id });
                            undoStack.push({ type: 'mind-add-edge', edge: deepClone({ from: creatingEdgeFrom.id, to: targetNode.id }) });
                            redoStack.length = 0;
                            updateUndoRedoButtons();
                            pushHistory('æ€ç»´å¯¼å›¾ï¼šæ·»åŠ è¿çº¿');
                            invalidateStaticCache();
                        }
                        creatingEdgeFrom = null; redrawCanvas(); return;
                    }
                    return;
                }

                if (!isDrawing || currentTool === 'text') return;
                isDrawing = false;

                const [rawX, rawY] = getEventCoordinates(e);
                const [x, y] = screenToLogical(rawX, rawY);

                if (currentStroke) {
                    // å¯¹äºçº¿å’Œå›¾å½¢ï¼Œæ›´æ–°æœ«ç«¯åæ ‡
                    if (currentStroke.start) currentStroke.end = { x, y };
                    // æäº¤ä¸ºä¸€ä¸ªæ–°çš„ç¬”ç”»ï¼ˆé€šè¿‡ pushStroke ä»¥è®°å½• undoï¼‰
                    pushStroke(currentStroke);
                    currentStroke = null;
                }
                redrawCanvas();
            }

            // äº‹ä»¶ç»‘å®š
            canvas.addEventListener('mousedown', function(e) { if (e.button !== 0) return; startDrawing(e); });
            canvas.addEventListener('mousemove', drawing);
            window.addEventListener('mouseup', stopDrawing);
            // è§¦æ‘¸æ”¯æŒï¼šå•æŒ‡ç»˜åˆ¶ / åŒæŒ‡æåˆç¼©æ”¾
            canvas.addEventListener('touchstart', function(e){
                if (e.touches && e.touches.length === 2) {
                    // å¼€å§‹æåˆ
                    isPinching = true;
                    pinchStartZoom = currentZoom;
                    const t0 = e.touches[0];
                    const t1 = e.touches[1];
                    const dx = t1.clientX - t0.clientX;
                    const dy = t1.clientY - t0.clientY;
                    pinchStartDist = Math.hypot(dx, dy);
                    // æåˆä¸­å¿ƒï¼ˆå±å¹•åæ ‡ç›¸å¯¹äº canvasï¼‰
                    const rect = canvas.getBoundingClientRect();
                    const cx = (t0.clientX + t1.clientX) / 2 - rect.left;
                    const cy = (t0.clientY + t1.clientY) / 2 - rect.top;
                    pinchCenter = { x: cx, y: cy };
                } else {
                    // å•æŒ‡ç»˜åˆ¶
                    startDrawing(e);
                }
                e.preventDefault();
            }, { passive: false });

            canvas.addEventListener('touchmove', function(e){
                if (isPinching && e.touches && e.touches.length === 2) {
                    const t0 = e.touches[0];
                    const t1 = e.touches[1];
                    const dx = t1.clientX - t0.clientX;
                    const dy = t1.clientY - t0.clientY;
                    const dist = Math.hypot(dx, dy);
                    if (pinchStartDist <= 0) pinchStartDist = dist || 1;
                    const rect = canvas.getBoundingClientRect();
                    // è®¡ç®—æ–°çš„ zoom
                    const ratio = dist / pinchStartDist;
                    const newZoom = Math.min(5, Math.max(0.2, pinchStartZoom * ratio));
                    // æ ¹æ®æåˆä¸­å¿ƒè°ƒæ•´ viewX/viewYï¼Œä½¿è§†è§‰ä¸­å¿ƒç¨³å®š
                    const mx = pinchCenter.x, my = pinchCenter.y;
                    const prevZoom = currentZoom;
                    const logicalX = viewX + mx / prevZoom;
                    const logicalY = viewY + my / prevZoom;
                    currentZoom = newZoom;
                    viewX = logicalX - mx / currentZoom;
                    viewY = logicalY - my / currentZoom;
                    viewX = Math.max(0, Math.min(viewX, LOGICAL_WIDTH - canvas.width / currentZoom));
                    viewY = Math.max(0, Math.min(viewY, LOGICAL_HEIGHT - canvas.height / currentZoom));
                    updateZoomDisplay();
                    redrawCanvas();
                    e.preventDefault();
                    return;
                }
                // å¦åˆ™æŒ‰å¸¸è§„å•ç‚¹å¤„ç†ï¼ˆç»˜åˆ¶/å¹³ç§»ï¼‰
                drawing(e);
                e.preventDefault();
            }, { passive: false });

            window.addEventListener('touchend', function(e){
                if (isPinching) {
                    // å¦‚æœæåˆç»“æŸï¼Œé‡ç½®çŠ¶æ€
                    if (!e.touches || e.touches.length < 2) {
                        isPinching = false;
                        pinchStartDist = 0;
                        pinchStartZoom = currentZoom;
                    }
                    e.preventDefault();
                    return;
                }
                stopDrawing(e);
            }, { passive: false });

            // ç¼©æ”¾/å¹³ç§»/å¿«æ·é”®
            function updateZoomDisplay() { zoomLevel.textContent = Math.round(currentZoom * 100) + '%'; }
            zoomInBtn.addEventListener('click', function() {
                const prevZoom = currentZoom; currentZoom = Math.min(currentZoom * 1.2, 5);
                const cx = canvas.width / 2, cy = canvas.height / 2;
                viewX += (cx / prevZoom) - (cx / currentZoom);
                viewY += (cy / prevZoom) - (cy / currentZoom);
                viewX = Math.max(0, Math.min(viewX, LOGICAL_WIDTH - canvas.width / currentZoom));
                viewY = Math.max(0, Math.min(viewY, LOGICAL_HEIGHT - canvas.height / currentZoom));
                updateZoomDisplay(); redrawCanvas();
            });
            zoomOutBtn.addEventListener('click', function() {
                const prevZoom = currentZoom; currentZoom = Math.max(currentZoom / 1.2, 0.2);
                const cx = canvas.width / 2, cy = canvas.height / 2;
                viewX += (cx / prevZoom) - (cx / currentZoom);
                viewY += (cy / prevZoom) - (cy / currentZoom);
                viewX = Math.max(0, Math.min(viewX, LOGICAL_WIDTH - canvas.width / currentZoom));
                viewY = Math.max(0, Math.min(viewY, LOGICAL_HEIGHT - canvas.height / currentZoom));
                updateZoomDisplay(); redrawCanvas();
            });

            panUpBtn.addEventListener('click', function(){ viewY = Math.max(0, viewY - 50 / currentZoom); redrawCanvas(); });
            panDownBtn.addEventListener('click', function(){ viewY = Math.min(LOGICAL_HEIGHT - canvas.height / currentZoom, viewY + 50 / currentZoom); redrawCanvas(); });
            panLeftBtn.addEventListener('click', function(){ viewX = Math.max(0, viewX - 50 / currentZoom); redrawCanvas(); });
            panRightBtn.addEventListener('click', function(){ viewX = Math.min(LOGICAL_WIDTH - canvas.width / currentZoom, viewX + 50 / currentZoom); redrawCanvas(); });
            panResetBtn.addEventListener('click', function(){ viewX = 0; viewY = 0; redrawCanvas(); });

            canvas.addEventListener('wheel', function(e){
                e.preventDefault();
                const rect = canvas.getBoundingClientRect();
                const mx = e.clientX - rect.left, my = e.clientY - rect.top;
                const prevZoom = currentZoom;
                const delta = e.deltaY > 0 ? 0.9 : 1.1;
                currentZoom = Math.max(0.2, Math.min(5, currentZoom * delta));
                const logicalX = viewX + mx / prevZoom;
                const logicalY = viewY + my / prevZoom;
                viewX = logicalX - mx / currentZoom;
                viewY = logicalY - my / currentZoom;
                viewX = Math.max(0, Math.min(viewX, LOGICAL_WIDTH - canvas.width / currentZoom));
                viewY = Math.max(0, Math.min(viewY, LOGICAL_HEIGHT - canvas.height / currentZoom));
                updateZoomDisplay(); redrawCanvas();
            });

            // æ–‡æœ¬è¾“å…¥å¤„ç†ï¼šåœ¨æ˜¾ç¤ºæ—¶è®°å½•é€»è¾‘åæ ‡ï¼Œæäº¤æ—¶å°†æ–‡æœ¬å­˜ä¸º stroke
            function showTextInput(e) {
                const [rawX, rawY] = getEventCoordinates(e);
                const [x, y] = screenToLogical(rawX, rawY);
                // åœ¨å±å¹•ä¸Šå®šä½è¾“å…¥æ¡†ï¼ˆç›¸å¯¹äº canvasï¼‰
                textInputContainer.style.left = rawX + 'px';
                textInputContainer.style.top = rawY + 'px';
                textInputContainer.style.width = '200px'; textInputContainer.style.height = '100px'; textInputContainer.style.display = 'block';
                textInput.style.fontSize = fontSize.value + 'px'; textInput.style.fontFamily = fontFamily.value; textInput.style.color = currentColor;
                // ä¿å­˜é€»è¾‘åæ ‡åˆ°å®¹å™¨ datasetï¼Œä»¥ä¾¿æäº¤æ—¶ä½¿ç”¨
                textInputContainer.dataset.logicalX = x;
                textInputContainer.dataset.logicalY = y;
                textInput.focus();
            }

            function hideTextInput() {
                if (textInputContainer.style.display === 'block') {
                    if (textInput.value.trim() !== '') {
                        const x = parseFloat(textInputContainer.dataset.logicalX);
                        const y = parseFloat(textInputContainer.dataset.logicalY);
                        const stroke = {
                            tool: 'text', x, y,
                            text: textInput.value,
                            color: currentColor,
                            fontSize: parseInt(fontSize.value, 10),
                            fontFamily: fontFamily.value,
                            layerId: currentLayerId
                        };
                        pushStroke(stroke);
                        redrawCanvas();
                    }
                    textInputContainer.style.display = 'none'; textInput.value = '';
                }
            }

            document.addEventListener('click', function(e){ if (currentTool === 'text' && !textInputContainer.contains(e.target) && e.target !== canvas) hideTextInput(); });
            textInput.addEventListener('keydown', function(e){ if (e.key === 'Enter' && !e.shiftKey) { e.preventDefault(); hideTextInput(); } });

            // å¿«æ·é”®ï¼šç©ºæ ¼ + æ‹–åŠ¨ å¹³ç§»ï¼ŒCtrl ä¿å­˜/æ¸…ç©º/ç¼©æ”¾ç­‰
            let isSpacePressed = false;
            document.addEventListener('keydown', function(e){
                if (e.code === 'Space') { isSpacePressed = true; if (currentTool !== 'pan') canvas.style.cursor = 'grab'; }
                if (e.ctrlKey || e.metaKey) {
                    switch(e.key) {
                        case 's': e.preventDefault(); saveImage(); break;
                        case 'd': e.preventDefault(); clearCanvas(); break;
                        case '0': e.preventDefault(); currentZoom = 1; viewX = 0; viewY = 0; updateZoomDisplay(); redrawCanvas(); break;
                        case '=': case '+': e.preventDefault(); currentZoom = Math.min(currentZoom * 1.2, 5); updateZoomDisplay(); redrawCanvas(); break;
                        case '-': e.preventDefault(); currentZoom = Math.max(currentZoom / 1.2, 0.2); updateZoomDisplay(); redrawCanvas(); break;
                    }
                }
            });
            document.addEventListener('keyup', function(e){ if (e.code === 'Space') { isSpacePressed = false; if (currentTool !== 'pan') canvas.style.cursor = 'crosshair'; } });

            canvas.addEventListener('mousedown', function(e){
                if (isSpacePressed) { isPanning = true; [lastPanX, lastPanY] = getEventCoordinates(e); canvas.style.cursor = 'grabbing'; e.preventDefault(); }
            });
            window.addEventListener('mouseup', function(e){ if (isPanning) { isPanning = false; canvas.style.cursor = isSpacePressed ? 'grab' : 'crosshair'; e.preventDefault(); } });

            // Undo/Redo æ ˆï¼ˆæ›´å®Œæ•´çš„å®ç°ï¼‰
            const undoStack = [];
            const redoStack = [];

            // å†å²é¢æ¿ï¼ˆç®€è¦æè¿° + å¿«ç…§ç´¢å¼•ï¼‰
            const historyListEl = document.getElementById('historyList');
            const history = []; // { desc, type, ts, snapshot }
            const MAX_HISTORY = 200;

            // ç”Ÿæˆå†å²é¡¹ç¼©ç•¥å›¾çš„è¾…åŠ©ï¼ˆè¿”å› dataURLï¼‰
            function renderHistoryThumbnail(snapshot, w = 160, h = 80) {
                try {
                    const tmp = document.createElement('canvas');
                    tmp.width = w; tmp.height = h;
                    const tctx = tmp.getContext('2d');
                    tctx.fillStyle = 'white'; tctx.fillRect(0,0,w,h);
                    // snapshot ä¸­åæ ‡ä¸ºé€»è¾‘åæ ‡ï¼›æˆ‘ä»¬éœ€è¦æŠŠå®ƒç¼©æ”¾ä»¥é€‚é…ç¼©ç•¥å›¾
                    // è®¡ç®— bbox
                    let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
                    const nodes = snapshot.mindNodes || [];
                    const strokesS = snapshot.strokes || [];
                    for (let n of nodes) {
                        minX = Math.min(minX, n.x - (n.w||120)/2);
                        minY = Math.min(minY, n.y - (n.h||40)/2);
                        maxX = Math.max(maxX, n.x + (n.w||120)/2);
                        maxY = Math.max(maxY, n.y + (n.h||40)/2);
                    }
                    for (let s of strokesS) {
                        if (s.points && s.points.length) {
                            for (let p of s.points) { minX = Math.min(minX, p.x); minY = Math.min(minY, p.y); maxX = Math.max(maxX, p.x); maxY = Math.max(maxY, p.y); }
                        } else if (s.start && s.end) {
                            minX = Math.min(minX, s.start.x, s.end.x); minY = Math.min(minY, s.start.y, s.end.y);
                            maxX = Math.max(maxX, s.start.x, s.end.x); maxY = Math.max(maxY, s.start.y, s.end.y);
                        } else if (s.x && s.y) { minX = Math.min(minX, s.x); minY = Math.min(minY, s.y); maxX = Math.max(maxX, s.x); maxY = Math.max(maxY, s.y); }
                    }
                    if (!isFinite(minX)) { minX = 0; minY = 0; maxX = Math.max(200, w); maxY = Math.max(100, h); }
                    const pad = 20;
                    minX -= pad; minY -= pad; maxX += pad; maxY += pad;
                    const sw = maxX - minX; const sh = maxY - minY;
                    const scale = Math.min(w / sw, h / sh);
                    const vx = minX, vy = minY, zoom = scale;
                    const snapLayers = snapshot.layers || [];
                    function layerVisible(layerId) { if (!snapLayers || !snapLayers.length) return true; const l = snapLayers.find(x=>x.id===layerId); return l ? !!l.visible : true; }
                    if (snapLayers && snapLayers.length) {
                        for (let li = 0; li < snapLayers.length; li++) {
                           
                            const layer = snapLayers[li]; if (!layerVisible(layer.id)) continue;
                            for (let s of strokesS) {
                                if ((s.layerId || null) !== layer.id) continue;
                                drawStrokeToCtx(tctx, s, { export: true, viewX: vx, viewY: vy, zoom });
                        }
                        drawMindmapToCtx(tctx, { export: true, viewX: vx, viewY: vy, zoom, canvasW: w, canvasH: h, snapLayers });
                    }
                   }else {
                        for (let s of strokesS) {
                            drawStrokeToCtx(tctx, s, { export: true, viewX: vx, viewY: vy, zoom });
                        }
                        drawMindmapToCtx(tctx, { export: true, viewX: vx, viewY: vy, zoom, canvasW: w, canvasH: h });
                    }
                    return tmp.toDataURL('image/png');
                } catch (e) {
                    return null;
                }
            }

            function pushHistory(desc, type = 'op') {
                // æˆªå–å½“å‰å¿«ç…§ï¼ˆä»…åºåˆ—åŒ–å¿…è¦éƒ¨åˆ†ï¼‰
                const snap = {
                    strokes: strokes.map(s => deepClone(s)),
                    mindNodes: deepClone(mindNodes),
                    mindEdges: deepClone(mindEdges),
                    layers: deepClone(layers),
                    currentLayerId
                };
                const entry = { desc, type, ts: Date.now(), snapshot: snap };
                history.push(entry);
                // é™åˆ¶æœ€å¤§å†å²é•¿åº¦
                if (history.length > MAX_HISTORY) history.shift();
                renderHistoryPanel();
            }

            function renderHistoryPanel() {
                historyListEl.innerHTML = '';
                for (let i = 0; i < history.length; i++) {
                    (function(idx){
                        const entry = history[idx];
                        const row = document.createElement('div');
                        row.style.display = 'flex'; row.style.alignItems = 'center'; row.style.gap = '8px'; row.style.padding = '6px'; row.style.borderBottom = '1px solid #f1f1f1'; row.style.cursor = 'pointer';
                        // color tag for type
                        const tag = document.createElement('div'); tag.style.width = '8px'; tag.style.height = '32px'; tag.style.borderRadius='4px';
                        if (entry.type === 'op') tag.style.background='#6a11cb'; else if (entry.type === 'undo') tag.style.background='#ff9500'; else tag.style.background='#4cd964';
                        row.appendChild(tag);
                        // thumbnail
                        const thumb = document.createElement('img'); thumb.style.width='120px'; thumb.style.height='60px'; thumb.style.objectFit='cover'; thumb.style.border='1px solid #eee'; thumb.style.background='#fff';
                        const dataURL = renderHistoryThumbnail(entry.snapshot, 120, 60);
                        if (dataURL) thumb.src = dataURL; else { thumb.style.display='none'; }
                        row.appendChild(thumb);
                        // desc + ts
                        const meta = document.createElement('div');
                        const title = document.createElement('div'); title.textContent = (idx + 1) + '. ' + entry.desc; title.style.fontSize='12px'; title.style.color='#111';
                        const time = document.createElement('div'); time.textContent = new Date(entry.ts).toLocaleString(); time.style.fontSize='11px'; time.style.color='#777';
                        meta.appendChild(title); meta.appendChild(time);
                        row.appendChild(meta);
                        row.addEventListener('click', function(){ jumpToHistory(idx); });

                        historyListEl.appendChild(row);
                        
                    })(i);

             
                }}
               
            
+              
            

            // jumpToHistory æ”¯æŒä¸€ä¸ªå¯é€‰å‚æ•° optsï¼Œé¿å…åœ¨å†…éƒ¨è°ƒç”¨æ—¶é‡å¤è®°å½• undo
            function jumpToHistory(index, opts = { recordUndo: true }) {
                if (index < 0 || index >= history.length) return;
                // è‹¥éœ€è¦è®°å½• undo æ“ä½œï¼Œåˆ™å…ˆæŠŠå½“å‰çŠ¶æ€ä½œä¸º jumpFrom ä¿å­˜åˆ° undo æ ˆ
                if (opts.recordUndo) {
                    const currSnap = { strokes: deepClone(strokes), mindNodes: deepClone(mindNodes), mindEdges: deepClone(mindEdges), layers: deepClone(layers), currentLayerId };
                    // ä¿å­˜ undo opï¼Œå…¶ä¸­åŒ…å«æ¢å¤åˆ°è·³è½¬å‰çŠ¶æ€çš„å¿«ç…§ï¼Œä»¥åŠ redo æ‰€éœ€çš„ç›®æ ‡å¿«ç…§
                    const targetSnap = deepClone(history[index].snapshot);
                    undoStack.push({ type: 'history-jump', from: currSnap, to: targetSnap });
                    // ç‚¹å‡»å†å²è·³è½¬ä¼šæ¸…ç©º redo æ ˆï¼ˆä¿æŒçº¿æ€§å†å²ï¼‰
                    redoStack.length = 0;
                }
                const snap = history[index].snapshot;
                strokes.length = 0; (snap.strokes || []).forEach(s => strokes.push(deepClone(s)));
                mindNodes.length = 0; (snap.mindNodes || []).forEach(n => mindNodes.push(deepClone(n)));
                mindEdges.length = 0; (snap.mindEdges || []).forEach(e => mindEdges.push(deepClone(e)));
                // æ¢å¤å›¾å±‚ä¿¡æ¯
                if (snap.layers) {
                    layers.length = 0; snap.layers.forEach(l => layers.push(deepClone(l)));
                    currentLayerId = snap.currentLayerId && layers.find(l => l.id === snap.currentLayerId) ? snap.currentLayerId : (layers[0] ? layers[0].id : null);
                    renderLayersPanel();
                }
                invalidateStaticCache();
                redrawCanvas(); updateUndoRedoButtons();
            }

            function deepClone(obj) {
                return JSON.parse(JSON.stringify(obj));
            }

            function strokeEqual(a, b) {
                try { return JSON.stringify(a) === JSON.stringify(b); } catch (e) { return false; }
            }

            function pushStroke(stroke) {
                // ä½¿ç”¨æ·±æ‹·è´ï¼Œä¿è¯è®°å½•çš„å¿«ç…§ä¸ä¼šè¢«åç»­ä¿®æ”¹æ±¡æŸ“
                const s = deepClone(stroke);
                strokes.push(s);
                undoStack.push({ type: 'add', stroke: s });
                redoStack.length = 0;
                pushHistory('æ·»åŠ ç¬”ç”»');
                invalidateStaticCache();
                redrawCanvas();
            }

            function undo() {
                if (undoStack.length === 0) return;
                const op = undoStack.pop();
                if (op.type === 'layer-delete') {
                    const prev = op.prev || { strokes: [], mindNodes: [], layers: [], currentLayerId: null };
                    const currSnapshot = { strokes: deepClone(strokes), mindNodes: deepClone(mindNodes), layers: deepClone(layers), currentLayerId };
                    // æ¢å¤ prev
                    strokes.length = 0; prev.strokes.forEach(s => strokes.push(deepClone(s)));
                    mindNodes.length = 0; prev.mindNodes.forEach(n => mindNodes.push(deepClone(n)));
                    layers.length = 0; (prev.layers || []).forEach(l => layers.push(deepClone(l)));
                    currentLayerId = prev.currentLayerId;
                    renderLayersPanel();
                    // å°†é‡åšæ“ä½œå‹å…¥ redo
                    redoStack.push({ type: 'layer-delete', prev: currSnapshot, next: deepClone(prev) });
                    invalidateStaticCache(); redrawCanvas(); updateUndoRedoButtons(); pushHistory('æ’¤é”€ï¼šå›¾å±‚åˆ é™¤/è¿ç§»');
                    return;
                }
                if (op.type === 'history-jump') {
                    // ä¿®å¤ targetSnap æœªå®šä¹‰
                    const prev = op.from || { strokes: [], mindNodes: [], mindEdges: [] };
                    const targetSnap = op.to || { strokes: [], mindNodes: [], mindEdges: [] };
                    const currSnapshot = { strokes: deepClone(strokes), mindNodes: deepClone(mindNodes), mindEdges: deepClone(mindEdges) };
                    strokes.length = 0; prev.strokes.forEach(s => strokes.push(deepClone(s)));
                    mindNodes.length = 0; prev.mindNodes.forEach(n => mindNodes.push(deepClone(n)));
                    mindEdges.length = 0; prev.mindEdges.forEach(e => mindEdges.push(deepClone(e)));
                    redoStack.push({ type: 'history-jump', from: currSnapshot, to: deepClone(targetSnap) });
                    invalidateStaticCache(); redrawCanvas(); updateUndoRedoButtons(); pushHistory('æ’¤é”€ï¼šå†å²è·³è½¬');
                    return;
                }
                if (op.type === 'add') {
                    // æŒ‰å†…å®¹æŸ¥æ‰¾å¹¶ç§»é™¤æœ€åä¸€ä¸ªåŒ¹é…çš„ç¬”ç”»
                    for (let i = strokes.length - 1; i >= 0; i--) {
                        if (strokeEqual(strokes[i], op.stroke)) {
                            const removed = strokes.splice(i, 1)[0];
                            redoStack.push({ type: 'add', stroke: deepClone(removed) });
                            invalidateStaticCache();
                            redrawCanvas();
                            updateUndoRedoButtons();
                            pushHistory('æ’¤é”€ï¼šç§»é™¤ç¬”ç”»');
                            return;
                        }
                    }
                } else if (op.type === 'clear') {
                    // æ¢å¤ä¹‹å‰çš„ç¬”ç”»
                    const prev = op.prev || [];
                    const currSnapshot = strokes.map(s => deepClone(s));
                    strokes.length = 0;
                    prev.forEach(p => strokes.push(deepClone(p)));
                    redoStack.push({ type: 'clear', prev: currSnapshot });
                    invalidateStaticCache();
                    redrawCanvas();
                    updateUndoRedoButtons();
                    pushHistory('æ’¤é”€ï¼šæ¢å¤æ¸…ç©ºå‰å†…å®¹');
                }
            }

            function redo() {
                if (redoStack.length === 0) return;
                const op = redoStack.pop();
                if (op.type === 'layer-delete') {
                    const target = op.next || { strokes: [], mindNodes: [], layers: [], currentLayerId: null };
                    const currSnapshot = { strokes: deepClone(strokes), mindNodes: deepClone(mindNodes), layers: deepClone(layers), currentLayerId };
                    // åº”ç”¨ target
                    strokes.length = 0; (target.strokes || []).forEach(s => strokes.push(deepClone(s)));
                    mindNodes.length = 0; (target.mindNodes || []).forEach(n => mindNodes.push(deepClone(n)));
                    layers.length = 0; (target.layers || []).forEach(l => layers.push(deepClone(l)));
                    currentLayerId = target.currentLayerId;
                    renderLayersPanel();
                    // æŠŠåå‘åŠ¨ä½œæ”¾å› undo
                    undoStack.push({ type: 'layer-delete', prev: currSnapshot, next: deepClone(target) });
                    invalidateStaticCache(); redrawCanvas(); updateUndoRedoButtons(); pushHistory('é‡åšï¼šå›¾å±‚åˆ é™¤/è¿ç§»');
                    return;
                }
                // æ”¯æŒå†å²è·³è½¬çš„é‡åš
                if (op.type === 'history-jump') {
                    const target = op.to || { strokes: [], mindNodes: [], mindEdges: [] };
                    const currSnapshot = { strokes: deepClone(strokes), mindNodes: deepClone(mindNodes), mindEdges: deepClone(mindEdges) };
                    // åº”ç”¨ target
                    strokes.length = 0; target.strokes.forEach(s => strokes.push(deepClone(s)));
                    mindNodes.length = 0; target.mindNodes.forEach(n => mindNodes.push(deepClone(n)));
                    mindEdges.length = 0; target.mindEdges.forEach(e => mindEdges.push(deepClone(e)));
                    // å°†åå‘åŠ¨ä½œæ”¾å› undo
                    undoStack.push({ type: 'history-jump', from: currSnapshot, to: deepClone(target) });
                    invalidateStaticCache(); redrawCanvas(); updateUndoRedoButtons(); pushHistory('é‡åšï¼šå†å²è·³è½¬');
                    return;
                }
                if (op.type === 'add') {
                    strokes.push(deepClone(op.stroke));
                    undoStack.push({ type: 'add', stroke: deepClone(op.stroke) });
                    invalidateStaticCache();
                    redrawCanvas();
                    updateUndoRedoButtons();
                    pushHistory('é‡åšï¼šæ¢å¤ç¬”ç”»');
                } else if (op.type === 'clear') {
                    const currSnapshot = strokes.map(s => deepClone(s));
                    strokes.length = 0;
                    undoStack.push({ type: 'clear', prev: currSnapshot });
                    invalidateStaticCache();
                    redrawCanvas();
                    updateUndoRedoButtons();
                    pushHistory('é‡åšï¼šæ¸…ç©ºç”»å¸ƒ');
                }
            }

            // ä¿å­˜ï¼šå°†çŸ¢é‡æ¸²æŸ“åˆ°ä¸´æ—¶ canvas å¯¼å‡º PNGï¼ˆæ³¨æ„ï¼šé€»è¾‘ç”»å¸ƒå¯èƒ½å¾ˆå¤§ï¼‰
            function saveImage(centerMindmap = false) {
                const temp = document.createElement('canvas');
                const tctx = temp.getContext('2d');
                // ä¿æŒä¸é€»è¾‘ç”»å¸ƒåŒæ ·å¤§å°ï¼ˆä¿æŒå‘åå…¼å®¹ï¼‰ã€‚æ³¨æ„ï¼šé€»è¾‘ç”»å¸ƒå¾ˆå¤§æ—¶å¯¼å‡ºå¯èƒ½æ¶ˆè€—å¤§é‡å†…å­˜ã€‚
                temp.width = LOGICAL_WIDTH; temp.height = LOGICAL_HEIGHT;
                tctx.fillStyle = 'white'; tctx.fillRect(0, 0, temp.width, temp.height);

                // å¦‚æœè¦æ±‚å±…ä¸­å¯¼å‡ºï¼ˆè‡ªåŠ¨ç¼©æ”¾ä»¥é€‚é…è¾“å‡ºç”»å¸ƒï¼‰ï¼Œæˆ‘ä»¬éœ€è¦ä¸ºç¬”ç”»å’Œæ€ç»´å¯¼å›¾ä½¿ç”¨ç›¸åŒçš„ view/zoom/åç§»ã€‚
                if (centerMindmap && mindNodes.length > 0) {
                    // è®¡ç®—èŠ‚ç‚¹å’Œç¬”ç”»çš„åŒ…å›´ç›’ï¼ˆé€»è¾‘åæ ‡ï¼‰
                    let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
                    for (let n of mindNodes) {
                        minX = Math.min(minX, n.x - (n.w||120)/2);
                        minY = Math.min(minY, n.y - (n.h||40)/2);
                        maxX = Math.max(maxX, n.x + (n.w||120)/2);
                        maxY = Math.max(maxY, n.y + (n.h||40)/2);
                    }
                    for (let s of strokes) {
                        if (s.points && s.points.length) {
                            for (let p of s.points) { minX = Math.min(minX, p.x); minY = Math.min(minY, p.y); maxX = Math.max(maxX, p.x); maxY = Math.max(maxY, p.y); }
                        } else if (s.start && s.end) {
                            minX = Math.min(minX, s.start.x, s.end.x); minY = Math.min(minY, s.start.y, s.end.y);
                            maxX = Math.max(maxX, s.start.x, s.end.x); maxY = Math.max(maxY, s.start.y, s.end.y);
                        } else if (s.x && s.y) { minX = Math.min(minX, s.x); minY = Math.min(minY, s.y); maxX = Math.max(maxX, s.x); maxY = Math.max(maxY, s.y); }
                    }
                    if (!isFinite(minX)) { minX = 0; minY = 0; maxX = Math.max(200, w); maxY = Math.max(100, h); }

                    // paddingï¼ˆé€»è¾‘å•ä½ï¼‰ä¸å®½é«˜
                    const pad = 20;
                    minX -= pad; minY -= pad; maxX += pad; maxY += pad;
                    const sw = maxX - minX; const sh = maxY - minY;

                    // è®¡ç®—ç¼©æ”¾å› å­ï¼Œä½¿åŒ…å›´ç›’åœ¨å¯¼å‡ºç”»å¸ƒå†…æœ€å¤§åŒ–ä½†ç•™æœ‰ä¸€ç‚¹è¾¹è·
                    const scale = Math.min(temp.width / sw, temp.height / sh) * 0.95;

                    // è§†å£å·¦ä¸Šè§’ï¼ˆé€»è¾‘ï¼‰ä»¥åŠç”¨äº drawStrokeToCtx çš„ zoom
                    const vx = minX; const vy = minY; const zoom = scale;

                    // è®¡ç®—åƒç´ åç§»é‡ï¼Œä½¿åŒ…å›´ç›’ä¸­å¿ƒä½äºå¯¼å‡ºç”»å¸ƒä¸­å¿ƒ
                    const bboxCenterX = (minX + maxX) / 2; const bboxCenterY = (minY + maxY) / 2;
                    const bboxCenterPixelX = (bboxCenterX - vx) * zoom; const bboxCenterPixelY = (bboxCenterY - vy) * zoom;
                    const tempOffsetX = temp.width / 2 - bboxCenterPixelX;
                    const tempOffsetY = temp.height / 2 - bboxCenterPixelY;

                    // åœ¨ç»˜åˆ¶ç¬”ç”»æ—¶åº”ç”¨ç›¸åŒçš„å˜æ¢ï¼ˆå¹³ç§»->ç¼©æ”¾ç”± drawStrokeToCtx å†…å¤„ç†ï¼‰ï¼Œä½¿ç”¨ canvas translate æ¥åº”ç”¨åç§»
                    tctx.save();
                    tctx.translate(tempOffsetX, tempOffsetY);
                    // æŒ‰å›¾å±‚é¡ºåºç»˜åˆ¶
                    for (let li = 0; li < layers.length; li++) {
                        const layer = layers[li]; if (!layer.visible) continue;
                        // ç»˜åˆ¶å›¾å±‚å›¾ç‰‡
                        if (layer.image) {
                            const imgW = layer.image.width;
                            const imgH = layer.image.height;
                            const sx = Math.max(0, (0 - viewX) * currentZoom);
                            const sy = Math.max(0, (0 - viewY) * currentZoom);
                            const sw = imgW * currentZoom;
                            const sh = imgH * currentZoom;
                            tctx.save();
                            tctx.globalAlpha = 0.85;
                            tctx.drawImage(layer.image, sx, sy, sw, sh);
                            tctx.restore();
                        }
                        for (let i = 0; i < strokes.length; i++) {
                            const s = strokes[i];
                            if (s.layerId !== layer.id) continue;
                            if (!isStrokeVisible(s, vx, vy, sw, sh)) continue;
                            drawStrokeToCtx(tctx, s, { export: true, viewX: vx, viewY: vy, zoom });
                        }
                    }
                    tctx.restore();

                    // ç»˜åˆ¶æ€ç»´å¯¼å›¾ï¼ˆä½¿ç”¨é¢„è®¡ç®—çš„åç§»é¿å…é‡å¤è®¡ç®—ï¼‰ï¼Œä¼ å…¥å½“å‰ layers
                    drawMindmapToCtx(tctx, { export: true, viewX: vx, viewY: vy, zoom, canvasW: temp.width, canvasH: temp.height, centerMindmap: true, offsetX: tempOffsetX, offsetY: tempOffsetY, snapLayers: layers });

                    // å¯é€‰æ°´å°
                    applyWatermarkToCtx(tctx, temp.width, temp.height);
                    const dataURL = temp.toDataURL('image/png'); const link = document.createElement('a'); link.download = 'æˆ‘çš„ç»˜å›¾.png'; link.href = dataURL; link.click();
                    return;
                }

                // é»˜è®¤è¡Œä¸ºï¼šæŒ‰é€»è¾‘åæ ‡æ•´ä½“å¯¼å‡ºï¼ˆä¸è¿›è¡Œè‡ªåŠ¨ç¼©æ”¾/å±…ä¸­ï¼‰
                // é»˜è®¤æŒ‰å›¾å±‚é¡ºåºç»˜åˆ¶æ‰€æœ‰ç¬”ç”»
                for (let li = 0; li < layers.length; li++) {
                    const layer = layers[li]; if (!layer.visible) continue;
                    for (let i = 0; i < strokes.length; i++) {
                        const s = strokes[i]; if (s.layerId !== layer.id) continue;
                        drawStrokeToCtx(tctx, s, { export: true, zoom: 1 });
                    }
                }
                // ç»˜åˆ¶æ€ç»´å¯¼å›¾ï¼ˆæ•´å›¾å¯¼å‡ºéœ€è€ƒè™‘å±…ä¸­ä¸å­—ä½“ç¼©æ”¾ï¼‰ï¼Œä¼ å…¥ layers
                drawMindmapToCtx(tctx, { export: true, canvasW: temp.width, canvasH: temp.height, centerMindmap, snapLayers: layers });
                // å¯é€‰æ°´å°
                applyWatermarkToCtx(tctx, temp.width, temp.height);
                const dataURL = temp.toDataURL('image/png'); const link = document.createElement('a'); link.download = 'æˆ‘çš„ç»˜å›¾.png'; link.href = dataURL; link.click();
            }

            // ä¿å­˜å½“å‰è§†å£ï¼ˆåªå¯¼å‡ºå½“å‰å¯è§åŒºåŸŸï¼‰
            function saveViewport() {
                const temp = document.createElement('canvas');
                const tctx = temp.getContext('2d');
                // å¯¼å‡ºå°ºå¯¸ä¸º visible canvas åœ¨é€»è¾‘åæ ‡çš„å¤§å°ä¹˜ä»¥å½“å‰ç¼©æ”¾ä»¥ä¿ç•™åƒç´ å¯†åº¦
                const vw = Math.ceil(canvas.width);
                const vh = Math.ceil(canvas.height);
                temp.width = vw; temp.height = vh;
                // ç™½åº•
                tctx.fillStyle = 'white'; tctx.fillRect(0, 0, vw, vh);
                // ç»˜åˆ¶ strokes åˆ° tempï¼šä¼ å…¥ viewX/viewY ä¸ zoom ä¸º currentZoom çš„åå‘ï¼ˆè¿™é‡Œæˆ‘ä»¬æŠŠé€»è¾‘ -> è§†å£ æ˜ å°„ï¼‰
                // åªç»˜åˆ¶å¯è§çš„ç¬”ç”»ä»¥èŠ‚çœæ—¶é—´
                // æŒ‰å›¾å±‚é¡ºåºç»˜åˆ¶å½“å‰å¯è§å›¾å±‚ä¸­çš„å¯è§ç¬”ç”»
                for (let li = 0; li < layers.length; li++) {
                    const layer = layers[li]; if (!layer.visible) continue;
                    for (let i = 0; i < strokes.length; i++) {
                        const s = strokes[i]; if (s.layerId !== layer.id) continue;
                        if (!isStrokeVisible(s, viewX, viewY, canvas.width / currentZoom, canvas.height / currentZoom)) continue;
                        drawStrokeToCtx(tctx, s, { viewX, viewY, zoom: currentZoom });
                    }
                }
                // ç»˜åˆ¶æ€ç»´å¯¼å›¾åˆ°å¯¼å‡ºè§†å£ï¼Œä¼ å…¥ layers
                drawMindmapToCtx(tctx, { export: true, viewX, viewY, zoom: currentZoom, canvasW: temp.width, canvasH: temp.height, snapLayers: layers });
                // å¯é€‰æ°´å°
                applyWatermarkToCtx(tctx, temp.width, temp.height);
                const dataURL = temp.toDataURL('image/png'); const link = document.createElement('a'); link.download = 'viewport.png'; link.href = dataURL; link.click();
            }

            function clearCanvas() {
                if (confirm('ç¡®å®šè¦æ¸…ç©ºæ•´ä¸ªç”»å¸ƒå—ï¼Ÿ(è¿™å°†æ¸…ç©ºæ‰€æœ‰çŸ¢é‡ç¬”ç”»)')) {
                    // è®°å½•å½“å‰å¿«ç…§ä»¥æ”¯æŒæ’¤é”€
                    const prevSnapshot = strokes.map(s => deepClone(s));
                    // æ‰§è¡Œæ¸…ç©º
                    strokes.length = 0; currentStroke = null;
                    // å°† clear æ“ä½œè®°å½•åˆ° undo æ ˆï¼Œredo æ¸…ç©º
                    undoStack.push({ type: 'clear', prev: prevSnapshot });
                    redoStack.length = 0;
                    pushHistory('æ¸…ç©ºç”»å¸ƒ');
                    invalidateStaticCache();
                    redrawCanvas();
                    updateUndoRedoButtons();
                }
            }

            // æŒ‰é’®ç»‘å®šï¼ˆæ–°å¢ï¼‰
            const saveViewportBtn = document.getElementById('saveViewportBtn');
            const undoBtn = document.getElementById('undoBtn');
            const redoBtn = document.getElementById('redoBtn');
            const deleteNodeBtn = document.getElementById('deleteNodeBtn');
            const autoLayoutBtn = document.getElementById('autoLayoutBtn');
            const clearHistoryBtn = document.getElementById('clearHistoryBtn');
            const historyToggleBtn = document.getElementById('historyToggleBtn');
            const historyContentEl = document.getElementById('historyContent');
            // æ¢å¤æŠ˜å çŠ¶æ€ï¼ˆå¯é€‰æŒä¹…åŒ–ï¼‰
            let historyCollapsed = false;
            try {
                if (localStorage.getItem('huihua_history_collapsed') === '1') {
                    historyCollapsed = true;
                    historyContentEl && historyContentEl.classList.add('collapsed');
                    historyToggleBtn && (historyToggleBtn.textContent = 'å±•å¼€');
                }
            } catch (e) {}
            if (historyToggleBtn) {
                historyToggleBtn.addEventListener('click', function(){
                    historyCollapsed = !historyCollapsed;
                    if (!historyContentEl) return;
                    historyContentEl.classList.toggle('collapsed', historyCollapsed);
                    historyToggleBtn.textContent = historyCollapsed ? 'å±•å¼€' : 'æŠ˜å ';
                    try { localStorage.setItem('huihua_history_collapsed', historyCollapsed ? '1' : '0'); } catch(e) {}
                });
            }

            const nodeEditorInput = document.createElement('input');
            nodeEditorInput.type = 'text'; nodeEditorInput.style.position = 'absolute'; nodeEditorInput.style.display = 'none'; nodeEditorInput.style.zIndex = 9999; nodeEditorInput.id = 'nodeEditorInput';
            document.body.appendChild(nodeEditorInput);
            saveBtn.addEventListener('click', function(){
                const doCenter = confirm('æ˜¯å¦åœ¨å¯¼å‡ºæ—¶å°†æ€ç»´å¯¼å›¾å±…ä¸­æ˜¾ç¤ºï¼Ÿ\nç‚¹å‡»â€œç¡®å®šâ€ï¼šå±…ä¸­å¯¼å‡ºï¼›ç‚¹å‡»â€œå–æ¶ˆâ€ï¼šæŒ‰é€»è¾‘åæ ‡å¯¼å‡ºã€‚');
                saveImage(doCenter);
            });
            clearHistoryBtn && clearHistoryBtn.addEventListener('click', function(){ if (confirm('æ¸…ç©ºå†å²è®°å½•ï¼Ÿæ­¤æ“ä½œæ— æ³•æ’¤é”€ã€‚')) { history.length = 0; renderHistoryPanel(); invalidateStaticCache(); updateUndoRedoButtons(); } });
            saveViewportBtn.addEventListener('click', saveViewport);
            clearBtn.addEventListener('click', clearCanvas);
            undoBtn.addEventListener('click', undo);
            redoBtn.addEventListener('click', redo);
            deleteNodeBtn.addEventListener('click', function(){ if (selectedNode) deleteSelectedNode(); });
            autoLayoutBtn.addEventListener('click', function(){ autoLayout(); undoStack.push({ type: 'mind-auto-layout', prev: deepClone({ nodes: mindNodes, edges: mindEdges }) }); redoStack.length = 0; updateUndoRedoButtons(); pushHistory('æ€ç»´å¯¼å›¾ï¼šè‡ªåŠ¨å¸ƒå±€'); });

            // æ°´å°å…ƒç´ å·²å­˜åœ¨: watermarkToggle, watermarkText
            function applyWatermarkToCtx(tctx, canvasWidth, canvasHeight) {
                if (!watermarkToggle.checked) return;
                const text = watermarkTextInput.value || 'Â©';
                const opacity = parseFloat(document.getElementById('watermarkOpacity')?.value || 0.5);
                const color = watermarkColorInput?.value || '#000000';
                const fontSize = parseInt(watermarkFontSizeInput?.value || '24', 10);
                const position = watermarkPositionSelect?.value || 'right-bottom';
                tctx.save();
                tctx.globalAlpha = opacity;
                tctx.fillStyle = color;
                tctx.font = fontSize + 'px Arial';
                let x = 0, y = 0;
                tctx.textBaseline = 'bottom';
                tctx.textAlign = 'left';
                switch(position) {
                    case 'right-bottom':
                        x = canvasWidth - 10;
                        y = canvasHeight - 10;
                        tctx.textAlign = 'right';
                        tctx.textBaseline = 'bottom';
                        break;
                    case 'left-bottom':
                        x = 10;
                        y = canvasHeight - 10;
                        tctx.textAlign = 'left';
                        tctx.textBaseline = 'bottom';
                        break;
                    case 'right-top':
                        x = canvasWidth - 10;
                        y = 10 + fontSize;
                        tctx.textAlign = 'right';
                        tctx.textBaseline = 'top';
                        break;
                    case 'left-top':
                        x = 10;
                        y = 10 + fontSize;
                        tctx.textAlign = 'left';
                        tctx.textBaseline = 'top';
                        break;
                    case 'center':
                        x = canvasWidth / 2;
                        y = canvasHeight / 2;
                        tctx.textAlign = 'center';
                        tctx.textBaseline = 'middle';
                        break;
                }
                tctx.fillText(text, x, y);
                tctx.restore();
            }

            // é€‰ä¸­èŠ‚ç‚¹ & åˆ é™¤
            let selectedNode = null;
            function selectNode(node) {
                selectedNode = node;
                if (!node) {
                    nodeEditorInput.style.display = 'none';
                    return;
                }
                // åœ¨å±å¹•ä¸Šæ”¾ç½®ç¼–è¾‘è¾“å…¥æ¡†
                const screenX = (node.x - viewX) * currentZoom + canvas.getBoundingClientRect().left;
                const screenY = (node.y - viewY) * currentZoom + canvas.getBoundingClientRect().top;
                nodeEditorInput.style.left = (screenX - 60) + 'px';
                nodeEditorInput.style.top = (screenY - 12) + 'px';
                nodeEditorInput.style.width = '120px';
                nodeEditorInput.value = node.text || '';
                nodeEditorInput.style.display = 'block';
                nodeEditorInput.focus();
            }

            nodeEditorInput.addEventListener('blur', function(){
                if (selectedNode) {
                    // å¦‚æœèŠ‚ç‚¹æ‰€åœ¨å›¾å±‚è¢«é”å®šï¼Œåˆ™ä¸å…è®¸ä¿å­˜ç¼–è¾‘
                    const nodeLayer = layers.find(l => l.id === selectedNode.layerId);
                    if (nodeLayer && nodeLayer.locked) {
                        alert('è¯¥å›¾å±‚å·²é”å®šï¼Œç¼–è¾‘æ— æ•ˆ');
                        nodeEditorInput.style.display = 'none'; selectedNode = null; return;
                    }
                    const prev = deepClone(selectedNode);
                    selectedNode.text = nodeEditorInput.value;
                    undoStack.push({ type: 'mind-edit-node', id: selectedNode.id, prev: prev, next: deepClone(selectedNode) });
                    redoStack.length = 0; updateUndoRedoButtons(); pushHistory('æ€ç»´å¯¼å›¾ï¼šç¼–è¾‘èŠ‚ç‚¹'); invalidateStaticCache(); redrawCanvas();
                }
                nodeEditorInput.style.display='none';
            });

            function deleteSelectedNode() {
                if (!selectedNode) return;
                const id = selectedNode.id;
                const prevNodes = deepClone(mindNodes);
                const prevEdges = deepClone(mindEdges);
                // remove node and connected edges
                for (let i = mindNodes.length - 1; i >= 0; i--) if (mindNodes[i].id === id) mindNodes.splice(i,1);
                for (let i = mindEdges.length - 1; i >= 0; i--) if (mindEdges[i].from === id || mindEdges[i].to === id) mindEdges.splice(i,1);
                undoStack.push({ type: 'mind-delete-node', prevNodes, prevEdges });
                redoStack.length = 0; updateUndoRedoButtons();
                pushHistory('æ€ç»´å¯¼å›¾ï¼šåˆ é™¤èŠ‚ç‚¹');
                invalidateStaticCache();
                selectedNode = null; nodeEditorInput.style.display = 'none'; redrawCanvas();
            }

            function autoLayout() {
                // ç®€å•ç¯å½¢å¸ƒå±€
                const centerX = LOGICAL_WIDTH / 2;
                const centerY = LOGICAL_HEIGHT / 2;
                const r = Math.min(LOGICAL_WIDTH, LOGICAL_HEIGHT) / 4;
                const n = mindNodes.length;
                for (let i = 0; i < n; i++) {
                    const a = (i / n) * Math.PI * 2;
                    mindNodes[i].x = centerX + r * Math.cos(a);
                    mindNodes[i].y = centerY + r * Math.sin(a);
                }
                invalidateStaticCache();
                redrawCanvas();
            }

            // åœ¨ undo/redo å˜åŒ–åæ›´æ–°æŒ‰é’®å¯ç”¨æ€§
            function updateUndoRedoButtons() {
                undoBtn.disabled = undoStack.length === 0;
                redoBtn.disabled = redoStack.length === 0;
            }

            // wrap push into helper that updates buttons
            const originalPushStroke = pushStroke;
            pushStroke = function(stroke) { originalPushStroke(stroke); updateUndoRedoButtons(); };

            // mindmap tool bindings: click node with ctrl to start edge create, or drag to move
            function createMindNode(x, y) {
                const node = { id: mindNextId++, x, y, w: 140, h: 48, text: 'æ–°èŠ‚ç‚¹', layerId: currentLayerId };
                mindNodes.push(node);
                return node;
            }

            function findNodeAtLogical(x, y) {
                for (let i = mindNodes.length - 1; i >= 0; i--) {
                    const n = mindNodes[i];
                    const halfW = (n.w || 120) / 2;
                    const halfH = (n.h || 40) / 2;
                    if (x >= n.x - halfW && x <= n.x + halfW && y >= n.y - halfH && y <= n.y + halfH) return n;
                }
                return null;
            }

            // åˆ¤æ–­ç¬”ç”»æ˜¯å¦å’Œè§†å£ç›¸äº¤ï¼ˆç²—ç•¥åŒ…å›´ç›’ï¼‰
            function isStrokeVisible(s, vx, vy, vw, vh) {
                if (s.points && s.points.length) {
                    for (let p of s.points) {
                        if (p.x >= vx && p.x <= vx + vw && p.y >= vy && p.y <= vy + vh) return true;
                    }
                    return false;
                }
                if (s.start && s.end) {
                    const minx = Math.min(s.start.x, s.end.x), maxx = Math.max(s.start.x, s.end.x);
                    const miny = Math.min(s.start.y, s.end.y), maxy = Math.max(s.start.y, s.end.y);
                    return !(maxx < vx || minx > vx + vw || maxy < vy || miny > vy + vh);
                }
                if (s.x && s.y) {
                    return s.x >= vx && s.x <= vx + vw && s.y >= vy && s.y <= vy + vh;
                }
                return true;
            }

            // åœ¨ä»»æ„ ctx ä¸Šç»˜åˆ¶æ€ç»´å¯¼å›¾ï¼ˆæ”¯æŒå¯¼å‡ºå’Œè§†å£æ¨¡å¼ï¼‰
            function drawMindmapToCtx(tctx, opts = {}) {
                const isExport = !!opts.export;
                const vx = opts.viewX || 0;
                const vy = opts.viewY || 0;
                const zoom = opts.zoom || 1;
                const canvasW = opts.canvasW || (canvas.width);
                const canvasH = opts.canvasH || (canvas.height);
                const centerMindmap = !!opts.centerMindmap;

                // å¦‚æœè¦æ±‚å±…ä¸­å¯¼å‡ºï¼Œè®¡ç®—èŠ‚ç‚¹åŒ…å›´ç›’å¹¶å†³å®šä¸€ä¸ªä¸´æ—¶åç§»ï¼Œç”¨äºç»˜åˆ¶åˆ°å¯¼å‡ºç”»å¸ƒä¸­å¿ƒ
                let tempOffsetX = 0, tempOffsetY = 0;
                // å¦‚æœå¤–éƒ¨ä¼ å…¥äº†é¢„è®¡ç®—çš„åç§»ï¼ˆä¾‹å¦‚ saveImageï¼‰ï¼Œä¼˜å…ˆä½¿ç”¨
                if (typeof opts.offsetX === 'number' && typeof opts.offsetY === 'number') {
                    tempOffsetX = opts.offsetX; tempOffsetY = opts.offsetY;
                } else if (centerMindmap && mindNodes.length > 0) {
                    let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
                    for (let n of mindNodes) {
                        minX = Math.min(minX, n.x - (n.w||120)/2);
                        minY = Math.min(minY, n.y - (n.h||40)/2);
                        maxX = Math.max(maxX, n.x + (n.w||120)/2);
                        maxY = Math.max(maxY, n.y + (n.h||40)/2);
                    }
                    const nodesW = maxX - minX;
                    const nodesH = maxY - minY;
                    // ç›®æ ‡ä¸­å¿ƒï¼ˆç”»å¸ƒä¸­å¿ƒï¼‰åœ¨åƒç´ åæ ‡ä¸­
                    const canvasCenterX = canvasW / 2;
                    const canvasCenterY = canvasH / 2;
                    // è®¡ç®—å½“å‰åŒ…å›´ç›’ä¸­å¿ƒåœ¨é€»è¾‘åæ ‡ç³»ä¸‹
                    const bboxCenterX = (minX + maxX) / 2;
                    const bboxCenterY = (minY + maxY) / 2;
                    // å°† bboxCenter æ˜ å°„åˆ°å¯¼å‡ºåƒç´ åæ ‡ï¼š (bboxCenter - vx) * zoom
                    const bboxCenterPixelX = (bboxCenterX - vx) * zoom;
                    const bboxCenterPixelY = (bboxCenterY - vy) * zoom;
                    // éœ€è¦çš„åƒç´ åç§»é‡ = canvasCenter - bboxCenterPixel
                    tempOffsetX = canvasCenterX - bboxCenterPixelX;
                    tempOffsetY = canvasCenterY - bboxCenterPixelY;
                }

                // æ”¯æŒæŒ‰å›¾å±‚ç»˜åˆ¶ï¼šä¼˜å…ˆä½¿ç”¨ opts.snapLayersï¼ˆå¯¼å‡º/å†å²ç¼©ç•¥å›¾æä¾›ï¼‰ï¼Œå¦åˆ™ä½¿ç”¨å…¨å±€ layers
                const useLayers = opts.snapLayers || layers;
                const layerVisible = (layerId) => {
                    if (!useLayers || !useLayers.length) return true;
                    const l = useLayers.find(x => x.id === layerId);
                    return l ? !!l.visible : true;
                };

                for (let li = 0; li < useLayers.length; li++) {
                    const layer = useLayers[li]; if (!layer || !layer.visible) continue;
                    // edges
                    tctx.save();
                    tctx.strokeStyle = '#444';
                    tctx.lineWidth = 2 * zoom;
                    for (let e of mindEdges) {
                        const from = mindNodes.find(n => n.id === e.from);
                        const to = mindNodes.find(n => n.id === e.to);
                        if (!from || !to) continue;
                        // ä»…å½“è¾¹ä»»ä¸€ç«¯ç‚¹å±äºå½“å‰ layer æ—¶ç»˜åˆ¶ï¼ˆä¿æŒç®€æ´ï¼‰
                        if (from.layerId !== layer.id && to.layerId !== layer.id) continue;
                        if (opts.viewX !== undefined && !((from.x >= vx && from.x <= vx + canvasW/zoom) || (to.x >= vx && to.x <= vx + canvasW/zoom))) continue;
                        const fx = (from.x - vx) * zoom + tempOffsetX;
                        const fy = (from.y - vy) * zoom + tempOffsetY;
                        const tx = (to.x - vx) * zoom + tempOffsetX;
                        const ty = (to.y - vy) * zoom + tempOffsetY;
                        tctx.beginPath(); tctx.moveTo(fx, fy); tctx.lineTo(tx, ty); tctx.stroke();
                    }
                    tctx.restore();

                    // nodes
                    for (let n of mindNodes) {
                        if (n.layerId !== layer.id) continue;
                        if (opts.viewX !== undefined) {
                            if (n.x < vx - 100/zoom || n.x > vx + canvasW/zoom + 100/zoom || n.y < vy - 60/zoom || n.y > vy + canvasH/zoom + 60/zoom) continue;
                        }
                        const nx = (n.x - vx) * zoom + tempOffsetX;
                        const ny = (n.y - vy) * zoom + tempOffsetY;
                        const w = (n.w || 120) * zoom;
                        const h = (n.h || 40) * zoom;
                        tctx.save();
                        tctx.fillStyle = '#fff8dc';
                        tctx.strokeStyle = '#333';
                        tctx.lineWidth = 1;
                        tctx.shadowColor = 'rgba(0,0,0,0.08)'; tctx.shadowBlur = 8;
                        roundRect(tctx, nx - w/2, ny - h/2, w, h, 8 * zoom, true, true);
                        tctx.restore();
                        tctx.save();
                        let baseFont;
                        if (isExport) {
                            const gw = (n.w || 120);
                            baseFont = Math.max(12, Math.min(28, gw / 6));
                        } else {
                            baseFont = Math.max(10, Math.min(24, 14 * zoom));
                        }
                        tctx.fillStyle = '#111';
                        tctx.font = `${baseFont}px Arial`;
                        tctx.textAlign = 'center'; tctx.textBaseline = 'middle';
                        tctx.fillText(n.text || ('èŠ‚ç‚¹ ' + n.id), nx, ny);
                        tctx.restore();
                    }
                }
            }

            // Shift ä¸ºè¿çº¿å¿«æ·é”®ï¼šæŒ‰ä¸‹ Shift å¹¶ç‚¹å‡»èŠ‚ç‚¹å¼€å§‹è¿çº¿
            let shiftEdgeStart = null;

            // å½“å·¥å…·åˆ‡æ¢åˆ° mindmap æ—¶ï¼Œå…è®¸åœ¨èŠ‚ç‚¹ä¸ŠæŒ‰ Ctrl å¼€å§‹è¿çº¿
            canvas.addEventListener('dblclick', function(e) {
                if (currentTool !== 'mindmap') return;
                const [rawX, rawY] = getEventCoordinates(e);
                const [x, y] = screenToLogical(rawX, rawY);
                const n = findNodeAtLogical(x, y);
                if (n) {
                    const nodeLayer = layers.find(l => l.id === n.layerId);
                    if (nodeLayer && nodeLayer.locked) { alert('è¯¥å›¾å±‚å·²é”å®šï¼Œæ— æ³•ç¼–è¾‘èŠ‚ç‚¹'); return; }
                    // ä¿®æ”¹èŠ‚ç‚¹æ–‡æœ¬ï¼ˆç®€å•å®ç°ï¼špromptï¼‰
                    const t = prompt('ç¼–è¾‘èŠ‚ç‚¹æ–‡æœ¬ï¼š', n.text || '');
                    if (t !== null) {
                        const prev = deepClone(n);
                        n.text = t;
                        undoStack.push({ type: 'mind-edit-node', id: n.id, prev: prev, next: deepClone(n) });
                        redoStack.length = 0;
                        updateUndoRedoButtons();
                        pushHistory('æ€ç»´å¯¼å›¾ï¼šç¼–è¾‘èŠ‚ç‚¹');
                        redrawCanvas();
                    }
                }
            });

            // å³é”®åœ¨èŠ‚ç‚¹ä¸Šå¼€å§‹åˆ›å»ºè¾¹ï¼ˆä¿ç•™æ—§äº¤äº’ï¼‰ï¼Œä»¥åŠ Shift + ç‚¹å‡»/é‡Šæ”¾ ç”¨äºæ›´ç›´è§‚çš„è¿çº¿
            canvas.addEventListener('contextmenu', function(e) {
                if (currentTool !== 'mindmap') return;
                e.preventDefault();
                const [rawX, rawY] = getEventCoordinates(e);
                const [x, y] = screenToLogical(rawX, rawY);
                const n = findNodeAtLogical(x, y);
                if (n) {
                    creatingEdgeFrom = n;
                }
            });

            // Shift é”®è¿çº¿ UXï¼šmousedown åœ¨èŠ‚ç‚¹ä¸Šä¸” shiftKey åˆ™è®°ä¸ºè¿çº¿å¼€å§‹ï¼Œmouseup åœ¨ç›®æ ‡èŠ‚ç‚¹åˆ™å®Œæˆ
            canvas.addEventListener('mousedown', function(e) {
                if (currentTool !== 'mindmap') return;
                const [rawX, rawY] = getEventCoordinates(e);
                const [x, y] = screenToLogical(rawX, rawY);
                if (e.shiftKey) {
                    const n = findNodeAtLogical(x, y);
                    if (n) {
                        shiftEdgeStart = n;
                        creatingEdgeFrom = n;
                    }
                }
            });

            canvas.addEventListener('mouseup', function(e) {
                if (currentTool !== 'mindmap') return;
                if (!shiftEdgeStart) return;
                const [rawX, rawY] = getEventCoordinates(e);
                const [x, y] = screenToLogical(rawX, rawY);
                const target = findNodeAtLogical(x, y);
                if (target && target.id !== shiftEdgeStart.id) {
                    mindEdges.push({ from: shiftEdgeStart.id, to: target.id });
                    undoStack.push({ type: 'mind-add-edge', edge: deepClone({ from: shiftEdgeStart.id, to: target.id }) });
                    redoStack.length = 0; updateUndoRedoButtons(); pushHistory('æ€ç»´å¯¼å›¾ï¼šæ·»åŠ è¿çº¿');
                    invalidateStaticCache();
                    redrawCanvas();
                }
                shiftEdgeStart = null; creatingEdgeFrom = null;
            });

            // å¿«æ·é”®æ‰©å±•ï¼šCtrl+Z / Ctrl+Y
            document.addEventListener('keydown', function(e) {
                if ((e.ctrlKey || e.metaKey) && e.key.toLowerCase() === 'z') { e.preventDefault(); undo(); }
                if ((e.ctrlKey || e.metaKey) && (e.key.toLowerCase() === 'y' || (e.shiftKey && e.key.toLowerCase() === 'z'))) { e.preventDefault(); redo(); }
            });

            // å…¨å±ç›¸å…³
            const fullscreenBtn = document.getElementById('fullscreenBtn');
            const container = document.querySelector('.container');
            const toolbar = document.querySelector('.toolbar');
            const actions = document.querySelector('.actions');
            const appBody = document.querySelector('.app-body');
            const canvasContainer = document.querySelector('.canvas-container');
            let isFullscreen = false;
            let toolbarExpanded = false;
            let actionsExpanded = false;
            let toolbarToggleBtn = null;
            let actionsToggleBtn = null;

            function enterFullscreen() {
                isFullscreen = true;
                container.classList.add('fullscreen-mode');
                toolbar.classList.add('fullscreen-toolbar-collapsed');
                actions.classList.add('fullscreen-actions-collapsed');
                canvasContainer.style.height = '100vh';
                appBody.style.height = '100vh';
                toolbarExpanded = false;
                actionsExpanded = false;
                // æ·»åŠ æŠ˜å /å±•å¼€æŒ‰é’®
                toolbarToggleBtn = document.createElement('button');
                toolbarToggleBtn.className = 'fullscreen-toggle-btn';
                toolbarToggleBtn.title = 'å±•å¼€å·¥å…·æ ';
                toolbarToggleBtn.innerHTML = 'â˜°';
                toolbarToggleBtn.onclick = function() {
                    toolbarExpanded = !toolbarExpanded;
                    if (toolbarExpanded) {
                        toolbar.classList.remove('fullscreen-toolbar-collapsed');
                        toolbar.classList.add('fullscreen-toolbar-expanded');
                        toolbarToggleBtn.title = 'æŠ˜å å·¥å…·æ ';
                        toolbarToggleBtn.innerHTML = 'â®œ';
                    } else {
                        toolbar.classList.remove('fullscreen-toolbar-expanded');
                        toolbar.classList.add('fullscreen-toolbar-collapsed');
                        toolbarToggleBtn.title = 'å±•å¼€å·¥å…·æ ';
                        toolbarToggleBtn.innerHTML = 'â˜°';
                    }
                };
                container.appendChild(toolbarToggleBtn);

                actionsToggleBtn = document.createElement('button');
                actionsToggleBtn.className = 'fullscreen-actions-toggle-btn';
                actionsToggleBtn.title = 'å±•å¼€æ§åˆ¶æŒ‰é’®';
                actionsToggleBtn.innerHTML = 'â¬†';
                actionsToggleBtn.onclick = function() {
                    actionsExpanded = !actionsExpanded;
                    if (actionsExpanded) {
                        actions.classList.remove('fullscreen-actions-collapsed');
                        actions.classList.add('fullscreen-actions-expanded');
                        actionsToggleBtn.title = 'æŠ˜å æ§åˆ¶æŒ‰é’®';
                        actionsToggleBtn.innerHTML = 'â¬‡';
                    } else {
                        actions.classList.remove('fullscreen-actions-expanded');
                        actions.classList.add('fullscreen-actions-collapsed');
                        actionsToggleBtn.title = 'å±•å¼€æ§åˆ¶æŒ‰é’®';
                        actionsToggleBtn.innerHTML = 'â¬†';
                    }
                };
                container.appendChild(actionsToggleBtn);

                fullscreenBtn.style.display = 'none';
                setupCanvas();
            }

            function exitFullscreen() {
                isFullscreen = false;
                container.classList.remove('fullscreen-mode');
                toolbar.classList.remove('fullscreen-toolbar-collapsed');
                toolbar.classList.remove('fullscreen-toolbar-expanded');
                actions.classList.remove('fullscreen-actions-collapsed');
                actions.classList.remove('fullscreen-actions-expanded');
                canvasContainer.style.height = '';
                appBody.style.height = '';
                if (toolbarToggleBtn) { toolbarToggleBtn.remove(); toolbarToggleBtn = null; }
                if (actionsToggleBtn) { actionsToggleBtn.remove(); actionsToggleBtn = null; }
                fullscreenBtn.style.display = '';
                setupCanvas();
            }

            fullscreenBtn.addEventListener('click', function() {
                enterFullscreen();
                // æµè§ˆå™¨å…¨å±API
                if (container.requestFullscreen) container.requestFullscreen();
                else if (container.webkitRequestFullscreen) container.webkitRequestFullscreen();
                else if (container.mozRequestFullScreen) container.mozRequestFullScreen();
                else if (container.msRequestFullscreen) container.msRequestFullscreen();
            });

            document.addEventListener('keydown', function(e) {
                if (isFullscreen && (e.key === 'Escape' || e.key === 'Esc')) {
                    if (document.exitFullscreen) document.exitFullscreen();
                    else if (document.webkitExitFullscreen) document.webkitExitFullscreen();
                    else if (document.mozCancelFullScreen) document.mozCancelFullScreen();
                    else if (document.msExitFullscreen) document.msExitFullscreen();
                    exitFullscreen();
                }
            });

            document.addEventListener('fullscreenchange', function() {
                if (!document.fullscreenElement && isFullscreen) {
                    exitFullscreen();
                }
            });

            // ...existing code...
        });
    </script>
</body>
</html>