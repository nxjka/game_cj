<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ÁªòÂõæÂ∑•ÂÖ∑</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        
        body {
            background: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
        }
        
        .container {
            max-width: 1200px;
            width: 100%;
            background-color: white;
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.1);
            overflow: hidden;
        }
        
        header {
            background: linear-gradient(90deg, #6a11cb 0%, #2575fc 100%);
            color: white;
            padding: 20px;
            text-align: center;
        }
        
        h1 {
            font-size: 2.2rem;
            margin-bottom: 10px;
        }
        
        .subtitle {
            font-size: 1rem;
            opacity: 0.9;
        }
        
        .app-body {
            display: flex;
            flex-wrap: wrap;
            padding: 20px;
        }
        
        .toolbar {
            flex: 1;
            min-width: 200px;
            padding: 15px;
            background-color: #f8f9fa;
            border-radius: 10px;
            margin-right: 20px;
            max-height: 600px;
            overflow-y: auto;
        }
        
        .tool-section {
            margin-bottom: 25px;
        }
        
        .tool-section h3 {
            margin-bottom: 15px;
            color: #444;
            font-size: 1.1rem;
            border-bottom: 1px solid #ddd;
            padding-bottom: 8px;
        }
        
        .tools {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
        }
        
        .tool-btn {
            width: 45px;
            height: 45px;
            border: none;
            border-radius: 8px;
            background-color: white;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
            transition: all 0.2s;
        }
        
        .tool-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0,0,0,0.15);
        }
        
        .tool-btn.active {
            background-color: #4d7cfe;
            color: white;
        }
        
        .color-palette {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
        }
        
        .color-option {
            width: 30px;
            height: 30px;
            border-radius: 50%;
            cursor: pointer;
            transition: transform 0.2s;
            border: 2px solid transparent;
        }
        
        .color-option:hover {
            transform: scale(1.1);
        }
        
        .color-option.active {
            border: 2px solid #333;
            transform: scale(1.1);
        }
        
        .slider-container {
            margin-top: 10px;
        }
        
        .slider-container label {
            display: block;
            margin-bottom: 8px;
            color: #555;
        }
        
        input[type="range"] {
            width: 100%;
        }
        
        select {
            width: 100%;
            padding: 8px;
            border-radius: 5px;
            border: 1px solid #ddd;
            background-color: white;
        }
        
        .canvas-container {
            flex: 3;
            min-width: 300px;
            background-color: #f0f0f0;
            border-radius: 10px;
            overflow: hidden;
            box-shadow: 0 5px 15px rgba(0,0,0,0.05);
            position: relative;
            height: 600px;
        }
        
        canvas {
            display: block;
            background-color: white;
            cursor: crosshair;
        }
        
        .text-input-container {
            position: absolute;
            display: none;
            border: 2px dashed #4d7cfe;
            padding: 5px;
            background-color: rgba(255, 255, 255, 0.9);
            box-shadow: 0 0 10px rgba(0,0,0,0.1);
        }
        
        .text-input {
            width: 100%;
            height: 100%;
            border: none;
            outline: none;
            background: transparent;
            resize: none;
            font-family: Arial, sans-serif;
            font-size: 16px;
        }
        
        .zoom-controls {
            position: absolute;
            bottom: 15px;
            right: 15px;
            display: flex;
            gap: 10px;
            background: rgba(255, 255, 255, 0.8);
            padding: 8px;
            border-radius: 8px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }
        
        .zoom-btn {
            width: 36px;
            height: 36px;
            border: none;
            border-radius: 50%;
            background-color: #4d7cfe;
            color: white;
            font-weight: bold;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
        }
        
        .zoom-level {
            display: flex;
            align-items: center;
            padding: 0 10px;
            font-weight: bold;
            color: #333;
        }
        
        .pan-controls {
            position: absolute;
            bottom: 15px;
            left: 15px;
            display: flex;
            flex-direction: column;
            gap: 5px;
            background: rgba(255, 255, 255, 0.8);
            padding: 8px;
            border-radius: 8px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }
        
        .pan-btn {
            width: 36px;
            height: 36px;
            border: none;
            border-radius: 50%;
            background-color: #4d7cfe;
            color: white;
            font-weight: bold;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
        }
        
        .pan-btn:hover {
            background-color: #3a6ae0;
        }
        
        .actions {
            display: flex;
            justify-content: center;
            gap: 15px;
            margin-top: 20px;
            padding: 0 20px 20px;
        }
        
        .action-btn {
            padding: 12px 25px;
            border: none;
            border-radius: 8px;
            background: linear-gradient(90deg, #6a11cb 0%, #2575fc 100%);
            color: white;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
            box-shadow: 0 4px 10px rgba(37, 117, 252, 0.3);
        }
        
        .action-btn:hover {
            transform: translateY(-3px);
            box-shadow: 0 6px 15px rgba(37, 117, 252, 0.4);
        }
        
        .action-btn.clear {
            background: linear-gradient(90deg, #ff416c 0%, #ff4b2b 100%);
            box-shadow: 0 4px 10px rgba(255, 65, 108, 0.3);
        }
        
        .action-btn.clear:hover {
            box-shadow: 0 6px 15px rgba(255, 65, 108, 0.4);
        }
        
        .shortcuts {
            margin-top: 20px;
            font-size: 0.85rem;
            color: #666;
        }
        
        .shortcuts h4 {
            margin-bottom: 10px;
            color: #444;
        }
        
        .shortcut-item {
            display: flex;
            justify-content: space-between;
            margin-bottom: 5px;
        }
        
        footer {
            margin-top: 20px;
            text-align: center;
            color: #666;
            font-size: 0.9rem;
        }
        
        @media (max-width: 768px) {
            .app-body {
                flex-direction: column;
            }
            
            .toolbar {
                margin-right: 0;
                margin-bottom: 20px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>ÁªòÂõæÂ∑•ÂÖ∑</h1>
            <p class="subtitle">Â§öÂΩ©ÁªòÂõæ</p>
        </header>
        
        <div class="app-body">
            <div class="toolbar">
                <div class="tool-section">
                    <h3>ÁªòÂõæÂ∑•ÂÖ∑</h3>
                    <div class="tools">
                        <button class="tool-btn active" id="pencil" title="ÁîªÁ¨î">‚úèÔ∏è</button>
                        <button class="tool-btn" id="eraser" title="Ê©°ÁöÆÊì¶">ü©Ω</button>
                        <button class="tool-btn" id="line" title="Áõ¥Á∫ø">üìè</button>
                        <button class="tool-btn" id="rectangle" title="Áü©ÂΩ¢">‚¨ú</button>
                        <button class="tool-btn" id="circle" title="ÂúÜÂΩ¢">‚≠ï</button>
                        <button class="tool-btn" id="text" title="ÊñáÊú¨">T</button>
                        <button class="tool-btn" id="mindmap" title="ÊÄùÁª¥ÂØºÂõæ">üß†</button>
                        <button class="tool-btn" id="pan" title="ÁßªÂä®ÁîªÂ∏É">‚úã</button>
                    </div>
                </div>

                <div class="tool-section">
                    <h3>ÂØºÂá∫ËÆæÁΩÆ</h3>
                    <div style="display:flex;gap:8px;align-items:center;">
                        <input type="checkbox" id="watermarkToggle">
                        <label for="watermarkToggle">Ê∑ªÂä†Ê∞¥Âç∞</label>
                    </div>
                    <div style="margin-top:8px;">
                        <input type="text" id="watermarkText" placeholder="Ê∞¥Âç∞ÊñáÊú¨Ôºà‰æãÂ¶Ç: ¬© ÊàëÔºâ" style="width:100%;padding:6px;border-radius:4px;border:1px solid #ddd;">
                    </div>
                    <div style="margin-top:8px;display:flex;gap:8px;align-items:center;">
                        <label for="watermarkOpacity">ÈÄèÊòéÂ∫¶</label>
                        <input id="watermarkOpacity" type="range" min="0" max="1" step="0.1" value="0.5" style="flex:1;">
                    </div>
                </div>
                
                <div class="tool-section">
                    <h3>È¢úËâ≤ÈÄâÊã©</h3>
                    <div class="color-palette">
                        <div class="color-option active" style="background-color: #000000;" data-color="#000000"></div>
                        <div class="color-option" style="background-color: #ff3b30;" data-color="#ff3b30"></div>
                        <div class="color-option" style="background-color: #4cd964;" data-color="#4cd964"></div>
                        <div class="color-option" style="background-color: #007aff;" data-color="#007aff"></div>
                        <div class="color-option" style="background-color: #5856d6;" data-color="#5856d6"></div>
                        <div class="color-option" style="background-color: #ff9500;" data-color="#ff9500"></div>
                        <div class="color-option" style="background-color: #ffcc00;" data-color="#ffcc00"></div>
                        <div class="color-option" style="background-color: #8e8e93;" data-color="#8e8e93"></div>
                    </div>
                </div>

                <div class="tool-section" id="layersSection">
                    <h3>ÂõæÂ±Ç</h3>
                    <div style="display:flex;gap:8px;margin-bottom:8px;">
                        <button id="addLayerBtn" class="tool-btn" style="width:auto;padding:6px 8px;">Ê∑ªÂä†ÂõæÂ±Ç</button>
                        <button id="removeLayerBtn" class="tool-btn" style="width:auto;padding:6px 8px;">Âà†Èô§ÂõæÂ±Ç</button>
                    </div>
                    <div id="layersList" style="max-height:180px;overflow:auto;border:1px solid #eee;padding:6px;background:#fff;"></div>
                </div>
                
                <div class="tool-section">
                    <h3>ÁîªÁ¨îËÆæÁΩÆ</h3>
                    <div class="slider-container">
                        <label for="brushSize">ÁîªÁ¨îÁ≤óÁªÜ: <span id="brushSizeValue">5</span>px</label>
                        <input type="range" id="brushSize" min="1" max="50" value="5">
                    </div>
                </div>
                
                <div class="tool-section" id="textSettings">
                    <h3>ÊñáÊú¨ËÆæÁΩÆ</h3>
                    <div class="slider-container">
                        <label for="fontSize">Â≠ó‰ΩìÂ§ßÂ∞è: <span id="fontSizeValue">16</span>px</label>
                        <input type="range" id="fontSize" min="10" max="72" value="16">
                    </div>
                    <div style="margin-top: 15px;">
                        <label for="fontFamily">Â≠ó‰ΩìÁ±ªÂûã:</label>
                        <select id="fontFamily">
                            <option value="Arial">Arial</option>
                            <option value="Helvetica">Helvetica</option>
                            <option value="Times New Roman">Times New Roman</option>
                            <option value="Georgia">Georgia</option>
                            <option value="Courier New">Courier New</option>
                            <option value="Verdana">Verdana</option>
                            <option value="Impact">Impact</option>
                            <option value="Comic Sans MS">Comic Sans MS</option>
                        </select>
                    </div>
                </div>
                
                <div class="tool-section shortcuts">
                    <h4>Âø´Êç∑ÈîÆ</h4>
                    <div class="shortcut-item">
                        <span>ÁßªÂä®ÁîªÂ∏É</span>
                        <span>Á©∫Ê†ºÈîÆ + ÊãñÊãΩ Êàñ ÈÄâÊã©ÁßªÂä®Â∑•ÂÖ∑</span>
                    </div>
                    <div class="shortcut-item">
                        <span>ÊîæÂ§ß</span>
                        <span>Ctrl + + Êàñ Èº†Ê†áÊªöËΩÆÂêë‰∏ä</span>
                    </div>
                    <div class="shortcut-item">
                        <span>Áº©Â∞è</span>
                        <span>Ctrl + - Êàñ Èº†Ê†áÊªöËΩÆÂêë‰∏ã</span>
                    </div>
                    <div class="shortcut-item">
                        <span>ÈáçÁΩÆÁº©Êîæ</span>
                        <span>Ctrl + 0</span>
                    </div>
                    <div class="shortcut-item">
                        <span>‰øùÂ≠ò</span>
                        <span>Ctrl + S</span>
                    </div>
                    <div class="shortcut-item">
                        <span>Ê∏ÖÁ©∫</span>
                        <span>Ctrl + D</span>
                    </div>
                </div>
            </div>
            <div class="tool-section" id="historySection">
                <h3>Êìç‰ΩúÂéÜÂè≤</h3>
                <div style="display:flex;gap:8px;align-items:center;margin-bottom:6px;">
                    <button id="clearHistoryBtn" class="tool-btn" title="Ê∏ÖÁ©∫ÂéÜÂè≤" style="width:auto;padding:6px 8px;">Ê∏ÖÁ©∫ÂéÜÂè≤</button>
                    <div style="font-size:0.85rem;color:#666;">ÁÇπÂáªÂéÜÂè≤È°πÂèØ‰ª•ÂõûÂà∞ËØ•Ê≠•</div>
                </div>
                <div id="historyList" style="max-height:200px;overflow:auto;border:1px solid #eee;padding:6px;background:#fff;"></div>
            </div>
            
            <div class="canvas-container">
                <canvas id="drawingCanvas"></canvas>
                <div class="text-input-container" id="textInputContainer">
                    <textarea class="text-input" id="textInput" placeholder="ËæìÂÖ•ÊñáÊú¨..."></textarea>
                </div>
                <div class="zoom-controls">
                    <button class="zoom-btn" id="zoomOut">-</button>
                    <div class="zoom-level"><span id="zoomLevel">100%</span></div>
                    <button class="zoom-btn" id="zoomIn">+</button>
                </div>
                <div class="pan-controls">
                    <button class="pan-btn" id="panUp">‚Üë</button>
                    <div style="display: flex; gap: 5px;">
                        <button class="pan-btn" id="panLeft">‚Üê</button>
                        <button class="pan-btn" id="panReset">‚Ü∫</button>
                        <button class="pan-btn" id="panRight">‚Üí</button>
                    </div>
                    <button class="pan-btn" id="panDown">‚Üì</button>
                </div>
            </div>
        </div>
        
        <div class="actions">
            <button class="action-btn" id="saveBtn">‰øùÂ≠òÂõæÁâá</button>
            <button class="action-btn" id="saveViewportBtn">‰øùÂ≠òËßÜÂè£</button>
            <button class="action-btn" id="undoBtn">Êí§ÈîÄ</button>
            <button class="action-btn" id="redoBtn">ÈáçÂÅö</button>
                    <button class="action-btn" id="deleteNodeBtn">Âà†Èô§ËäÇÁÇπ</button>
                    <button class="action-btn" id="autoLayoutBtn">Ëá™Âä®Â∏ÉÂ±Ä</button>
            <button class="action-btn clear" id="clearBtn">Ê∏ÖÁ©∫ÁîªÂ∏É</button>
        </div>
    </div>
    
    <footer>
        <p>ÁªòÂõæÂ∑•ÂÖ∑ &copy; 2025</p>
    </footer>

    <script>
        document.addEventListener('DOMContentLoaded', function() {
            const canvas = document.getElementById('drawingCanvas');
            const ctx = canvas.getContext('2d');
            const brushSize = document.getElementById('brushSize');
            const brushSizeValue = document.getElementById('brushSizeValue');
            const fontSize = document.getElementById('fontSize');
            const fontSizeValue = document.getElementById('fontSizeValue');
            const fontFamily = document.getElementById('fontFamily');
            const colorOptions = document.querySelectorAll('.color-option');
            const toolButtons = document.querySelectorAll('.tool-btn');
            const saveBtn = document.getElementById('saveBtn');
            const clearBtn = document.getElementById('clearBtn');
            const textInputContainer = document.getElementById('textInputContainer');
            const textInput = document.getElementById('textInput');
            const zoomInBtn = document.getElementById('zoomIn');
            const zoomOutBtn = document.getElementById('zoomOut');
            const zoomLevel = document.getElementById('zoomLevel');
            const panUpBtn = document.getElementById('panUp');
            const panDownBtn = document.getElementById('panDown');
            const panLeftBtn = document.getElementById('panLeft');
            const panRightBtn = document.getElementById('panRight');
            const panResetBtn = document.getElementById('panReset');

            // ÈÄªËæëÔºàË∂ÖÂ§ßÔºâÁîªÂ∏ÉÂ∞∫ÂØ∏ÔºàËÆæÁΩÆ‰∏∫ÂæàÂ§ß‰ª•Ê®°Êãü‚ÄúÊó†Èôê‚ÄùÔºâ
            const LOGICAL_WIDTH = 16000; // ÂèØÊ†πÊçÆÈúÄË¶ÅÊîæÂ§ß
            const LOGICAL_HEIGHT = 9000;

            // Áü¢ÈáèÂ≠òÂÇ®ÔºöÊØè‰∏™ stroke Ë°®Á§∫‰∏ÄÁ¨îÊàñ‰∏Ä‰∏™ÂØπË±°
            // stroke = { tool: 'pencil'|'eraser'|'line'|'rectangle'|'circle'|'text', color, lineWidth, points: [{x,y}], start:{x,y}, end:{x,y}, text, fontSize, fontFamily }
            const strokes = [];
            let currentStroke = null;

            // ÊÄùÁª¥ÂØºÂõæÊï∞ÊçÆ
            // node = { id, x, y, w, h, text }
            // edge = { from, to }
            const mindNodes = [];
            const mindEdges = [];
            let mindNextId = 1;
            let draggingNode = null;
            let dragStartPos = null; // {x,y}
            let dragOffset = { x: 0, y: 0 };
            let creatingEdgeFrom = null;

            // Ê∞¥Âç∞ UI ÂÖÉÁ¥†
            const watermarkToggle = document.getElementById('watermarkToggle');
            const watermarkTextInput = document.getElementById('watermarkText');

            // ÂõæÂ±ÇÁ≥ªÁªü
            // layer = { id, name, visible: true, locked: false }
            const layers = [];
            let currentLayerId = null;

            function createLayer(name) {
                const id = 'layer_' + Date.now() + '_' + Math.floor(Math.random() * 1000);
                const layer = { id, name: name || 'ÂõæÂ±Ç ' + (layers.length + 1), visible: true, locked: false };
                layers.push(layer);
                if (!currentLayerId) currentLayerId = id;
                renderLayersPanel();
                return layer;
            }

            function removeLayer(id) {
                const idx = layers.findIndex(l => l.id === id);
                if (idx === -1) return false;
                layers.splice(idx, 1);
                if (currentLayerId === id) currentLayerId = layers.length ? layers[0].id : null;
                renderLayersPanel();
                return true;
            }

            function toggleLayerVisibility(id) {
                const l = layers.find(x => x.id === id); if (!l) return; l.visible = !l.visible; renderLayersPanel(); invalidateStaticCache(); redrawCanvas();
            }

            function toggleLayerLock(id) { const l = layers.find(x => x.id === id); if (!l) return; l.locked = !l.locked; renderLayersPanel(); }

            function selectLayer(id) { if (!layers.find(l => l.id === id)) return; currentLayerId = id; renderLayersPanel(); }

            const layersListEl = document.getElementById('layersList');
            const addLayerBtn = document.getElementById('addLayerBtn');
            const removeLayerBtn = document.getElementById('removeLayerBtn');

            function renderLayersPanel() {
                layersListEl.innerHTML = '';
                for (let i = 0; i < layers.length; i++) {
                    const l = layers[i];
                    const row = document.createElement('div');
                    row.style.display = 'flex'; row.style.alignItems = 'center'; row.style.gap = '8px'; row.style.padding = '6px'; row.style.borderBottom = '1px solid #f1f1f1';
                    // color swatch
                    const sw = document.createElement('div'); sw.style.width='18px'; sw.style.height='18px'; sw.style.borderRadius='4px'; sw.style.background = l.color || '#ffffff'; sw.title='ÂõæÂ±ÇÈ¢úËâ≤'; sw.style.border='1px solid #ddd';
                    sw.style.cursor = 'pointer';
                    sw.addEventListener('click', function(){
                        // ‰ΩøÁî®ÂéüÁîü color input Êèê‰æõÊõ¥Â•Ω‰ΩìÈ™åÔºà‰ªÖÊîØÊåÅ hexÔºâ
                        const colorInput = document.createElement('input'); colorInput.type = 'color';
                        // Ëã•Â∑≤Êúâ hex ÂÄºÂàô‰ΩøÁî®ÔºåÂê¶ÂàôÈªòËÆ§ÁôΩËâ≤
                        try { colorInput.value = (l.color && l.color.startsWith && l.color.startsWith('#')) ? l.color : '#ffffff'; } catch(e) { colorInput.value = '#ffffff'; }
                        colorInput.style.display = 'none'; document.body.appendChild(colorInput);
                        colorInput.addEventListener('input', function() {
                            l.color = colorInput.value; renderLayersPanel(); invalidateStaticCache(); redrawCanvas();
                            // cleanup
                            if (colorInput.parentNode) colorInput.parentNode.removeChild(colorInput);
                        });
                        colorInput.click();
                    });
                    row.appendChild(sw);
                    // visibility checkbox
                    const vis = document.createElement('input'); vis.type='checkbox'; vis.checked = !!l.visible; vis.addEventListener('change', function(){ toggleLayerVisibility(l.id); }); row.appendChild(vis);
                    // lock checkbox
                    const lock = document.createElement('input'); lock.type='checkbox'; lock.title='ÈîÅÂÆö'; lock.checked = !!l.locked; lock.addEventListener('change', function(){ toggleLayerLock(l.id); }); row.appendChild(lock);
                    const label = document.createElement('div'); label.textContent = l.name; label.style.flex='1'; label.style.cursor='pointer'; if (l.id === currentLayerId) label.style.fontWeight='700'; label.addEventListener('click', function(){ selectLayer(l.id); }); row.appendChild(label);
                    // rename button
                    const renameBtn = document.createElement('button'); renameBtn.className='tool-btn'; renameBtn.style.width='auto'; renameBtn.style.padding='4px 6px'; renameBtn.textContent='ÈáçÂëΩÂêç'; renameBtn.addEventListener('click', function(){ const nm = prompt('ÂõæÂ±ÇÊñ∞ÂêçÁß∞Ôºö', l.name); if (nm !== null) { l.name = nm; renderLayersPanel(); pushHistory('ÈáçÂëΩÂêçÂõæÂ±Ç'); } }); row.appendChild(renameBtn);
                    // move up/down
                    const upBtn = document.createElement('button'); upBtn.className='tool-btn'; upBtn.style.width='auto'; upBtn.style.padding='4px 6px'; upBtn.textContent='‚Üë'; upBtn.addEventListener('click', function(){ if (i === 0) return; layers.splice(i,1); layers.splice(i-1,0,l); renderLayersPanel(); invalidateStaticCache(); redrawCanvas(); pushHistory('‰∏äÁßªÂõæÂ±Ç'); }); row.appendChild(upBtn);
                    const downBtn = document.createElement('button'); downBtn.className='tool-btn'; downBtn.style.width='auto'; downBtn.style.padding='4px 6px'; downBtn.textContent='‚Üì'; downBtn.addEventListener('click', function(){ if (i === layers.length -1) return; layers.splice(i,1); layers.splice(i+1,0,l); renderLayersPanel(); invalidateStaticCache(); redrawCanvas(); pushHistory('‰∏ãÁßªÂõæÂ±Ç'); }); row.appendChild(downBtn);
                    layersListEl.appendChild(row);
                }
            }

            // ÂàùÂßãÂåñÈªòËÆ§ÂõæÂ±Ç
            createLayer('ÈªòËÆ§ÂõæÂ±Ç');
            renderLayersPanel();

            // ÂõæÂ±ÇÊåâÈíÆÈÄªËæë
            addLayerBtn.addEventListener('click', function(){ const name = prompt('ÂõæÂ±ÇÂêçÁß∞ÔºàÂèØÈÄâÔºâÔºö','Êñ∞ÂõæÂ±Ç'); const l = createLayer(name || undefined); pushHistory('Ê∑ªÂä†ÂõæÂ±Ç'); invalidateStaticCache(); });
            removeLayerBtn.addEventListener('click', function(){ if (!currentLayerId) return alert('Ê≤°ÊúâÂèØÂà†Èô§ÁöÑÂõæÂ±Ç');
                if (!confirm('Âà†Èô§ÂΩìÂâçÂõæÂ±ÇÔºü‰Ω†ÂèØ‰ª•ÈÄâÊã©Â∞ÜËØ•ÂõæÂ±ÇÂÜÖÂÆπËøÅÁßªÂà∞Âè¶‰∏Ä‰∏™ÂõæÂ±ÇÔºåÊàñÁõ¥Êé•Âà†Èô§„ÄÇÊòØÂê¶ÁªßÁª≠Ôºü')) return;
                // ËÆ∞ÂΩïÂà†Èô§ÂâçÂÆåÊï¥Âø´ÁÖßÔºå‰ª•ÊîØÊåÅÊí§ÈîÄ
                const prevSnapshot = { strokes: deepClone(strokes), mindNodes: deepClone(mindNodes), layers: deepClone(layers), currentLayerId };
                // ÈÄâÊã©ËøÅÁßªÁõÆÊ†á
                const other = layers.filter(x => x.id !== currentLayerId);
                let migrateTo = null;
                if (other.length > 0) {
                    const opts = other.map((o,idx) => `${idx+1}. ${o.name}`).join('\n');
                    const sel = prompt('ËæìÂÖ•Ë¶ÅËøÅÁßªÂà∞ÁöÑÂõæÂ±ÇÂ∫èÂè∑ÔºåÁïôÁ©∫ÂàôÂà†Èô§ÂÖÉÁ¥†Ôºö\n' + opts, '');
                    if (sel !== null && sel.trim() !== '') {
                        const idx = parseInt(sel, 10) - 1;
                        if (idx >= 0 && idx < other.length) migrateTo = other[idx].id;
                    }
                }
                // ÊâßË°åËøÅÁßªÊàñÂà†Èô§
                if (migrateTo) {
                    for (let i = 0; i < strokes.length; i++) if (strokes[i].layerId === currentLayerId) strokes[i].layerId = migrateTo;
                    for (let i = 0; i < mindNodes.length; i++) if (mindNodes[i].layerId === currentLayerId) mindNodes[i].layerId = migrateTo;
                } else {
                    for (let i = strokes.length - 1; i >= 0; i--) if (strokes[i].layerId === currentLayerId) strokes.splice(i,1);
                    for (let i = mindNodes.length - 1; i >= 0; i--) if (mindNodes[i].layerId === currentLayerId) mindNodes.splice(i,1);
                }
                // ÊâßË°åÂõæÂ±ÇÂà†Èô§
                const removedLayerId = currentLayerId;
                removeLayer(removedLayerId);
                const nextSnapshot = { strokes: deepClone(strokes), mindNodes: deepClone(mindNodes), layers: deepClone(layers), currentLayerId };
                // Â∞ÜÊìç‰ΩúÂéãÂÖ• undo Ê†àÔºåÊîØÊåÅÊí§ÈîÄÊÅ¢Â§ç‰∏∫ prevSnapshot
                undoStack.push({ type: 'layer-delete', prev: prevSnapshot, next: nextSnapshot });
                redoStack.length = 0; updateUndoRedoButtons();
                pushHistory('Âà†Èô§/ËøÅÁßªÂõæÂ±Ç'); invalidateStaticCache(); redrawCanvas(); });


            // ËßÜÂè£‰∏é‰∫§‰∫íÁä∂ÊÄÅ
            let currentZoom = 1; // Áº©ÊîæÊØî‰æã
            let viewX = 0, viewY = 0; // ËßÜÂè£Â∑¶‰∏äËßíÂú®ÈÄªËæëÂùêÊ†áÁ≥ªÁöÑ‰ΩçÁΩÆ
            let isPanning = false;
            let lastPanX = 0, lastPanY = 0;
            // ÂàÜÂ±ÇÁºìÂ≠òÔºöÈùôÊÄÅËßÜÂè£Âø´ÁÖßÔºåÁî®‰∫éÂä†ÈÄü redraw
            const staticCache = document.createElement('canvas');
            const staticCacheCtx = staticCache.getContext('2d');
            let staticCacheValid = false;
            let staticCacheView = { viewX: 0, viewY: 0, zoom: 1, w: 0, h: 0 };

            function invalidateStaticCache() {
                staticCacheValid = false;
                scheduleRedraw();
            }

            // ÂáèÂ∞ëÈáçÂ§çÈáçÁªòÔºö‰ΩøÁî® requestAnimationFrame ÊâπÈáèË∞ÉÂ∫¶ redraw
            let scheduled = false;
            function scheduleRedraw() {
                if (scheduled) return;
                scheduled = true;
                requestAnimationFrame(() => { scheduled = false; redrawCanvas(); });
            }

            function setupCanvas() {
                const container = canvas.parentElement;
                const newWidth = Math.max(300, container.clientWidth);
                const newHeight = Math.max(200, container.clientHeight);
                canvas.width = newWidth;
                canvas.height = newHeight;

                // ÈôêÂà∂ËßÜÂè£
                viewX = Math.min(Math.max(0, viewX), LOGICAL_WIDTH - canvas.width / currentZoom);
                viewY = Math.min(Math.max(0, viewY), LOGICAL_HEIGHT - canvas.height / currentZoom);
                redrawCanvas();
            }

            function drawGrid() {
                const gridSize = 20;
                ctx.save();
                ctx.strokeStyle = '#f0f0f0';
                ctx.lineWidth = 1;

                const startX = Math.floor(viewX / gridSize) * gridSize;
                const startY = Math.floor(viewY / gridSize) * gridSize;
                const endX = viewX + canvas.width / currentZoom + gridSize;
                const endY = viewY + canvas.height / currentZoom + gridSize;

                ctx.beginPath();
                for (let x = startX; x < endX; x += gridSize) {
                    const sx = (x - viewX) * currentZoom;
                    ctx.moveTo(sx, (startY - viewY) * currentZoom);
                    ctx.lineTo(sx, (endY - viewY) * currentZoom);
                }
                for (let y = startY; y < endY; y += gridSize) {
                    const sy = (y - viewY) * currentZoom;
                    ctx.moveTo((startX - viewX) * currentZoom, sy);
                    ctx.lineTo((endX - viewX) * currentZoom, sy);
                }
                ctx.stroke();
                ctx.restore();
            }

            // Â∞Ü screen (canvas ÂÉèÁ¥†) ËΩ¨‰∏∫ÈÄªËæëÂùêÊ†á
            function screenToLogical(rawX, rawY) {
                return [viewX + rawX / currentZoom, viewY + rawY / currentZoom];
            }

            function getEventCoordinates(e) {
                let clientX, clientY;
                if (e.type && e.type.includes('touch')) {
                    clientX = e.touches[0].clientX;
                    clientY = e.touches[0].clientY;
                } else {
                    clientX = e.clientX;
                    clientY = e.clientY;
                }
                const rect = canvas.getBoundingClientRect();
                return [clientX - rect.left, clientY - rect.top];
            }

            // ÁªòÂà∂Âçï‰∏™ stroke Âà∞‰ªªÊÑè ctx„ÄÇËã•Êèê‰æõ view/zoom ÂèÇÊï∞ÂàôÊåâËßÜÂè£ËΩ¨Êç¢ÁªòÂà∂ÔºåÂê¶ÂàôÊåâÈÄªËæëÂùêÊ†áÁõ¥Êé•ÁªòÂà∂ÔºàÁî®‰∫éÂØºÂá∫Ôºâ
            function drawStrokeToCtx(targetCtx, stroke, opts = {}) {
                const isExport = !!opts.export;
                const vx = opts.viewX || 0;
                const vy = opts.viewY || 0;
                const zoom = opts.zoom || 1;

                targetCtx.save();
                targetCtx.lineJoin = 'round';
                targetCtx.lineCap = 'round';
                targetCtx.lineWidth = stroke.lineWidth || 1;
                if (stroke.tool === 'eraser') {
                    targetCtx.globalCompositeOperation = 'destination-out';
                    targetCtx.strokeStyle = 'rgba(0,0,0,1)';
                } else {
                    targetCtx.globalCompositeOperation = 'source-over';
                    targetCtx.strokeStyle = stroke.color || '#000';
                }

                if (stroke.tool === 'pencil' || stroke.tool === 'eraser') {
                    const pts = stroke.points || [];
                    if (pts.length === 1) {
                        const x = (pts[0].x - vx) * zoom;
                        const y = (pts[0].y - vy) * zoom;
                        targetCtx.beginPath();
                        targetCtx.arc(x, y, (stroke.lineWidth || 1) / 2 * zoom, 0, Math.PI * 2);
                        targetCtx.fillStyle = stroke.color || '#000';
                        if (stroke.tool === 'eraser') {
                            targetCtx.globalCompositeOperation = 'destination-out';
                            targetCtx.fill();
                        } else {
                            targetCtx.fill();
                        }
                    } else if (pts.length > 1) {
                        targetCtx.beginPath();
                        for (let i = 0; i < pts.length; i++) {
                            const p = pts[i];
                            const x = (p.x - vx) * zoom;
                            const y = (p.y - vy) * zoom;
                            if (i === 0) targetCtx.moveTo(x, y);
                            else targetCtx.lineTo(x, y);
                        }
                        targetCtx.stroke();
                    }
                } else if (stroke.tool === 'line') {
                    const sx = (stroke.start.x - vx) * zoom;
                    const sy = (stroke.start.y - vy) * zoom;
                    const ex = (stroke.end.x - vx) * zoom;
                    const ey = (stroke.end.y - vy) * zoom;
                    targetCtx.beginPath(); targetCtx.moveTo(sx, sy); targetCtx.lineTo(ex, ey); targetCtx.stroke();
                } else if (stroke.tool === 'rectangle') {
                    const sx = (stroke.start.x - vx) * zoom;
                    const sy = (stroke.start.y - vy) * zoom;
                    const w = (stroke.end.x - stroke.start.x) * zoom;
                    const h = (stroke.end.y - stroke.start.y) * zoom;
                    targetCtx.strokeRect(sx, sy, w, h);
                } else if (stroke.tool === 'circle') {
                    const cx = (stroke.start.x - vx) * zoom;
                    const cy = (stroke.start.y - vy) * zoom;
                    const r = Math.sqrt(Math.pow(stroke.end.x - stroke.start.x, 2) + Math.pow(stroke.end.y - stroke.start.y, 2)) * zoom;
                    targetCtx.beginPath(); targetCtx.arc(cx, cy, r, 0, Math.PI * 2); targetCtx.stroke();
                } else if (stroke.tool === 'text') {
                    const tx = (stroke.x - vx) * zoom;
                    const ty = (stroke.y - vy) * zoom;
                    const fSize = (stroke.fontSize || 16) * (isExport ? 1 : zoom);
                    targetCtx.fillStyle = stroke.color || '#000';
                    targetCtx.font = `${fSize}px ${stroke.fontFamily || 'Arial'}`;
                    targetCtx.textBaseline = 'top';
                    targetCtx.fillText(stroke.text || '', tx, ty);
                }

                targetCtx.restore();
            }

            function redrawCanvas() {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                ctx.fillStyle = 'white';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                drawGrid();

                // ÁªòÂà∂Â∑≤ÊúâÁöÑÁü¢ÈáèÁ¨îÁîªÔºà‰ΩøÁî®ÈùôÊÄÅÁºìÂ≠ò‰ª•ÊèêÂçáÊÄßËÉΩÔºâ
                // ÂΩìËßÜÂè£ÊàñÁîªÂ∏ÉÂ∞∫ÂØ∏ÂèòÂåñÊàñÊï∞ÊçÆÂèòÊõ¥Êó∂ÈúÄË¶ÅÈáçÂª∫ÁºìÂ≠ò
                if (!staticCacheValid || staticCacheView.viewX !== viewX || staticCacheView.viewY !== viewY || staticCacheView.zoom !== currentZoom || staticCacheView.w !== canvas.width || staticCacheView.h !== canvas.height) {
                    // ÈáçÂª∫ÈùôÊÄÅÁºìÂ≠òÔºöÂ§ßÂ∞è‰∏é‰∏ª canvas Áõ∏ÂêåÔºàË°®Á§∫ÂΩìÂâçËßÜÂè£Ôºâ
                    staticCache.width = canvas.width;
                    staticCache.height = canvas.height;
                    staticCacheCtx.clearRect(0, 0, staticCache.width, staticCache.height);
                    staticCacheCtx.fillStyle = 'white';
                    staticCacheCtx.fillRect(0, 0, staticCache.width, staticCache.height);
                    // ÊåâÂõæÂ±ÇÈ°∫Â∫èÁªòÂà∂Á¨îÁîªÂà∞ÈùôÊÄÅÁºìÂ≠òÔºà‰ªÖÁªòÂà∂ÂèØËßÅÂõæÂ±Ç‰∏î‰ªÖÁªòÂà∂ÂèØËßÅÁöÑÈÉ®ÂàÜÔºâ
                    for (let li = 0; li < layers.length; li++) {
                        const layer = layers[li];
                        if (!layer.visible) continue;
                        for (let i = 0; i < strokes.length; i++) {
                            const s = strokes[i];
                            if (s.layerId !== layer.id) continue;
                            if (!isStrokeVisible(s, viewX, viewY, canvas.width / currentZoom, canvas.height / currentZoom)) continue;
                            drawStrokeToCtx(staticCacheCtx, s, { viewX, viewY, zoom: currentZoom });
                        }
                    }
                    staticCacheValid = true;
                    staticCacheView = { viewX, viewY, zoom: currentZoom, w: canvas.width, h: canvas.height };
                }
                // Â∞ÜÈùôÊÄÅÁºìÂ≠òÁªòÂà∂Âà∞‰∏ª ctx
                ctx.drawImage(staticCache, 0, 0);

                // ÁªòÂà∂ÊÄùÁª¥ÂØºÂõæËæπÂíåËäÇÁÇπÔºåÊåâÂõæÂ±ÇÈ°∫Â∫èÁªòÂà∂‰ª•‰øùËØÅÊ≠£Á°ÆÈÅÆÊå°
                for (let li = 0; li < layers.length; li++) {
                    const layer = layers[li];
                    if (!layer.visible) continue;
                    // edges Â±ÇÁ∫ßËøáÊª§Ôºö‰ªÖÁªòÂà∂Â±û‰∫éÂΩìÂâçÂõæÂ±Ç‰∏≠ËäÇÁÇπÁöÑËæπÔºàËã•ËæπÁöÑ‰∏§Á´ØËäÇÁÇπÈÉΩÂú®ÂèØËßÅÂõæÂ±ÇÔºâ
                    ctx.save();
                    ctx.strokeStyle = '#444';
                    ctx.lineWidth = 2 * currentZoom;
                    for (let e of mindEdges) {
                        const from = mindNodes.find(n => n.id === e.from);
                        const to = mindNodes.find(n => n.id === e.to);
                        if (!from || !to) continue;
                        // Ëã•ËæπÊâÄÂ±ûÂõæÂ±Ç‰∏çÂú®ÂΩìÂâç layerÔºà‰ª• from.node ÁöÑ layer ‰∏∫ÂáÜÔºâÂàôË∑≥Ëøá
                        if (from.layerId !== layer.id && to.layerId !== layer.id) continue;
                        const fx = (from.x - viewX) * currentZoom;
                        const fy = (from.y - viewY) * currentZoom;
                        const tx = (to.x - viewX) * currentZoom;
                        const ty = (to.y - viewY) * currentZoom;
                        ctx.beginPath(); ctx.moveTo(fx, fy); ctx.lineTo(tx, ty); ctx.stroke();
                    }
                    ctx.restore();

                    // nodes
                    for (let n of mindNodes) {
                        if (n.layerId !== layer.id) continue;
                        const nx = (n.x - viewX) * currentZoom;
                        const ny = (n.y - viewY) * currentZoom;
                        const w = (n.w || 120) * currentZoom;
                        const h = (n.h || 40) * currentZoom;
                        ctx.save();
                        ctx.fillStyle = '#fff8dc';
                        ctx.strokeStyle = '#333';
                        ctx.lineWidth = 1;
                        roundRect(ctx, nx - w/2, ny - h/2, w, h, 8 * currentZoom, true, true);
                        ctx.restore();
                        ctx.save();
                        ctx.fillStyle = '#111';
                        ctx.font = `${14 * currentZoom}px Arial`;
                        ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
                        ctx.fillText(n.text || ('ËäÇÁÇπ ' + n.id), nx, ny);
                        ctx.restore();
                    }
                }

                // ÁªòÂà∂ÂΩìÂâçÊ≠£Âú®ÁªòÂà∂ÁöÑ stroke ‰Ωú‰∏∫È¢ÑËßà
                if (currentStroke) {
                    // Â¶ÇÊûúÊòØÂõæÂΩ¢ÂûãÔºå‰ΩøÁî®ËôöÁ∫øÈ¢ÑËßà
                    ctx.save();
                    if (currentStroke.tool === 'line' || currentStroke.tool === 'rectangle' || currentStroke.tool === 'circle') {
                        ctx.setLineDash([6, 4]);
                    }
                    drawStrokeToCtx(ctx, currentStroke, { viewX, viewY, zoom: currentZoom });
                    ctx.restore();
                }

                // Â¶ÇÊûúÊ≠£Âú®ÂàõÂª∫ËøûÁ∫øÔºåÊòæÁ§∫È¢ÑËßàÁ∫ø
                if (creatingEdgeFrom) {
                    const fromNode = mindNodes.find(n => n.id === creatingEdgeFrom.id);
                    if (fromNode) {
                        const fx = (fromNode.x - viewX) * currentZoom;
                        const fy = (fromNode.y - viewY) * currentZoom;
                        ctx.save(); ctx.strokeStyle = '#666'; ctx.setLineDash([4,4]); ctx.beginPath(); ctx.moveTo(fx, fy);
                        const m = lastPointerPos || { x: fx, y: fy };
                        ctx.lineTo(m.x, m.y); ctx.stroke(); ctx.restore();
                    }
                }
            }

            // helper: draw rounded rect
            function roundRect(ctx, x, y, width, height, radius, fill, stroke) {
                if (typeof stroke === 'undefined') { stroke = true; }
                if (typeof radius === 'undefined') { radius = 5; }
                ctx.beginPath();
                ctx.moveTo(x + radius, y);
                ctx.arcTo(x + width, y, x + width, y + height, radius);
                ctx.arcTo(x + width, y + height, x, y + height, radius);
                ctx.arcTo(x, y + height, x, y, radius);
                ctx.arcTo(x, y, x + width, y, radius);
                ctx.closePath();
                if (fill) ctx.fill();
                if (stroke) ctx.stroke();
            }

            // ÂàùÂßãÂåñ
            setupCanvas();
            window.addEventListener('resize', setupCanvas);

            // ÁªòÂà∂Áä∂ÊÄÅ
            let isDrawing = false;
            let lastX = 0, lastY = 0;
            let startX = 0, startY = 0;
            let currentTool = 'pencil';
            let currentColor = '#000000';
            let lastPointerPos = null;

            // UI Êéß‰ª∂ÂêåÊ≠•
            brushSizeValue.textContent = brushSize.value;
            fontSizeValue.textContent = fontSize.value;
            brushSize.addEventListener('input', () => brushSizeValue.textContent = brushSize.value);
            fontSize.addEventListener('input', () => fontSizeValue.textContent = fontSize.value);

            colorOptions.forEach(option => {
                option.addEventListener('click', function() {
                    colorOptions.forEach(opt => opt.classList.remove('active'));
                    this.classList.add('active');
                    currentColor = this.getAttribute('data-color');
                });
            });

            toolButtons.forEach(button => {
                button.addEventListener('click', function() {
                    toolButtons.forEach(btn => btn.classList.remove('active'));
                    this.classList.add('active');
                    currentTool = this.id;
                    if (currentTool !== 'text') hideTextInput();
                    if (currentTool === 'text') canvas.style.cursor = 'text';
                    else if (currentTool === 'pan') canvas.style.cursor = 'grab';
                    else canvas.style.cursor = 'crosshair';
                });
            });

            function startDrawing(e) {
                if (currentTool === 'text') { showTextInput(e); return; }
                if (currentTool === 'pan') { isPanning = true; [lastPanX, lastPanY] = getEventCoordinates(e); canvas.style.cursor = 'grabbing'; return; }
                if (currentTool === 'mindmap') {
                    const [rawX, rawY] = getEventCoordinates(e);
                    const [x, y] = screenToLogical(rawX, rawY);
                    // Ê£ÄÊü•ÊòØÂê¶ÁÇπÂáªÂú®ËäÇÁÇπ‰∏ä
                    const node = findNodeAtLogical(x, y);
                    if (node) {
                        // Â¶ÇÊûúËäÇÁÇπÊâÄÂú®ÂõæÂ±ÇË¢´ÈîÅÂÆöÔºåÈòªÊ≠¢ÊãñÂä®/ÁºñËæë
                        const nodeLayer = layers.find(l => l.id === node.layerId);
                        if (nodeLayer && nodeLayer.locked) {
                            alert('ËØ•ÂõæÂ±ÇÂ∑≤ÈîÅÂÆöÔºåÊó†Ê≥ïÁßªÂä®/ÁºñËæëËäÇÁÇπ');
                            return;
                        }
                        // ÂºÄÂßãÊãñÂä®ËäÇÁÇπ
                        draggingNode = node;
                        dragStartPos = { x, y };
                        dragOffset = { x: x - node.x, y: y - node.y };
                        return;
                    } else {
                        // ÂàõÂª∫Êñ∞ËäÇÁÇπÔºàÊ£ÄÊü•ÂΩìÂâçÂõæÂ±ÇÈîÅÂÆöÔºâ
                        const curLayer = layers.find(l => l.id === currentLayerId);
                        if (curLayer && curLayer.locked) { alert('ÂΩìÂâçÂõæÂ±ÇÂ∑≤ÈîÅÂÆöÔºåÊó†Ê≥ïÊ∑ªÂä†ËäÇÁÇπ'); return; }
                        const newNode = createMindNode(x, y);
                        undoStack.push({ type: 'mind-add-node', node: deepClone(newNode) });
                        redoStack.length = 0;
                        updateUndoRedoButtons();
                        pushHistory('ÊÄùÁª¥ÂØºÂõæÔºöÊ∑ªÂä†ËäÇÁÇπ');
                        redrawCanvas();
                        return;
                    }
                }

                const [rawX, rawY] = getEventCoordinates(e);
                const [x, y] = screenToLogical(rawX, rawY);
                isDrawing = true; startX = x; startY = y; lastX = x; lastY = y;

                if (currentTool === 'pencil' || currentTool === 'eraser') {
                    const layer = layers.find(l => l.id === currentLayerId);
                    if (layer && layer.locked) { isDrawing = false; return; }
                    currentStroke = {
                        tool: currentTool,
                        color: currentColor,
                        lineWidth: parseFloat(brushSize.value),
                        points: [{ x, y }],
                        layerId: currentLayerId
                    };
                } else if (currentTool === 'line' || currentTool === 'rectangle' || currentTool === 'circle') {
                    const layer = layers.find(l => l.id === currentLayerId);
                    if (layer && layer.locked) { isDrawing = false; return; }
                    currentStroke = {
                        tool: currentTool,
                        color: currentColor,
                        lineWidth: parseFloat(brushSize.value),
                        start: { x, y },
                        end: { x, y },
                        layerId: currentLayerId
                    };
                }
                redrawCanvas();
            }

            function drawing(e) {
                // update lastPointerPos for mindmap preview
                const [prx, pry] = getEventCoordinates(e);
                lastPointerPos = { x: prx, y: pry };

                if (isPanning) {
                    const [sx, sy] = getEventCoordinates(e);
                    viewX -= (sx - lastPanX) / currentZoom;
                    viewY -= (sy - lastPanY) / currentZoom;
                    lastPanX = sx; lastPanY = sy;
                    viewX = Math.max(0, Math.min(viewX, LOGICAL_WIDTH - canvas.width / currentZoom));
                    viewY = Math.max(0, Math.min(viewY, LOGICAL_HEIGHT - canvas.height / currentZoom));
                    redrawCanvas();
                    return;
                }
                if (currentTool === 'mindmap' && draggingNode) {
                    const [rawX, rawY] = getEventCoordinates(e);
                    const [x, y] = screenToLogical(rawX, rawY);
                    // ÁßªÂä®ËäÇÁÇπ‰ΩçÁΩÆ
                    const prev = { x: draggingNode.x, y: draggingNode.y };
                    draggingNode.x = x - dragOffset.x;
                    draggingNode.y = y - dragOffset.y;
                    // ËÆ∞ÂΩïÁßªÂä®Êìç‰ΩúÔºàÂÆûÊó∂‰∏çËÆ∞ÂΩïÂà∞ undoÔºåÂÅú‰∏ãÊó∂ËÆ∞ÂΩï‰∏ÄÊ¨°Ôºâ
                    redrawCanvas();
                    return;
                }
                if (!isDrawing || currentTool === 'text') return;

                const [rawX, rawY] = getEventCoordinates(e);
                const [x, y] = screenToLogical(rawX, rawY);

                if (currentTool === 'pencil' || currentTool === 'eraser') {
                    if (currentStroke && currentStroke.points) {
                        currentStroke.points.push({ x, y });
                    }
                } else if (currentTool === 'line' || currentTool === 'rectangle' || currentTool === 'circle') {
                    if (currentStroke) currentStroke.end = { x, y };
                }
                lastX = x; lastY = y;
                redrawCanvas();
            }

            function stopDrawing(e) {
                if (isPanning) { isPanning = false; canvas.style.cursor = 'grab'; return; }
                // mindmap ÁâπÊÆäÂ§ÑÁêÜÔºöÂÅúÊ≠¢ÊãñÂä®ËäÇÁÇπÊàñÂÆåÊàêËøûÁ∫ø
                if (currentTool === 'mindmap') {
                    if (draggingNode) {
                        // ËÆ∞ÂΩïËäÇÁÇπÁßªÂä®Âà∞ undoÔºàËÆ∞ÂΩï from/toÔºâ
                        const node = deepClone(draggingNode);
                        // for simplicity, we push a move op with previous pos stored in op.prev
                        // (we need previous pos - assume dragStartPos stores start)
                        undoStack.push({ type: 'mind-move-node', id: node.id, from: dragStartPos, to: { x: node.x, y: node.y } });
                        redoStack.length = 0;
                        updateUndoRedoButtons();
                        pushHistory('ÊÄùÁª¥ÂØºÂõæÔºöÁßªÂä®ËäÇÁÇπ');
                        draggingNode = null; dragStartPos = null;
                        redrawCanvas();
                        return;
                    }
                    // Â¶ÇÊûúÊ≠£Âú®ÂàõÂª∫ËøûÁ∫øÔºåÂ∞ùËØïÁªìÊùüËøûÁ∫ø
                    if (creatingEdgeFrom) {
                        const [rawX, rawY] = getEventCoordinates(e);
                        const [x, y] = screenToLogical(rawX, rawY);
                        const targetNode = findNodeAtLogical(x, y);
                        if (targetNode && targetNode.id !== creatingEdgeFrom.id) {
                            // ÂàõÂª∫Ëæπ
                            mindEdges.push({ from: creatingEdgeFrom.id, to: targetNode.id });
                            undoStack.push({ type: 'mind-add-edge', edge: deepClone({ from: creatingEdgeFrom.id, to: targetNode.id }) });
                            redoStack.length = 0;
                            updateUndoRedoButtons();
                            pushHistory('ÊÄùÁª¥ÂØºÂõæÔºöÊ∑ªÂä†ËøûÁ∫ø');
                            invalidateStaticCache();
                        }
                        creatingEdgeFrom = null; redrawCanvas(); return;
                    }
                    return;
                }

                if (!isDrawing || currentTool === 'text') return;
                isDrawing = false;

                const [rawX, rawY] = getEventCoordinates(e);
                const [x, y] = screenToLogical(rawX, rawY);

                if (currentStroke) {
                    // ÂØπ‰∫éÁ∫øÂíåÂõæÂΩ¢ÔºåÊõ¥Êñ∞Êú´Á´ØÂùêÊ†á
                    if (currentStroke.start) currentStroke.end = { x, y };
                    // Êèê‰∫§‰∏∫‰∏Ä‰∏™Êñ∞ÁöÑÁ¨îÁîªÔºàÈÄöËøá pushStroke ‰ª•ËÆ∞ÂΩï undoÔºâ
                    pushStroke(currentStroke);
                    currentStroke = null;
                }
                redrawCanvas();
            }

            // ‰∫ã‰ª∂ÁªëÂÆö
            canvas.addEventListener('mousedown', function(e) { if (e.button !== 0) return; startDrawing(e); });
            canvas.addEventListener('mousemove', drawing);
            window.addEventListener('mouseup', stopDrawing);
            canvas.addEventListener('touchstart', function(e){ e.preventDefault(); startDrawing(e); }, { passive: false });
            canvas.addEventListener('touchmove', function(e){ e.preventDefault(); drawing(e); }, { passive: false });
            window.addEventListener('touchend', function(e){ e.preventDefault(); stopDrawing(e); }, { passive: false });

            // Áº©Êîæ/Âπ≥Áßª/Âø´Êç∑ÈîÆ
            function updateZoomDisplay() { zoomLevel.textContent = Math.round(currentZoom * 100) + '%'; }
            zoomInBtn.addEventListener('click', function() {
                const prevZoom = currentZoom; currentZoom = Math.min(currentZoom * 1.2, 5);
                const cx = canvas.width / 2, cy = canvas.height / 2;
                viewX += (cx / prevZoom) - (cx / currentZoom);
                viewY += (cy / prevZoom) - (cy / currentZoom);
                viewX = Math.max(0, Math.min(viewX, LOGICAL_WIDTH - canvas.width / currentZoom));
                viewY = Math.max(0, Math.min(viewY, LOGICAL_HEIGHT - canvas.height / currentZoom));
                updateZoomDisplay(); redrawCanvas();
            });
            zoomOutBtn.addEventListener('click', function() {
                const prevZoom = currentZoom; currentZoom = Math.max(currentZoom / 1.2, 0.2);
                const cx = canvas.width / 2, cy = canvas.height / 2;
                viewX += (cx / prevZoom) - (cx / currentZoom);
                viewY += (cy / prevZoom) - (cy / currentZoom);
                viewX = Math.max(0, Math.min(viewX, LOGICAL_WIDTH - canvas.width / currentZoom));
                viewY = Math.max(0, Math.min(viewY, LOGICAL_HEIGHT - canvas.height / currentZoom));
                updateZoomDisplay(); redrawCanvas();
            });

            panUpBtn.addEventListener('click', function(){ viewY = Math.max(0, viewY - 50 / currentZoom); redrawCanvas(); });
            panDownBtn.addEventListener('click', function(){ viewY = Math.min(LOGICAL_HEIGHT - canvas.height / currentZoom, viewY + 50 / currentZoom); redrawCanvas(); });
            panLeftBtn.addEventListener('click', function(){ viewX = Math.max(0, viewX - 50 / currentZoom); redrawCanvas(); });
            panRightBtn.addEventListener('click', function(){ viewX = Math.min(LOGICAL_WIDTH - canvas.width / currentZoom, viewX + 50 / currentZoom); redrawCanvas(); });
            panResetBtn.addEventListener('click', function(){ viewX = 0; viewY = 0; redrawCanvas(); });

            canvas.addEventListener('wheel', function(e){
                e.preventDefault();
                const rect = canvas.getBoundingClientRect();
                const mx = e.clientX - rect.left, my = e.clientY - rect.top;
                const prevZoom = currentZoom;
                const delta = e.deltaY > 0 ? 0.9 : 1.1;
                currentZoom = Math.max(0.2, Math.min(5, currentZoom * delta));
                const logicalX = viewX + mx / prevZoom;
                const logicalY = viewY + my / prevZoom;
                viewX = logicalX - mx / currentZoom;
                viewY = logicalY - my / currentZoom;
                viewX = Math.max(0, Math.min(viewX, LOGICAL_WIDTH - canvas.width / currentZoom));
                viewY = Math.max(0, Math.min(viewY, LOGICAL_HEIGHT - canvas.height / currentZoom));
                updateZoomDisplay(); redrawCanvas();
            });

            // ÊñáÊú¨ËæìÂÖ•Â§ÑÁêÜÔºöÂú®ÊòæÁ§∫Êó∂ËÆ∞ÂΩïÈÄªËæëÂùêÊ†áÔºåÊèê‰∫§Êó∂Â∞ÜÊñáÊú¨Â≠ò‰∏∫ stroke
            function showTextInput(e) {
                const [rawX, rawY] = getEventCoordinates(e);
                const [x, y] = screenToLogical(rawX, rawY);
                // Âú®Â±èÂπï‰∏äÂÆö‰ΩçËæìÂÖ•Ê°ÜÔºàÁõ∏ÂØπ‰∫é canvasÔºâ
                textInputContainer.style.left = rawX + 'px';
                textInputContainer.style.top = rawY + 'px';
                textInputContainer.style.width = '200px'; textInputContainer.style.height = '100px'; textInputContainer.style.display = 'block';
                textInput.style.fontSize = fontSize.value + 'px'; textInput.style.fontFamily = fontFamily.value; textInput.style.color = currentColor;
                // ‰øùÂ≠òÈÄªËæëÂùêÊ†áÂà∞ÂÆπÂô® datasetÔºå‰ª•‰æøÊèê‰∫§Êó∂‰ΩøÁî®
                textInputContainer.dataset.logicalX = x;
                textInputContainer.dataset.logicalY = y;
                textInput.focus();
            }

            function hideTextInput() {
                if (textInputContainer.style.display === 'block') {
                    if (textInput.value.trim() !== '') {
                        const x = parseFloat(textInputContainer.dataset.logicalX);
                        const y = parseFloat(textInputContainer.dataset.logicalY);
                        const stroke = {
                            tool: 'text', x, y,
                            text: textInput.value,
                            color: currentColor,
                            fontSize: parseInt(fontSize.value, 10),
                            fontFamily: fontFamily.value,
                            layerId: currentLayerId
                        };
                        pushStroke(stroke);
                        redrawCanvas();
                    }
                    textInputContainer.style.display = 'none'; textInput.value = '';
                }
            }

            document.addEventListener('click', function(e){ if (currentTool === 'text' && !textInputContainer.contains(e.target) && e.target !== canvas) hideTextInput(); });
            textInput.addEventListener('keydown', function(e){ if (e.key === 'Enter' && !e.shiftKey) { e.preventDefault(); hideTextInput(); } });

            // Âø´Êç∑ÈîÆÔºöÁ©∫Ê†º + ÊãñÂä® Âπ≥ÁßªÔºåCtrl ‰øùÂ≠ò/Ê∏ÖÁ©∫/Áº©ÊîæÁ≠â
            let isSpacePressed = false;
            document.addEventListener('keydown', function(e){
                if (e.code === 'Space') { isSpacePressed = true; if (currentTool !== 'pan') canvas.style.cursor = 'grab'; }
                if (e.ctrlKey || e.metaKey) {
                    switch(e.key) {
                        case 's': e.preventDefault(); saveImage(); break;
                        case 'd': e.preventDefault(); clearCanvas(); break;
                        case '0': e.preventDefault(); currentZoom = 1; viewX = 0; viewY = 0; updateZoomDisplay(); redrawCanvas(); break;
                        case '=': case '+': e.preventDefault(); currentZoom = Math.min(currentZoom * 1.2, 5); updateZoomDisplay(); redrawCanvas(); break;
                        case '-': e.preventDefault(); currentZoom = Math.max(currentZoom / 1.2, 0.2); updateZoomDisplay(); redrawCanvas(); break;
                    }
                }
            });
            document.addEventListener('keyup', function(e){ if (e.code === 'Space') { isSpacePressed = false; if (currentTool !== 'pan') canvas.style.cursor = 'crosshair'; } });

            canvas.addEventListener('mousedown', function(e){
                if (isSpacePressed) { isPanning = true; [lastPanX, lastPanY] = getEventCoordinates(e); canvas.style.cursor = 'grabbing'; e.preventDefault(); }
            });
            window.addEventListener('mouseup', function(e){ if (isPanning) { isPanning = false; canvas.style.cursor = isSpacePressed ? 'grab' : 'crosshair'; e.preventDefault(); } });

            // Undo/Redo Ê†àÔºàÊõ¥ÂÆåÊï¥ÁöÑÂÆûÁé∞Ôºâ
            const undoStack = [];
            const redoStack = [];

            // ÂéÜÂè≤Èù¢ÊùøÔºàÁÆÄË¶ÅÊèèËø∞ + Âø´ÁÖßÁ¥¢ÂºïÔºâ
            const historyListEl = document.getElementById('historyList');
            const history = []; // { desc, type, ts, snapshot }
            const MAX_HISTORY = 200;

            // ÁîüÊàêÂéÜÂè≤È°πÁº©Áï•ÂõæÁöÑËæÖÂä©ÔºàËøîÂõû dataURLÔºâ
            function renderHistoryThumbnail(snapshot, w = 160, h = 80) {
                try {
                    const tmp = document.createElement('canvas');
                    tmp.width = w; tmp.height = h;
                    const tctx = tmp.getContext('2d');
                    tctx.fillStyle = 'white'; tctx.fillRect(0,0,w,h);
                    // snapshot ‰∏≠ÂùêÊ†á‰∏∫ÈÄªËæëÂùêÊ†áÔºõÊàë‰ª¨ÈúÄË¶ÅÊääÂÆÉÁº©Êîæ‰ª•ÈÄÇÈÖçÁº©Áï•Âõæ
                    // ËÆ°ÁÆó bbox
                    let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
                    const nodes = snapshot.mindNodes || [];
                    const strokesS = snapshot.strokes || [];
                    for (let n of nodes) {
                        minX = Math.min(minX, n.x - (n.w||120)/2);
                        minY = Math.min(minY, n.y - (n.h||40)/2);
                        maxX = Math.max(maxX, n.x + (n.w||120)/2);
                        maxY = Math.max(maxY, n.y + (n.h||40)/2);
                    }
                    for (let s of strokesS) {
                        if (s.points && s.points.length) {
                            for (let p of s.points) { minX = Math.min(minX, p.x); minY = Math.min(minY, p.y); maxX = Math.max(maxX, p.x); maxY = Math.max(maxY, p.y); }
                        } else if (s.start && s.end) {
                            minX = Math.min(minX, s.start.x, s.end.x); minY = Math.min(minY, s.start.y, s.end.y);
                            maxX = Math.max(maxX, s.start.x, s.end.x); maxY = Math.max(maxY, s.start.y, s.end.y);
                        } else if (s.x && s.y) { minX = Math.min(minX, s.x); minY = Math.min(minY, s.y); maxX = Math.max(maxX, s.x); maxY = Math.max(maxY, s.y); }
                    }
                    if (!isFinite(minX)) { minX = 0; minY = 0; maxX = Math.max(200, w); maxY = Math.max(100, h); }
                    const pad = 20;
                    minX -= pad; minY -= pad; maxX += pad; maxY += pad;
                    const sw = maxX - minX; const sh = maxY - minY;
                    const scale = Math.min(w / sw, h / sh);
                    const vx = minX, vy = minY, zoom = scale;
                    const snapLayers = snapshot.layers || [];
                    function layerVisible(layerId) { if (!snapLayers || !snapLayers.length) return true; const l = snapLayers.find(x=>x.id===layerId); return l ? !!l.visible : true; }
                    if (snapLayers && snapLayers.length) {
                        for (let li = 0; li < snapLayers.length; li++) {
                            const layer = snapLayers[li]; if (!layerVisible(layer.id)) continue;
                            for (let s of strokesS) {
                                if ((s.layerId || null) !== layer.id) continue;
                                drawStrokeToCtx(tctx, s, { export: true, viewX: vx, viewY: vy, zoom });
                            }
                        }
                        drawMindmapToCtx(tctx, { export: true, viewX: vx, viewY: vy, zoom, canvasW: w, canvasH: h, snapLayers });
                    } else {
                        for (let s of strokesS) {
                            drawStrokeToCtx(tctx, s, { export: true, viewX: vx, viewY: vy, zoom });
                        }
                        drawMindmapToCtx(tctx, { export: true, viewX: vx, viewY: vy, zoom, canvasW: w, canvasH: h });
                    }
                    return tmp.toDataURL('image/png');
                } catch (e) {
                    return null;
                }
            }

            function pushHistory(desc, type = 'op') {
                // Êà™ÂèñÂΩìÂâçÂø´ÁÖßÔºà‰ªÖÂ∫èÂàóÂåñÂøÖË¶ÅÈÉ®ÂàÜÔºâ
                const snap = {
                    strokes: strokes.map(s => deepClone(s)),
                    mindNodes: deepClone(mindNodes),
                    mindEdges: deepClone(mindEdges),
                    layers: deepClone(layers),
                    currentLayerId
                };
                const entry = { desc, type, ts: Date.now(), snapshot: snap };
                history.push(entry);
                // ÈôêÂà∂ÊúÄÂ§ßÂéÜÂè≤ÈïøÂ∫¶
                if (history.length > MAX_HISTORY) history.shift();
                renderHistoryPanel();
            }

            function renderHistoryPanel() {
                historyListEl.innerHTML = '';
                for (let i = 0; i < history.length; i++) {
                    (function(idx){
                        const entry = history[idx];
                        const row = document.createElement('div');
                        row.style.display = 'flex'; row.style.alignItems = 'center'; row.style.gap = '8px'; row.style.padding = '6px'; row.style.borderBottom = '1px solid #f1f1f1'; row.style.cursor = 'pointer';
                        // color tag for type
                        const tag = document.createElement('div'); tag.style.width = '8px'; tag.style.height = '32px'; tag.style.borderRadius='4px';
                        if (entry.type === 'op') tag.style.background='#6a11cb'; else if (entry.type === 'undo') tag.style.background='#ff9500'; else tag.style.background='#4cd964';
                        row.appendChild(tag);
                        // thumbnail
                        const thumb = document.createElement('img'); thumb.style.width='120px'; thumb.style.height='60px'; thumb.style.objectFit='cover'; thumb.style.border='1px solid #eee'; thumb.style.background='#fff';
                        const dataURL = renderHistoryThumbnail(entry.snapshot, 120, 60);
                        if (dataURL) thumb.src = dataURL; else { thumb.style.display='none'; }
                        row.appendChild(thumb);
                        // desc + ts
                        const meta = document.createElement('div');
                        const title = document.createElement('div'); title.textContent = (idx + 1) + '. ' + entry.desc; title.style.fontSize='12px'; title.style.color='#111';
                        const time = document.createElement('div'); time.textContent = new Date(entry.ts).toLocaleString(); time.style.fontSize='11px'; time.style.color='#777';
                        meta.appendChild(title); meta.appendChild(time);
                        row.appendChild(meta);
                        row.addEventListener('click', function(){ jumpToHistory(idx); });
                        historyListEl.appendChild(row);
                    })(i);
                }
            }

            // jumpToHistory ÊîØÊåÅ‰∏Ä‰∏™ÂèØÈÄâÂèÇÊï∞ optsÔºåÈÅøÂÖçÂú®ÂÜÖÈÉ®Ë∞ÉÁî®Êó∂ÈáçÂ§çËÆ∞ÂΩï undo
            function jumpToHistory(index, opts = { recordUndo: true }) {
                if (index < 0 || index >= history.length) return;
                // Ëã•ÈúÄË¶ÅËÆ∞ÂΩï undo Êìç‰ΩúÔºåÂàôÂÖàÊääÂΩìÂâçÁä∂ÊÄÅ‰Ωú‰∏∫ jumpFrom ‰øùÂ≠òÂà∞ undo Ê†à
                if (opts.recordUndo) {
                    const currSnap = { strokes: deepClone(strokes), mindNodes: deepClone(mindNodes), mindEdges: deepClone(mindEdges), layers: deepClone(layers), currentLayerId };
                    // ‰øùÂ≠ò undo opÔºåÂÖ∂‰∏≠ÂåÖÂê´ÊÅ¢Â§çÂà∞Ë∑≥ËΩ¨ÂâçÁä∂ÊÄÅÁöÑÂø´ÁÖßÔºå‰ª•Âèä redo ÊâÄÈúÄÁöÑÁõÆÊ†áÂø´ÁÖß
                    const targetSnap = deepClone(history[index].snapshot);
                    undoStack.push({ type: 'history-jump', from: currSnap, to: targetSnap });
                    // ÁÇπÂáªÂéÜÂè≤Ë∑≥ËΩ¨‰ºöÊ∏ÖÁ©∫ redo Ê†àÔºà‰øùÊåÅÁ∫øÊÄßÂéÜÂè≤Ôºâ
                    redoStack.length = 0;
                }
                const snap = history[index].snapshot;
                strokes.length = 0; (snap.strokes || []).forEach(s => strokes.push(deepClone(s)));
                mindNodes.length = 0; (snap.mindNodes || []).forEach(n => mindNodes.push(deepClone(n)));
                mindEdges.length = 0; (snap.mindEdges || []).forEach(e => mindEdges.push(deepClone(e)));
                // ÊÅ¢Â§çÂõæÂ±Ç‰ø°ÊÅØ
                if (snap.layers) {
                    layers.length = 0; snap.layers.forEach(l => layers.push(deepClone(l)));
                    currentLayerId = snap.currentLayerId && layers.find(l => l.id === snap.currentLayerId) ? snap.currentLayerId : (layers[0] ? layers[0].id : null);
                    renderLayersPanel();
                }
                invalidateStaticCache();
                redrawCanvas(); updateUndoRedoButtons();
            }

            function deepClone(obj) {
                return JSON.parse(JSON.stringify(obj));
            }

            function strokeEqual(a, b) {
                try { return JSON.stringify(a) === JSON.stringify(b); } catch (e) { return false; }
            }

            function pushStroke(stroke) {
                // ‰ΩøÁî®Ê∑±Êã∑Ë¥ùÔºå‰øùËØÅËÆ∞ÂΩïÁöÑÂø´ÁÖß‰∏ç‰ºöË¢´ÂêéÁª≠‰øÆÊîπÊ±°Êüì
                const s = deepClone(stroke);
                strokes.push(s);
                undoStack.push({ type: 'add', stroke: s });
                redoStack.length = 0;
                pushHistory('Ê∑ªÂä†Á¨îÁîª');
                invalidateStaticCache();
                redrawCanvas();
            }

            function undo() {
                if (undoStack.length === 0) return;
                const op = undoStack.pop();
                // ÊîØÊåÅÂéÜÂè≤Ë∑≥ËΩ¨ÁöÑÊí§ÈîÄ
                // ÊîØÊåÅÂõæÂ±ÇÂà†Èô§ÁöÑÊí§ÈîÄ
                if (op.type === 'layer-delete') {
                    const prev = op.prev || { strokes: [], mindNodes: [], layers: [], currentLayerId: null };
                    const currSnapshot = { strokes: deepClone(strokes), mindNodes: deepClone(mindNodes), layers: deepClone(layers), currentLayerId };
                    // ÊÅ¢Â§ç prev
                    strokes.length = 0; prev.strokes.forEach(s => strokes.push(deepClone(s)));
                    mindNodes.length = 0; prev.mindNodes.forEach(n => mindNodes.push(deepClone(n)));
                    layers.length = 0; (prev.layers || []).forEach(l => layers.push(deepClone(l)));
                    currentLayerId = prev.currentLayerId;
                    renderLayersPanel();
                    // Â∞ÜÈáçÂÅöÊìç‰ΩúÂéãÂÖ• redo
                    redoStack.push({ type: 'layer-delete', prev: currSnapshot, next: deepClone(prev) });
                    invalidateStaticCache(); redrawCanvas(); updateUndoRedoButtons(); pushHistory('Êí§ÈîÄÔºöÂõæÂ±ÇÂà†Èô§/ËøÅÁßª');
                    return;
                }
                if (op.type === 'history-jump') {
                    // ÊÅ¢Â§çË∑≥ËΩ¨ÂâçÁöÑÂø´ÁÖß
                    const prev = op.from || { strokes: [], mindNodes: [], mindEdges: [] };
                    const currSnapshot = { strokes: deepClone(strokes), mindNodes: deepClone(mindNodes), mindEdges: deepClone(mindEdges) };
                    // Â∫îÁî® prev
                    strokes.length = 0; prev.strokes.forEach(s => strokes.push(deepClone(s)));
                    mindNodes.length = 0; prev.mindNodes.forEach(n => mindNodes.push(deepClone(n)));
                    mindEdges.length = 0; prev.mindEdges.forEach(e => mindEdges.push(deepClone(e)));
                    // Â∞ÜÂèØÈáçÂÅöÁöÑÂä®‰ΩúÂéãÂÖ• redoÔºàÊÅ¢Â§çÂà∞Ë∑≥ËΩ¨ÂêéÁöÑÁä∂ÊÄÅÔºâ
                    redoStack.push({ type: 'history-jump', from: currSnapshot, to: op.to ? deepClone(op.to) : currSnapshot });
                    invalidateStaticCache(); redrawCanvas(); updateUndoRedoButtons(); pushHistory('Êí§ÈîÄÔºöÂéÜÂè≤Ë∑≥ËΩ¨');
                    return;
                }
                if (op.type === 'add') {
                    // ÊåâÂÜÖÂÆπÊü•ÊâæÂπ∂ÁßªÈô§ÊúÄÂêé‰∏Ä‰∏™ÂåπÈÖçÁöÑÁ¨îÁîª
                    for (let i = strokes.length - 1; i >= 0; i--) {
                        if (strokeEqual(strokes[i], op.stroke)) {
                            const removed = strokes.splice(i, 1)[0];
                            redoStack.push({ type: 'add', stroke: deepClone(removed) });
                            invalidateStaticCache();
                            redrawCanvas();
                            updateUndoRedoButtons();
                            pushHistory('Êí§ÈîÄÔºöÁßªÈô§Á¨îÁîª');
                            return;
                        }
                    }
                } else if (op.type === 'clear') {
                    // ÊÅ¢Â§ç‰πãÂâçÁöÑÁ¨îÁîª
                    const prev = op.prev || [];
                    const currSnapshot = strokes.map(s => deepClone(s));
                    strokes.length = 0;
                    prev.forEach(p => strokes.push(deepClone(p)));
                    redoStack.push({ type: 'clear', prev: currSnapshot });
                    invalidateStaticCache();
                    redrawCanvas();
                    updateUndoRedoButtons();
                    pushHistory('Êí§ÈîÄÔºöÊÅ¢Â§çÊ∏ÖÁ©∫ÂâçÂÜÖÂÆπ');
                }
            }

            function redo() {
                if (redoStack.length === 0) return;
                const op = redoStack.pop();
                if (op.type === 'layer-delete') {
                    const target = op.next || { strokes: [], mindNodes: [], layers: [], currentLayerId: null };
                    const currSnapshot = { strokes: deepClone(strokes), mindNodes: deepClone(mindNodes), layers: deepClone(layers), currentLayerId };
                    // Â∫îÁî® target
                    strokes.length = 0; (target.strokes || []).forEach(s => strokes.push(deepClone(s)));
                    mindNodes.length = 0; (target.mindNodes || []).forEach(n => mindNodes.push(deepClone(n)));
                    layers.length = 0; (target.layers || []).forEach(l => layers.push(deepClone(l)));
                    currentLayerId = target.currentLayerId;
                    renderLayersPanel();
                    // ÊääÂèçÂêëÂä®‰ΩúÊîæÂõû undo
                    undoStack.push({ type: 'layer-delete', prev: currSnapshot, next: deepClone(target) });
                    invalidateStaticCache(); redrawCanvas(); updateUndoRedoButtons(); pushHistory('ÈáçÂÅöÔºöÂõæÂ±ÇÂà†Èô§/ËøÅÁßª');
                    return;
                }
                // ÊîØÊåÅÂéÜÂè≤Ë∑≥ËΩ¨ÁöÑÈáçÂÅö
                if (op.type === 'history-jump') {
                    const target = op.to || { strokes: [], mindNodes: [], mindEdges: [] };
                    const currSnapshot = { strokes: deepClone(strokes), mindNodes: deepClone(mindNodes), mindEdges: deepClone(mindEdges) };
                    // Â∫îÁî® target
                    strokes.length = 0; target.strokes.forEach(s => strokes.push(deepClone(s)));
                    mindNodes.length = 0; target.mindNodes.forEach(n => mindNodes.push(deepClone(n)));
                    mindEdges.length = 0; target.mindEdges.forEach(e => mindEdges.push(deepClone(e)));
                    // Â∞ÜÂèçÂêëÂä®‰ΩúÊîæÂõû undo
                    undoStack.push({ type: 'history-jump', from: currSnapshot, to: deepClone(target) });
                    invalidateStaticCache(); redrawCanvas(); updateUndoRedoButtons(); pushHistory('ÈáçÂÅöÔºöÂéÜÂè≤Ë∑≥ËΩ¨');
                    return;
                }
                if (op.type === 'add') {
                    strokes.push(deepClone(op.stroke));
                    undoStack.push({ type: 'add', stroke: deepClone(op.stroke) });
                    invalidateStaticCache();
                    redrawCanvas();
                    updateUndoRedoButtons();
                    pushHistory('ÈáçÂÅöÔºöÊÅ¢Â§çÁ¨îÁîª');
                } else if (op.type === 'clear') {
                    const currSnapshot = strokes.map(s => deepClone(s));
                    strokes.length = 0;
                    undoStack.push({ type: 'clear', prev: currSnapshot });
                    invalidateStaticCache();
                    redrawCanvas();
                    updateUndoRedoButtons();
                    pushHistory('ÈáçÂÅöÔºöÊ∏ÖÁ©∫ÁîªÂ∏É');
                }
            }

            // ‰øùÂ≠òÔºöÂ∞ÜÁü¢ÈáèÊ∏≤ÊüìÂà∞‰∏¥Êó∂ canvas ÂØºÂá∫ PNGÔºàÊ≥®ÊÑèÔºöÈÄªËæëÁîªÂ∏ÉÂèØËÉΩÂæàÂ§ßÔºâ
            function saveImage(centerMindmap = false) {
                const temp = document.createElement('canvas');
                const tctx = temp.getContext('2d');
                // ‰øùÊåÅ‰∏éÈÄªËæëÁîªÂ∏ÉÂêåÊ†∑Â§ßÂ∞èÔºà‰øùÊåÅÂêëÂêéÂÖºÂÆπÔºâ„ÄÇÊ≥®ÊÑèÔºöÈÄªËæëÁîªÂ∏ÉÂæàÂ§ßÊó∂ÂØºÂá∫ÂèØËÉΩÊ∂àËÄóÂ§ßÈáèÂÜÖÂ≠ò„ÄÇ
                temp.width = LOGICAL_WIDTH; temp.height = LOGICAL_HEIGHT;
                tctx.fillStyle = 'white'; tctx.fillRect(0, 0, temp.width, temp.height);

                // Â¶ÇÊûúË¶ÅÊ±ÇÂ±Ö‰∏≠ÂØºÂá∫ÔºàËá™Âä®Áº©Êîæ‰ª•ÈÄÇÈÖçËæìÂá∫ÁîªÂ∏ÉÔºâÔºåÊàë‰ª¨ÈúÄË¶Å‰∏∫Á¨îÁîªÂíåÊÄùÁª¥ÂØºÂõæ‰ΩøÁî®Áõ∏ÂêåÁöÑ view/zoom/ÂÅèÁßª„ÄÇ
                if (centerMindmap && mindNodes.length > 0) {
                    // ËÆ°ÁÆóËäÇÁÇπÂíåÁ¨îÁîªÁöÑÂåÖÂõ¥ÁõíÔºàÈÄªËæëÂùêÊ†áÔºâ
                    let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
                    for (let n of mindNodes) {
                        minX = Math.min(minX, n.x - (n.w||120)/2);
                        minY = Math.min(minY, n.y - (n.h||40)/2);
                        maxX = Math.max(maxX, n.x + (n.w||120)/2);
                        maxY = Math.max(maxY, n.y + (n.h||40)/2);
                    }
                    for (let s of strokes) {
                        if (s.points && s.points.length) {
                            for (let p of s.points) { minX = Math.min(minX, p.x); minY = Math.min(minY, p.y); maxX = Math.max(maxX, p.x); maxY = Math.max(maxY, p.y); }
                        } else if (s.start && s.end) {
                            minX = Math.min(minX, s.start.x, s.end.x); minY = Math.min(minY, s.start.y, s.end.y);
                            maxX = Math.max(maxX, s.start.x, s.end.x); maxY = Math.max(maxY, s.start.y, s.end.y);
                        } else if (s.x && s.y) { minX = Math.min(minX, s.x); minY = Math.min(minY, s.y); maxX = Math.max(maxX, s.x); maxY = Math.max(maxY, s.y); }
                    }
                    if (!isFinite(minX)) { minX = 0; minY = 0; maxX = Math.max(200, temp.width); maxY = Math.max(100, temp.height); }

                    // paddingÔºàÈÄªËæëÂçï‰ΩçÔºâ‰∏éÂÆΩÈ´ò
                    const pad = 20;
                    minX -= pad; minY -= pad; maxX += pad; maxY += pad;
                    const sw = maxX - minX; const sh = maxY - minY;

                    // ËÆ°ÁÆóÁº©ÊîæÂõ†Â≠êÔºå‰ΩøÂåÖÂõ¥ÁõíÂú®ÂØºÂá∫ÁîªÂ∏ÉÂÜÖÊúÄÂ§ßÂåñ‰ΩÜÁïôÊúâ‰∏ÄÁÇπËæπË∑ù
                    const scale = Math.min(temp.width / sw, temp.height / sh) * 0.95;

                    // ËßÜÂè£Â∑¶‰∏äËßíÔºàÈÄªËæëÔºâ‰ª•ÂèäÁî®‰∫é drawStrokeToCtx ÁöÑ zoom
                    const vx = minX; const vy = minY; const zoom = scale;

                    // ËÆ°ÁÆóÂÉèÁ¥†ÂÅèÁßªÈáèÔºå‰ΩøÂåÖÂõ¥Áõí‰∏≠ÂøÉ‰Ωç‰∫éÂØºÂá∫ÁîªÂ∏É‰∏≠ÂøÉ
                    const bboxCenterX = (minX + maxX) / 2; const bboxCenterY = (minY + maxY) / 2;
                    const bboxCenterPixelX = (bboxCenterX - vx) * zoom; const bboxCenterPixelY = (bboxCenterY - vy) * zoom;
                    const tempOffsetX = temp.width / 2 - bboxCenterPixelX;
                    const tempOffsetY = temp.height / 2 - bboxCenterPixelY;

                    // Âú®ÁªòÂà∂Á¨îÁîªÊó∂Â∫îÁî®Áõ∏ÂêåÁöÑÂèòÊç¢ÔºàÂπ≥Áßª->Áº©ÊîæÁî± drawStrokeToCtx ÂÜÖÂ§ÑÁêÜÔºâÔºå‰ΩøÁî® canvas translate Êù•Â∫îÁî®ÂÅèÁßª
                    tctx.save();
                    tctx.translate(tempOffsetX, tempOffsetY);
                    // ÊåâÂõæÂ±ÇÈ°∫Â∫èÁªòÂà∂
                    for (let li = 0; li < layers.length; li++) {
                        const layer = layers[li]; if (!layer.visible) continue;
                        for (let i = 0; i < strokes.length; i++) {
                            const s = strokes[i];
                            if (s.layerId !== layer.id) continue;
                            if (!isStrokeVisible(s, vx, vy, sw, sh)) continue;
                            drawStrokeToCtx(tctx, s, { export: true, viewX: vx, viewY: vy, zoom });
                        }
                    }
                    tctx.restore();

                    // ÁªòÂà∂ÊÄùÁª¥ÂØºÂõæÔºà‰ΩøÁî®È¢ÑËÆ°ÁÆóÁöÑÂÅèÁßªÈÅøÂÖçÈáçÂ§çËÆ°ÁÆóÔºâÔºå‰º†ÂÖ•ÂΩìÂâç layers
                    drawMindmapToCtx(tctx, { export: true, viewX: vx, viewY: vy, zoom, canvasW: temp.width, canvasH: temp.height, centerMindmap: true, offsetX: tempOffsetX, offsetY: tempOffsetY, snapLayers: layers });

                    // ÂèØÈÄâÊ∞¥Âç∞
                    applyWatermarkToCtx(tctx, temp.width, temp.height);
                    const dataURL = temp.toDataURL('image/png'); const link = document.createElement('a'); link.download = 'ÊàëÁöÑÁªòÂõæ.png'; link.href = dataURL; link.click();
                    return;
                }

                // ÈªòËÆ§Ë°å‰∏∫ÔºöÊåâÈÄªËæëÂùêÊ†áÊï¥‰ΩìÂØºÂá∫Ôºà‰∏çËøõË°åËá™Âä®Áº©Êîæ/Â±Ö‰∏≠Ôºâ
                // ÈªòËÆ§ÊåâÂõæÂ±ÇÈ°∫Â∫èÁªòÂà∂ÊâÄÊúâÁ¨îÁîª
                for (let li = 0; li < layers.length; li++) {
                    const layer = layers[li]; if (!layer.visible) continue;
                    for (let i = 0; i < strokes.length; i++) {
                        const s = strokes[i]; if (s.layerId !== layer.id) continue;
                        drawStrokeToCtx(tctx, s, { export: true, zoom: 1 });
                    }
                }
                // ÁªòÂà∂ÊÄùÁª¥ÂØºÂõæÔºàÊï¥ÂõæÂØºÂá∫ÈúÄËÄÉËôëÂ±Ö‰∏≠‰∏éÂ≠ó‰ΩìÁº©ÊîæÔºâÔºå‰º†ÂÖ• layers
                drawMindmapToCtx(tctx, { export: true, canvasW: temp.width, canvasH: temp.height, centerMindmap, snapLayers: layers });
                // ÂèØÈÄâÊ∞¥Âç∞
                applyWatermarkToCtx(tctx, temp.width, temp.height);
                const dataURL = temp.toDataURL('image/png'); const link = document.createElement('a'); link.download = 'ÊàëÁöÑÁªòÂõæ.png'; link.href = dataURL; link.click();
            }

            // ‰øùÂ≠òÂΩìÂâçËßÜÂè£ÔºàÂè™ÂØºÂá∫ÂΩìÂâçÂèØËßÅÂå∫ÂüüÔºâ
            function saveViewport() {
                const temp = document.createElement('canvas');
                const tctx = temp.getContext('2d');
                // ÂØºÂá∫Â∞∫ÂØ∏‰∏∫ visible canvas Âú®ÈÄªËæëÂùêÊ†áÁöÑÂ§ßÂ∞è‰πò‰ª•ÂΩìÂâçÁº©Êîæ‰ª•‰øùÁïôÂÉèÁ¥†ÂØÜÂ∫¶
                const vw = Math.ceil(canvas.width);
                const vh = Math.ceil(canvas.height);
                temp.width = vw; temp.height = vh;
                // ÁôΩÂ∫ï
                tctx.fillStyle = 'white'; tctx.fillRect(0, 0, vw, vh);
                // ÁªòÂà∂ strokes Âà∞ tempÔºö‰º†ÂÖ• viewX/viewY ‰∏é zoom ‰∏∫ currentZoom ÁöÑÂèçÂêëÔºàËøôÈáåÊàë‰ª¨ÊääÈÄªËæë -> ËßÜÂè£ Êò†Â∞ÑÔºâ
                // Âè™ÁªòÂà∂ÂèØËßÅÁöÑÁ¨îÁîª‰ª•ËäÇÁúÅÊó∂Èó¥
                // ÊåâÂõæÂ±ÇÈ°∫Â∫èÁªòÂà∂ÂΩìÂâçÂèØËßÅÂõæÂ±Ç‰∏≠ÁöÑÂèØËßÅÁ¨îÁîª
                for (let li = 0; li < layers.length; li++) {
                    const layer = layers[li]; if (!layer.visible) continue;
                    for (let i = 0; i < strokes.length; i++) {
                        const s = strokes[i]; if (s.layerId !== layer.id) continue;
                        if (!isStrokeVisible(s, viewX, viewY, canvas.width / currentZoom, canvas.height / currentZoom)) continue;
                        drawStrokeToCtx(tctx, s, { viewX, viewY, zoom: currentZoom });
                    }
                }
                // ÁªòÂà∂ÊÄùÁª¥ÂØºÂõæÂà∞ÂØºÂá∫ËßÜÂè£Ôºå‰º†ÂÖ• layers
                drawMindmapToCtx(tctx, { export: true, viewX, viewY, zoom: currentZoom, canvasW: temp.width, canvasH: temp.height, snapLayers: layers });
                // ÂèØÈÄâÊ∞¥Âç∞
                applyWatermarkToCtx(tctx, temp.width, temp.height);
                const dataURL = temp.toDataURL('image/png'); const link = document.createElement('a'); link.download = 'viewport.png'; link.href = dataURL; link.click();
            }

            function clearCanvas() {
                if (confirm('Á°ÆÂÆöË¶ÅÊ∏ÖÁ©∫Êï¥‰∏™ÁîªÂ∏ÉÂêóÔºü(ËøôÂ∞ÜÊ∏ÖÁ©∫ÊâÄÊúâÁü¢ÈáèÁ¨îÁîª)')) {
                    // ËÆ∞ÂΩïÂΩìÂâçÂø´ÁÖß‰ª•ÊîØÊåÅÊí§ÈîÄ
                    const prevSnapshot = strokes.map(s => deepClone(s));
                    // ÊâßË°åÊ∏ÖÁ©∫
                    strokes.length = 0; currentStroke = null;
                    // Â∞Ü clear Êìç‰ΩúËÆ∞ÂΩïÂà∞ undo Ê†àÔºåredo Ê∏ÖÁ©∫
                    undoStack.push({ type: 'clear', prev: prevSnapshot });
                    redoStack.length = 0;
                    pushHistory('Ê∏ÖÁ©∫ÁîªÂ∏É');
                    invalidateStaticCache();
                    redrawCanvas();
                    updateUndoRedoButtons();
                }
            }

            // ÊåâÈíÆÁªëÂÆöÔºàÊñ∞Â¢ûÔºâ
            const saveViewportBtn = document.getElementById('saveViewportBtn');
            const undoBtn = document.getElementById('undoBtn');
            const redoBtn = document.getElementById('redoBtn');
            const deleteNodeBtn = document.getElementById('deleteNodeBtn');
            const autoLayoutBtn = document.getElementById('autoLayoutBtn');
            const clearHistoryBtn = document.getElementById('clearHistoryBtn');
            const nodeEditorInput = document.createElement('input');
            nodeEditorInput.type = 'text'; nodeEditorInput.style.position = 'absolute'; nodeEditorInput.style.display = 'none'; nodeEditorInput.style.zIndex = 9999; nodeEditorInput.id = 'nodeEditorInput';
            document.body.appendChild(nodeEditorInput);
            saveBtn.addEventListener('click', function(){
                const doCenter = confirm('ÊòØÂê¶Âú®ÂØºÂá∫Êó∂Â∞ÜÊÄùÁª¥ÂØºÂõæÂ±Ö‰∏≠ÊòæÁ§∫Ôºü\nÁÇπÂáª‚ÄúÁ°ÆÂÆö‚ÄùÔºöÂ±Ö‰∏≠ÂØºÂá∫ÔºõÁÇπÂáª‚ÄúÂèñÊ∂à‚ÄùÔºöÊåâÈÄªËæëÂùêÊ†áÂØºÂá∫„ÄÇ');
                saveImage(doCenter);
            });
            clearHistoryBtn && clearHistoryBtn.addEventListener('click', function(){ if (confirm('Ê∏ÖÁ©∫ÂéÜÂè≤ËÆ∞ÂΩïÔºüÊ≠§Êìç‰ΩúÊó†Ê≥ïÊí§ÈîÄ„ÄÇ')) { history.length = 0; renderHistoryPanel(); invalidateStaticCache(); updateUndoRedoButtons(); } });
            saveViewportBtn.addEventListener('click', saveViewport);
            clearBtn.addEventListener('click', clearCanvas);
            undoBtn.addEventListener('click', undo);
            redoBtn.addEventListener('click', redo);
            deleteNodeBtn.addEventListener('click', function(){ if (selectedNode) deleteSelectedNode(); });
            autoLayoutBtn.addEventListener('click', function(){ autoLayout(); undoStack.push({ type: 'mind-auto-layout', prev: deepClone({ nodes: mindNodes, edges: mindEdges }) }); redoStack.length = 0; updateUndoRedoButtons(); pushHistory('ÊÄùÁª¥ÂØºÂõæÔºöËá™Âä®Â∏ÉÂ±Ä'); });

            // Ê∞¥Âç∞ÂÖÉÁ¥†Â∑≤Â≠òÂú®: watermarkToggle, watermarkText
            function applyWatermarkToCtx(tctx, canvasWidth, canvasHeight) {
                if (!watermarkToggle.checked) return;
                const text = watermarkTextInput.value || '¬©';
                tctx.save();
                tctx.globalAlpha = parseFloat(document.getElementById('watermarkOpacity')?.value || 0.5);
                tctx.fillStyle = 'rgba(0,0,0,0.4)';
                tctx.font = '24px Arial';
                tctx.textAlign = 'right';
                tctx.fillText(text, canvasWidth - 10, canvasHeight - 10);
                tctx.restore();
            }

            // ÈÄâ‰∏≠ËäÇÁÇπ & Âà†Èô§
            let selectedNode = null;
            function selectNode(node) {
                selectedNode = node;
                if (!node) {
                    nodeEditorInput.style.display = 'none';
                    return;
                }
                // Âú®Â±èÂπï‰∏äÊîæÁΩÆÁºñËæëËæìÂÖ•Ê°Ü
                const screenX = (node.x - viewX) * currentZoom + canvas.getBoundingClientRect().left;
                const screenY = (node.y - viewY) * currentZoom + canvas.getBoundingClientRect().top;
                nodeEditorInput.style.left = (screenX - 60) + 'px';
                nodeEditorInput.style.top = (screenY - 12) + 'px';
                nodeEditorInput.style.width = '120px';
                nodeEditorInput.value = node.text || '';
                nodeEditorInput.style.display = 'block';
                nodeEditorInput.focus();
            }

            nodeEditorInput.addEventListener('blur', function(){
                if (selectedNode) {
                    // Â¶ÇÊûúËäÇÁÇπÊâÄÂú®ÂõæÂ±ÇË¢´ÈîÅÂÆöÔºåÂàô‰∏çÂÖÅËÆ∏‰øùÂ≠òÁºñËæë
                    const nodeLayer = layers.find(l => l.id === selectedNode.layerId);
                    if (nodeLayer && nodeLayer.locked) {
                        alert('ËØ•ÂõæÂ±ÇÂ∑≤ÈîÅÂÆöÔºåÁºñËæëÊó†Êïà');
                        nodeEditorInput.style.display = 'none'; selectedNode = null; return;
                    }
                    const prev = deepClone(selectedNode);
                    selectedNode.text = nodeEditorInput.value;
                    undoStack.push({ type: 'mind-edit-node', id: selectedNode.id, prev: prev, next: deepClone(selectedNode) });
                    redoStack.length = 0; updateUndoRedoButtons(); pushHistory('ÊÄùÁª¥ÂØºÂõæÔºöÁºñËæëËäÇÁÇπ'); invalidateStaticCache(); redrawCanvas();
                }
                nodeEditorInput.style.display='none';
            });

            function deleteSelectedNode() {
                if (!selectedNode) return;
                const id = selectedNode.id;
                const prevNodes = deepClone(mindNodes);
                const prevEdges = deepClone(mindEdges);
                // remove node and connected edges
                for (let i = mindNodes.length - 1; i >= 0; i--) if (mindNodes[i].id === id) mindNodes.splice(i,1);
                for (let i = mindEdges.length - 1; i >= 0; i--) if (mindEdges[i].from === id || mindEdges[i].to === id) mindEdges.splice(i,1);
                undoStack.push({ type: 'mind-delete-node', prevNodes, prevEdges });
                redoStack.length = 0; updateUndoRedoButtons();
                pushHistory('ÊÄùÁª¥ÂØºÂõæÔºöÂà†Èô§ËäÇÁÇπ');
                invalidateStaticCache();
                selectedNode = null; nodeEditorInput.style.display = 'none'; redrawCanvas();
            }

            function autoLayout() {
                // ÁÆÄÂçïÁéØÂΩ¢Â∏ÉÂ±Ä
                const centerX = LOGICAL_WIDTH / 2;
                const centerY = LOGICAL_HEIGHT / 2;
                const r = Math.min(LOGICAL_WIDTH, LOGICAL_HEIGHT) / 4;
                const n = mindNodes.length;
                for (let i = 0; i < n; i++) {
                    const a = (i / n) * Math.PI * 2;
                    mindNodes[i].x = centerX + r * Math.cos(a);
                    mindNodes[i].y = centerY + r * Math.sin(a);
                }
                invalidateStaticCache();
                redrawCanvas();
            }

            // Âú® undo/redo ÂèòÂåñÂêéÊõ¥Êñ∞ÊåâÈíÆÂèØÁî®ÊÄß
            function updateUndoRedoButtons() {
                undoBtn.disabled = undoStack.length === 0;
                redoBtn.disabled = redoStack.length === 0;
            }

            // wrap push into helper that updates buttons
            const originalPushStroke = pushStroke;
            pushStroke = function(stroke) { originalPushStroke(stroke); updateUndoRedoButtons(); };

            // mindmap tool bindings: click node with ctrl to start edge create, or drag to move
            function createMindNode(x, y) {
                const node = { id: mindNextId++, x, y, w: 140, h: 48, text: 'Êñ∞ËäÇÁÇπ', layerId: currentLayerId };
                mindNodes.push(node);
                return node;
            }

            function findNodeAtLogical(x, y) {
                for (let i = mindNodes.length - 1; i >= 0; i--) {
                    const n = mindNodes[i];
                    const halfW = (n.w || 120) / 2;
                    const halfH = (n.h || 40) / 2;
                    if (x >= n.x - halfW && x <= n.x + halfW && y >= n.y - halfH && y <= n.y + halfH) return n;
                }
                return null;
            }

            // Âà§Êñ≠Á¨îÁîªÊòØÂê¶ÂíåËßÜÂè£Áõ∏‰∫§ÔºàÁ≤óÁï•ÂåÖÂõ¥ÁõíÔºâ
            function isStrokeVisible(s, vx, vy, vw, vh) {
                if (s.points && s.points.length) {
                    for (let p of s.points) {
                        if (p.x >= vx && p.x <= vx + vw && p.y >= vy && p.y <= vy + vh) return true;
                    }
                    return false;
                }
                if (s.start && s.end) {
                    const minx = Math.min(s.start.x, s.end.x), maxx = Math.max(s.start.x, s.end.x);
                    const miny = Math.min(s.start.y, s.end.y), maxy = Math.max(s.start.y, s.end.y);
                    return !(maxx < vx || minx > vx + vw || maxy < vy || miny > vy + vh);
                }
                if (s.x && s.y) {
                    return s.x >= vx && s.x <= vx + vw && s.y >= vy && s.y <= vy + vh;
                }
                return true;
            }

            // Âú®‰ªªÊÑè ctx ‰∏äÁªòÂà∂ÊÄùÁª¥ÂØºÂõæÔºàÊîØÊåÅÂØºÂá∫ÂíåËßÜÂè£Ê®°ÂºèÔºâ
            function drawMindmapToCtx(tctx, opts = {}) {
                const isExport = !!opts.export;
                const vx = opts.viewX || 0;
                const vy = opts.viewY || 0;
                const zoom = opts.zoom || 1;
                const canvasW = opts.canvasW || (canvas.width);
                const canvasH = opts.canvasH || (canvas.height);
                const centerMindmap = !!opts.centerMindmap;

                // Â¶ÇÊûúË¶ÅÊ±ÇÂ±Ö‰∏≠ÂØºÂá∫ÔºåËÆ°ÁÆóËäÇÁÇπÂåÖÂõ¥ÁõíÂπ∂ÂÜ≥ÂÆö‰∏Ä‰∏™‰∏¥Êó∂ÂÅèÁßªÔºåÁî®‰∫éÁªòÂà∂Âà∞ÂØºÂá∫ÁîªÂ∏É‰∏≠ÂøÉ
                let tempOffsetX = 0, tempOffsetY = 0;
                // Â¶ÇÊûúÂ§ñÈÉ®‰º†ÂÖ•‰∫ÜÈ¢ÑËÆ°ÁÆóÁöÑÂÅèÁßªÔºà‰æãÂ¶Ç saveImageÔºâÔºå‰ºòÂÖà‰ΩøÁî®
                if (typeof opts.offsetX === 'number' && typeof opts.offsetY === 'number') {
                    tempOffsetX = opts.offsetX; tempOffsetY = opts.offsetY;
                } else if (centerMindmap && mindNodes.length > 0) {
                    let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
                    for (let n of mindNodes) {
                        minX = Math.min(minX, n.x - (n.w||120)/2);
                        minY = Math.min(minY, n.y - (n.h||40)/2);
                        maxX = Math.max(maxX, n.x + (n.w||120)/2);
                        maxY = Math.max(maxY, n.y + (n.h||40)/2);
                    }
                    const nodesW = maxX - minX;
                    const nodesH = maxY - minY;
                    // ÁõÆÊ†á‰∏≠ÂøÉÔºàÁîªÂ∏É‰∏≠ÂøÉÔºâÂú®ÂÉèÁ¥†ÂùêÊ†á‰∏≠
                    const canvasCenterX = canvasW / 2;
                    const canvasCenterY = canvasH / 2;
                    // ËÆ°ÁÆóÂΩìÂâçÂåÖÂõ¥Áõí‰∏≠ÂøÉÂú®ÈÄªËæëÂùêÊ†áÁ≥ª‰∏ã
                    const bboxCenterX = (minX + maxX) / 2;
                    const bboxCenterY = (minY + maxY) / 2;
                    // Â∞Ü bboxCenter Êò†Â∞ÑÂà∞ÂØºÂá∫ÂÉèÁ¥†ÂùêÊ†áÔºö (bboxCenter - vx) * zoom
                    const bboxCenterPixelX = (bboxCenterX - vx) * zoom;
                    const bboxCenterPixelY = (bboxCenterY - vy) * zoom;
                    // ÈúÄË¶ÅÁöÑÂÉèÁ¥†ÂÅèÁßªÈáè = canvasCenter - bboxCenterPixel
                    tempOffsetX = canvasCenterX - bboxCenterPixelX;
                    tempOffsetY = canvasCenterY - bboxCenterPixelY;
                }

                // ÊîØÊåÅÊåâÂõæÂ±ÇÁªòÂà∂Ôºö‰ºòÂÖà‰ΩøÁî® opts.snapLayersÔºàÂØºÂá∫/ÂéÜÂè≤Áº©Áï•ÂõæÊèê‰æõÔºâÔºåÂê¶Âàô‰ΩøÁî®ÂÖ®Â±Ä layers
                const useLayers = opts.snapLayers || layers;
                const layerVisible = (layerId) => {
                    if (!useLayers || !useLayers.length) return true;
                    const l = useLayers.find(x => x.id === layerId);
                    return l ? !!l.visible : true;
                };

                for (let li = 0; li < useLayers.length; li++) {
                    const layer = useLayers[li]; if (!layer || !layer.visible) continue;
                    // edges
                    tctx.save();
                    tctx.strokeStyle = '#444';
                    tctx.lineWidth = 2 * zoom;
                    for (let e of mindEdges) {
                        const from = mindNodes.find(n => n.id === e.from);
                        const to = mindNodes.find(n => n.id === e.to);
                        if (!from || !to) continue;
                        // ‰ªÖÂΩìËæπ‰ªª‰∏ÄÁ´ØÁÇπÂ±û‰∫éÂΩìÂâç layer Êó∂ÁªòÂà∂Ôºà‰øùÊåÅÁÆÄÊ¥ÅÔºâ
                        if (from.layerId !== layer.id && to.layerId !== layer.id) continue;
                        if (opts.viewX !== undefined && !((from.x >= vx && from.x <= vx + canvasW/zoom) || (to.x >= vx && to.x <= vx + canvasW/zoom))) continue;
                        const fx = (from.x - vx) * zoom + tempOffsetX;
                        const fy = (from.y - vy) * zoom + tempOffsetY;
                        const tx = (to.x - vx) * zoom + tempOffsetX;
                        const ty = (to.y - vy) * zoom + tempOffsetY;
                        tctx.beginPath(); tctx.moveTo(fx, fy); tctx.lineTo(tx, ty); tctx.stroke();
                    }
                    tctx.restore();

                    // nodes
                    for (let n of mindNodes) {
                        if (n.layerId !== layer.id) continue;
                        if (opts.viewX !== undefined) {
                            if (n.x < vx - 100/zoom || n.x > vx + canvasW/zoom + 100/zoom || n.y < vy - 60/zoom || n.y > vy + canvasH/zoom + 60/zoom) continue;
                        }
                        const nx = (n.x - vx) * zoom + tempOffsetX;
                        const ny = (n.y - vy) * zoom + tempOffsetY;
                        const w = (n.w || 120) * zoom;
                        const h = (n.h || 40) * zoom;
                        tctx.save();
                        tctx.fillStyle = '#fff8dc';
                        tctx.strokeStyle = '#333';
                        tctx.lineWidth = 1;
                        tctx.shadowColor = 'rgba(0,0,0,0.08)'; tctx.shadowBlur = 8;
                        roundRect(tctx, nx - w/2, ny - h/2, w, h, 8 * zoom, true, true);
                        tctx.restore();
                        tctx.save();
                        let baseFont;
                        if (isExport) {
                            const gw = (n.w || 120);
                            baseFont = Math.max(12, Math.min(28, gw / 6));
                        } else {
                            baseFont = Math.max(10, Math.min(24, 14 * zoom));
                        }
                        tctx.fillStyle = '#111';
                        tctx.font = `${baseFont}px Arial`;
                        tctx.textAlign = 'center'; tctx.textBaseline = 'middle';
                        tctx.fillText(n.text || ('ËäÇÁÇπ ' + n.id), nx, ny);
                        tctx.restore();
                    }
                }
            }

            // Shift ‰∏∫ËøûÁ∫øÂø´Êç∑ÈîÆÔºöÊåâ‰∏ã Shift Âπ∂ÁÇπÂáªËäÇÁÇπÂºÄÂßãËøûÁ∫ø
            let shiftEdgeStart = null;

            // ÂΩìÂ∑•ÂÖ∑ÂàáÊç¢Âà∞ mindmap Êó∂ÔºåÂÖÅËÆ∏Âú®ËäÇÁÇπ‰∏äÊåâ Ctrl ÂºÄÂßãËøûÁ∫ø
            canvas.addEventListener('dblclick', function(e) {
                if (currentTool !== 'mindmap') return;
                const [rawX, rawY] = getEventCoordinates(e);
                const [x, y] = screenToLogical(rawX, rawY);
                const n = findNodeAtLogical(x, y);
                if (n) {
                    const nodeLayer = layers.find(l => l.id === n.layerId);
                    if (nodeLayer && nodeLayer.locked) { alert('ËØ•ÂõæÂ±ÇÂ∑≤ÈîÅÂÆöÔºåÊó†Ê≥ïÁºñËæëËäÇÁÇπ'); return; }
                    // ‰øÆÊîπËäÇÁÇπÊñáÊú¨ÔºàÁÆÄÂçïÂÆûÁé∞ÔºöpromptÔºâ
                    const t = prompt('ÁºñËæëËäÇÁÇπÊñáÊú¨Ôºö', n.text || '');
                    if (t !== null) {
                        const prev = deepClone(n);
                        n.text = t;
                        undoStack.push({ type: 'mind-edit-node', id: n.id, prev: prev, next: deepClone(n) });
                        redoStack.length = 0;
                        updateUndoRedoButtons();
                        pushHistory('ÊÄùÁª¥ÂØºÂõæÔºöÁºñËæëËäÇÁÇπ');
                        redrawCanvas();
                    }
                }
            });

            // Âè≥ÈîÆÂú®ËäÇÁÇπ‰∏äÂºÄÂßãÂàõÂª∫ËæπÔºà‰øùÁïôÊóß‰∫§‰∫íÔºâÔºå‰ª•Âèä Shift + ÁÇπÂáª/ÈáäÊîæ Áî®‰∫éÊõ¥Áõ¥ËßÇÁöÑËøûÁ∫ø
            canvas.addEventListener('contextmenu', function(e) {
                if (currentTool !== 'mindmap') return;
                e.preventDefault();
                const [rawX, rawY] = getEventCoordinates(e);
                const [x, y] = screenToLogical(rawX, rawY);
                const n = findNodeAtLogical(x, y);
                if (n) {
                    creatingEdgeFrom = n;
                }
            });

            // Shift ÈîÆËøûÁ∫ø UXÔºömousedown Âú®ËäÇÁÇπ‰∏ä‰∏î shiftKey ÂàôËÆ∞‰∏∫ËøûÁ∫øÂºÄÂßãÔºåmouseup Âú®ÁõÆÊ†áËäÇÁÇπÂàôÂÆåÊàê
            canvas.addEventListener('mousedown', function(e) {
                if (currentTool !== 'mindmap') return;
                const [rawX, rawY] = getEventCoordinates(e);
                const [x, y] = screenToLogical(rawX, rawY);
                if (e.shiftKey) {
                    const n = findNodeAtLogical(x, y);
                    if (n) {
                        shiftEdgeStart = n;
                        creatingEdgeFrom = n;
                    }
                }
            });

            canvas.addEventListener('mouseup', function(e) {
                if (currentTool !== 'mindmap') return;
                if (!shiftEdgeStart) return;
                const [rawX, rawY] = getEventCoordinates(e);
                const [x, y] = screenToLogical(rawX, rawY);
                const target = findNodeAtLogical(x, y);
                if (target && target.id !== shiftEdgeStart.id) {
                    mindEdges.push({ from: shiftEdgeStart.id, to: target.id });
                    undoStack.push({ type: 'mind-add-edge', edge: deepClone({ from: shiftEdgeStart.id, to: target.id }) });
                    redoStack.length = 0; updateUndoRedoButtons(); pushHistory('ÊÄùÁª¥ÂØºÂõæÔºöÊ∑ªÂä†ËøûÁ∫ø');
                    invalidateStaticCache();
                    redrawCanvas();
                }
                shiftEdgeStart = null; creatingEdgeFrom = null;
            });

            // Âø´Êç∑ÈîÆÊâ©Â±ïÔºöCtrl+Z / Ctrl+Y
            document.addEventListener('keydown', function(e) {
                if ((e.ctrlKey || e.metaKey) && e.key.toLowerCase() === 'z') { e.preventDefault(); undo(); }
                if ((e.ctrlKey || e.metaKey) && (e.key.toLowerCase() === 'y' || (e.shiftKey && e.key.toLowerCase() === 'z'))) { e.preventDefault(); redo(); }
            });

            // ÂàùÂßãÊòæÁ§∫
            updateZoomDisplay();
            // ÂàùÂßãÂåñÂéÜÂè≤‰∏éÊí§ÈîÄ/ÈáçÂÅöÊåâÈíÆÁä∂ÊÄÅ
            pushHistory('ÂàùÂßãÁä∂ÊÄÅ');
            updateUndoRedoButtons();
        });
    </script>
</body>
</html>