<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>随机星球地图生成器</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #1a2a6c, #2a5298);
            color: #fff;
            min-height: 100vh;
            overflow: hidden;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }
        
        header {
            text-align: center;
            padding: 20px 0;
            margin-bottom: 20px;
        }
        
        h1 {
            font-size: 2.8rem;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
        }
        
        .subtitle {
            font-size: 1.2rem;
            opacity: 0.8;
        }
        
        .map-container {
            position: relative;
            background-color: rgba(0, 0, 0, 0.3);
            border-radius: 10px;
            overflow: hidden;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
            height: 70vh;
            margin-bottom: 20px;
        }
        
        canvas {
            display: block;
            cursor: grab;
        }
        
        canvas:active {
            cursor: grabbing;
        }
        
        .controls {
            display: flex;
            justify-content: center;
            gap: 15px;
            margin-bottom: 20px;
        }
        
        button {
            padding: 12px 25px;
            background: linear-gradient(to bottom, #3498db, #2980b9);
            color: white;
            border: none;
            border-radius: 50px;
            cursor: pointer;
            font-size: 1rem;
            font-weight: bold;
            transition: all 0.3s ease;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.2);
        }
        
        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 8px rgba(0, 0, 0, 0.3);
            background: linear-gradient(to bottom, #3cb0fd, #3498db);
        }
        
        button:active {
            transform: translateY(0);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }
        
        .zoom-controls {
            position: absolute;
            bottom: 20px;
            right: 20px;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        
        .zoom-btn {
            width: 50px;
            height: 50px;
            border-radius: 50%;
            font-size: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .info-panel {
            background-color: rgba(0, 0, 0, 0.5);
            border-radius: 8px;
            padding: 15px;
            margin-top: 20px;
        }
        
        .info-panel h3 {
            margin-bottom: 10px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.2);
            padding-bottom: 5px;
        }
        
        .locations {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
        }
        
        .location-tag {
            background: linear-gradient(to bottom, #e74c3c, #c0392b);
            padding: 5px 10px;
            border-radius: 20px;
            font-size: 0.9rem;
        }
        
        footer {
            text-align: center;
            margin-top: 30px;
            opacity: 0.7;
            font-size: 0.9rem;
        }
        
        @media (max-width: 768px) {
            h1 {
                font-size: 2rem;
            }
            
            .map-container {
                height: 60vh;
            }
            
            button {
                padding: 10px 20px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>随机星球地图生成器</h1>
            <p class="subtitle">每次刷新都会生成一个全新的世界，包含随机地形和地名</p>
        </header>
        
        <div class="controls">
            <button id="generateBtn">生成新地图</button>
            <button id="resetZoomBtn">重置缩放</button>
        </div>
        
        <div class="map-container">
            <canvas id="mapCanvas"></canvas>
            
            <div class="zoom-controls">
                <button class="zoom-btn" id="zoomIn">+</button>
                <button class="zoom-btn" id="zoomOut">-</button>
            </div>
        </div>
        
        <div class="info-panel">
            <h3>生成地点</h3>
            <div id="locations" class="locations">
                <!-- 地名将在这里动态生成 -->
            </div>
        </div>
        
        <footer>
            <p>探索未知的世界 | 随机生成地图 | 每个世界都是独一无二的</p>
        </footer>
    </div>

    <script>
        // 配置参数
        const config = {
            width: 1200,
            height: 600,
            terrainLevels: {
                deepWater: 0.3,
                shallowWater: 0.4,
                sand: 0.45,
                grass: 0.6,
                forest: 0.7,
                mountain: 0.85,
                snow: 1.0
            },
            colors: {
                deepWater: '#1a237e',
                shallowWater: '#283593',
                sand: '#c8b393',
                grass: '#4caf50',
                forest: '#2e7d32',
                mountain: '#795548',
                snow: '#f5f5f5'
            },
            zoom: {
                min: 0.5,
                max: 3,
                step: 0.2
            }
        };

        // 初始化变量
        let canvas, ctx;
        let noiseMap = [];
        let offsetX = 0, offsetY = 0;
        let scale = 1;
        let isDragging = false;
        let lastX, lastY;
        let locations = [];

        // 地名生成部件
        const nameComponents = {
            prefixes: ['新', '旧', '北', '南', '东', '西', '大', '小', '金', '银', '翡翠', '水晶', '龙', '凤凰', '天空'],
            middles: ['星', '月', '日', '云', '海', '山', '河', '湖', '林', '原', '谷', '泉', '石', '沙', '雾'],
            suffixes: ['之城', '之都', '平原', '山脉', '峡谷', '森林', '湖泊', '沙漠', '岛屿', '海岸', '港口', '村庄', '堡垒', '王国', '领域']
        };

        // 初始化
        window.onload = function() {
            canvas = document.getElementById('mapCanvas');
            ctx = canvas.getContext('2d');
            
            // 设置Canvas大小
            canvas.width = config.width;
            canvas.height = config.height;
            
            // 生成地图
            generateMap();
            
            // 添加事件监听器
            setupEventListeners();
        };

        // 设置事件监听器
        function setupEventListeners() {
            // 生成新地图按钮
            document.getElementById('generateBtn').addEventListener('click', generateMap);
            
            // 重置缩放按钮
            document.getElementById('resetZoomBtn').addEventListener('click', function() {
                scale = 1;
                offsetX = 0;
                offsetY = 0;
                drawMap();
            });
            
            // 缩放按钮
            document.getElementById('zoomIn').addEventListener('click', function() {
                scale = Math.min(scale + config.zoom.step, config.zoom.max);
                drawMap();
            });
            
            document.getElementById('zoomOut').addEventListener('click', function() {
                scale = Math.max(scale - config.zoom.step, config.zoom.min);
                drawMap();
            });
            
            // 鼠标拖动事件
            canvas.addEventListener('mousedown', function(e) {
                isDragging = true;
                lastX = e.clientX;
                lastY = e.clientY;
                canvas.style.cursor = 'grabbing';
            });
            
            canvas.addEventListener('mousemove', function(e) {
                if (isDragging) {
                    const dx = e.clientX - lastX;
                    const dy = e.clientY - lastY;
                    lastX = e.clientX;
                    lastY = e.clientY;
                    
                    offsetX += dx / scale;
                    offsetY += dy / scale;
                    
                    drawMap();
                }
            });
            
            canvas.addEventListener('mouseup', function() {
                isDragging = false;
                canvas.style.cursor = 'grab';
            });
            
            canvas.addEventListener('mouseleave', function() {
                isDragging = false;
                canvas.style.cursor = 'grab';
            });
            
            // 触摸事件支持
            canvas.addEventListener('touchstart', function(e) {
                e.preventDefault();
                isDragging = true;
                lastX = e.touches[0].clientX;
                lastY = e.touches[0].clientY;
            });
            
            canvas.addEventListener('touchmove', function(e) {
                e.preventDefault();
                if (isDragging) {
                    const dx = e.touches[0].clientX - lastX;
                    const dy = e.touches[0].clientY - lastY;
                    lastX = e.touches[0].clientX;
                    lastY = e.touches[0].clientY;
                    
                    offsetX += dx / scale;
                    offsetY += dy / scale;
                    
                    drawMap();
                }
            });
            
            canvas.addEventListener('touchend', function() {
                isDragging = false;
            });
            
            // 鼠标滚轮缩放
            canvas.addEventListener('wheel', function(e) {
                e.preventDefault();
                
                const zoomIntensity = 0.1;
                const mouseX = e.offsetX;
                const mouseY = e.offsetY;
                
                const worldMouseX = (mouseX / scale) - (offsetX / scale);
                const worldMouseY = (mouseY / scale) - (offsetY / scale);
                
                if (e.deltaY < 0) {
                    scale = Math.min(scale + zoomIntensity, config.zoom.max);
                } else {
                    scale = Math.max(scale - zoomIntensity, config.zoom.min);
                }
                
                offsetX = -(worldMouseX * scale - mouseX);
                offsetY = -(worldMouseY * scale - mouseY);
                
                drawMap();
            });
        }

        // 生成新地图
        function generateMap() {
            // 重置偏移和缩放
            offsetX = 0;
            offsetY = 0;
            scale = 1;
            
            // 生成噪声地图
            generateNoiseMap();
            
            // 生成随机地名
            generateLocations();
            
            // 绘制地图
            drawMap();
        }

        // 生成Perlin噪声地图
        function generateNoiseMap() {
            noiseMap = [];
            const noise = new PerlinNoise();
            
            for (let y = 0; y < config.height; y++) {
                noiseMap[y] = [];
                for (let x = 0; x < config.width; x++) {
                    // 使用多个频率的噪声叠加，产生更自然的地形
                    let value = 
                        noise.simplex2(x / 200, y / 200) * 0.5 +
                        noise.simplex2(x / 100, y / 100) * 0.25 +
                        noise.simplex2(x / 50, y / 50) * 0.15 +
                        noise.simplex2(x / 20, y / 20) * 0.1;
                    
                    // 将值从[-1, 1]映射到[0, 1]
                    value = (value + 1) / 2;
                    
                    noiseMap[y][x] = value;
                }
            }
        }

        // 绘制地图
        function drawMap() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // 保存当前状态
            ctx.save();
            
            // 应用平移和缩放
            ctx.translate(offsetX, offsetY);
            ctx.scale(scale, scale);
            
            // 绘制地形
            for (let y = 0; y < config.height; y++) {
                for (let x = 0; x < config.width; x++) {
                    const value = noiseMap[y][x];
                    
                    let color;
                    if (value < config.terrainLevels.deepWater) {
                        color = config.colors.deepWater;
                    } else if (value < config.terrainLevels.shallowWater) {
                        color = config.colors.shallowWater;
                    } else if (value < config.terrainLevels.sand) {
                        color = config.colors.sand;
                    } else if (value < config.terrainLevels.grass) {
                        color = config.colors.grass;
                    } else if (value < config.terrainLevels.forest) {
                        color = config.colors.forest;
                    } else if (value < config.terrainLevels.mountain) {
                        color = config.colors.mountain;
                    } else {
                        color = config.colors.snow;
                    }
                    
                    ctx.fillStyle = color;
                    ctx.fillRect(x, y, 1, 1);
                }
            }
            
            // 绘制地点标记
            drawLocationMarkers();
            
            // 恢复状态
            ctx.restore();
        }

        // 生成随机地名
        function generateLocations() {
            locations = [];
            const numLocations = 15 + Math.floor(Math.random() * 10);
            
            for (let i = 0; i < numLocations; i++) {
                // 确保地点在陆地上
                let x, y, value;
                do {
                    x = Math.floor(Math.random() * config.width);
                    y = Math.floor(Math.random() * config.height);
                    value = noiseMap[y][x];
                } while (value < config.terrainLevels.sand);
                
                // 生成随机名称
                const prefix = nameComponents.prefixes[Math.floor(Math.random() * nameComponents.prefixes.length)];
                const middle = nameComponents.middles[Math.floor(Math.random() * nameComponents.middles.length)];
                const suffix = nameComponents.suffixes[Math.floor(Math.random() * nameComponents.suffixes.length)];
                
                // 随机选择名称结构
                const nameStructures = [
                    `${prefix}${middle}${suffix}`,
                    `${prefix}${middle}`,
                    `${middle}${suffix}`,
                    `${prefix}${suffix}`
                ];
                
                const name = nameStructures[Math.floor(Math.random() * nameStructures.length)];
                
                locations.push({
                    x: x,
                    y: y,
                    name: name,
                    // 根据地势决定地点类型
                    type: value < config.terrainLevels.grass ? '村庄' : 
                          value < config.terrainLevels.forest ? '城镇' : '城市'
                });
            }
            
            // 更新地点列表显示
            updateLocationsList();
        }

        // 绘制地点标记
        function drawLocationMarkers() {
            locations.forEach(location => {
                ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
                ctx.beginPath();
                ctx.arc(location.x, location.y, 4, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.strokeStyle = 'rgba(0, 0, 0, 0.7)';
                ctx.lineWidth = 2;
                ctx.stroke();
                
                // 绘制名称
                ctx.font = '14px Arial';
                ctx.fillStyle = 'white';
                ctx.strokeStyle = 'black';
                ctx.lineWidth = 3;
                ctx.strokeText(location.name, location.x + 8, location.y - 8);
                ctx.fillText(location.name, location.x + 8, location.y - 8);
            });
        }

        // 更新地点列表显示
        function updateLocationsList() {
            const locationsContainer = document.getElementById('locations');
            locationsContainer.innerHTML = '';
            
            locations.forEach(location => {
                const tag = document.createElement('div');
                tag.className = 'location-tag';
                tag.textContent = `${location.name} (${location.type})`;
                locationsContainer.appendChild(tag);
            });
        }

        // Perlin噪声生成器
        class PerlinNoise {
            constructor() {
                this.grad3 = [
                    [1,1,0], [-1,1,0], [1,-1,0], [-1,-1,0],
                    [1,0,1], [-1,0,1], [1,0,-1], [-1,0,-1],
                    [0,1,1], [0,-1,1], [0,1,-1], [0,-1,-1]
                ];
                
                this.p = [];
                for (let i = 0; i < 256; i++) {
                    this.p[i] = Math.floor(Math.random() * 256);
                }
                
                this.perm = [];
                for (let i = 0; i < 512; i++) {
                    this.perm[i] = this.p[i & 255];
                }
            }
            
            dot(g, x, y) {
                return g[0]*x + g[1]*y;
            }
            
            mix(a, b, t) {
                return (1.0-t)*a + t*b;
            }
            
            fade(t) {
                return t*t*t*(t*(t*6.0-15.0)+10.0);
            }
            
            noise(x, y) {
                let X = Math.floor(x);
                let Y = Math.floor(y);
                
                x = x - X;
                y = y - Y;
                
                X = X & 255;
                Y = Y & 255;
                
                const gi00 = this.perm[X+this.perm[Y]] % 12;
                const gi01 = this.perm[X+this.perm[Y+1]] % 12;
                const gi10 = this.perm[X+1+this.perm[Y]] % 12;
                const gi11 = this.perm[X+1+this.perm[Y+1]] % 12;
                
                const n00 = this.dot(this.grad3[gi00], x, y);
                const n10 = this.dot(this.grad3[gi10], x-1, y);
                const n01 = this.dot(this.grad3[gi01], x, y-1);
                const n11 = this.dot(this.grad3[gi11], x-1, y-1);
                
                const u = this.fade(x);
                const v = this.fade(y);
                
                const nx0 = this.mix(n00, n10, u);
                const nx1 = this.mix(n01, n11, u);
                
                return this.mix(nx0, nx1, v);
            }
            
            simplex2(xin, yin) {
                const F2 = 0.5*(Math.sqrt(3.0)-1.0);
                const G2 = (3.0-Math.sqrt(3.0))/6.0;
                
                let n0, n1, n2;
                
                const s = (xin+yin)*F2;
                const i = Math.floor(xin+s);
                const j = Math.floor(yin+s);
                const t = (i+j)*G2;
                const X0 = i-t;
                const Y0 = j-t;
                const x0 = xin-X0;
                const y0 = yin-Y0;
                
                let i1, j1;
                if(x0>y0) { i1=1; j1=0; } else { i1=0; j1=1; }
                
                const x1 = x0 - i1 + G2;
                const y1 = y0 - j1 + G2;
                const x2 = x0 - 1.0 + 2.0 * G2;
                const y2 = y0 - 1.0 + 2.0 * G2;
                
                const ii = i & 255;
                const jj = j & 255;
                const gi0 = this.perm[ii+this.perm[jj]] % 12;
                const gi1 = this.perm[ii+i1+this.perm[jj+j1]] % 12;
                const gi2 = this.perm[ii+1+this.perm[jj+1]] % 12;
                
                let t0 = 0.5 - x0*x0-y0*y0;
                if(t0 < 0) n0 = 0.0;
                else {
                    t0 *= t0;
                    n0 = t0 * t0 * this.dot(this.grad3[gi0], x0, y0);
                }
                
                let t1 = 0.5 - x1*x1-y1*y1;
                if(t1 < 0) n1 = 0.0;
                else {
                    t1 *= t1;
                    n1 = t1 * t1 * this.dot(this.grad3[gi1], x1, y1);
                }
                
                let t2 = 0.5 - x2*x2-y2*y2;
                if(t2 < 0) n2 = 0.0;
                else {
                    t2 *= t2;
                    n2 = t2 * t2 * this.dot(this.grad3[gi2], x2, y2);
                }
                
                return 70.0 * (n0 + n1 + n2);
            }
        }
    </script>
</body>
</html>