<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>绘图工具 - 改进版</title>
    <style>
        /* 样式保持不变，因为CSS部分已经相对合理 */
        /* 为节省空间，这里省略CSS部分，实际使用时需要保留完整的CSS */
    </style>
</head>
<body>
    <!-- HTML结构保持不变 -->
    <div class="container">
        <!-- 省略HTML结构，实际使用时需要保留完整的HTML结构 -->
    </div>

    <script>
        // ===============================
        // 改进点1：配置常量
        // ===============================
        const CONFIG = {
            LOGICAL_WIDTH: 16000,
            LOGICAL_HEIGHT: 9000,
            MAX_HISTORY: 200,
            GRID_SIZE: 20,
            ZOOM_RANGE: { min: 0.2, max: 5 },
            BRUSH_SIZE_RANGE: { min: 1, max: 50 },
            FONT_SIZE_RANGE: { min: 10, max: 72 }
        };

        // ===============================
        // 改进点2：工具类定义 - 模块化设计
        // ===============================
        class DrawingApp {
            constructor() {
                this.canvas = document.getElementById('drawingCanvas');
                this.ctx = this.canvas.getContext('2d');
                this.state = this.initializeState();
                this.ui = this.initializeUI();
                this.setupEventListeners();
                this.setupCanvas();
            }

            initializeState() {
                return {
                    currentTool: 'pencil',
                    currentColor: '#000000',
                    currentZoom: 1,
                    viewX: 0, viewY: 0,
                    isDrawing: false, isPanning: false,
                    strokes: [], currentStroke: null,
                    mindNodes: [], mindEdges: [],
                    layers: [], currentLayerId: null,
                    undoStack: [], redoStack: [], history: [],
                    // 性能优化相关
                    staticCache: document.createElement('canvas'),
                    staticCacheCtx: null,
                    staticCacheValid: false,
                    scheduled: false
                };
            }

            // ===============================
            // 改进点3：初始化方法
            // ===============================
            setupCanvas() {
                this.state.staticCacheCtx = this.state.staticCache.getContext('2d');
                this.updateCanvasSize();
                window.addEventListener('resize', () => this.updateCanvasSize());
                this.createLayer('默认图层');
                this.redrawCanvas();
            }

            updateCanvasSize() {
                const container = this.canvas.parentElement;
                const newWidth = Math.max(300, container.clientWidth);
                const newHeight = Math.max(200, container.clientHeight);
                this.canvas.width = newWidth;
                this.canvas.height = newHeight;
                this.invalidateStaticCache();
                this.redrawCanvas();
            }

            // ===============================
            // 改进点4：性能优化 - 静态缓存和批量重绘
            // ===============================
            invalidateStaticCache() {
                this.state.staticCacheValid = false;
                this.scheduleRedraw();
            }

            scheduleRedraw() {
                if (this.state.scheduled) return;
                this.state.scheduled = true;
                requestAnimationFrame(() => {
                    this.state.scheduled = false;
                    this.redrawCanvas();
                });
            }

            redrawCanvas() {
                // 简化的重绘逻辑，实际需要完整实现
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                this.drawBackground();
                this.drawStaticContent();
                this.drawDynamicContent();
            }

            drawBackground() {
                this.ctx.fillStyle = this.state.backgroundColor || '#ffffff';
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                this.drawGrid();
            }

            drawGrid() {
                const gridSize = CONFIG.GRID_SIZE;
                this.ctx.save();
                this.ctx.strokeStyle = '#f0f0f0';
                this.ctx.lineWidth = 1;

                const startX = Math.floor(this.state.viewX / gridSize) * gridSize;
                const startY = Math.floor(this.state.viewY / gridSize) * gridSize;
                const endX = this.state.viewX + this.canvas.width / this.state.currentZoom + gridSize;
                const endY = this.state.viewY + this.canvas.height / this.state.currentZoom + gridSize;

                this.ctx.beginPath();
                for (let x = startX; x < endX; x += gridSize) {
                    const sx = (x - this.state.viewX) * this.state.currentZoom;
                    this.ctx.moveTo(sx, (startY - this.state.viewY) * this.state.currentZoom);
                    this.ctx.lineTo(sx, (endY - this.state.viewY) * this.state.currentZoom);
                }
                for (let y = startY; y < endY; y += gridSize) {
                    const sy = (y - this.state.viewY) * this.state.currentZoom;
                    this.ctx.moveTo((startX - this.state.viewX) * this.state.currentZoom, sy);
                    this.ctx.lineTo((endX - this.state.viewX) * this.state.currentZoom, sy);
                }
                this.ctx.stroke();
                this.ctx.restore();
            }

            // ===============================
            // 改进点5：图层系统
            // ===============================
            createLayer(name) {
                const id = 'layer_' + Date.now() + '_' + Math.floor(Math.random() * 1000);
                const layer = {
                    id,
                    name: name || '图层 ' + (this.state.layers.length + 1),
                    visible: true,
                    locked: false,
                    color: '#ffffff',
                    image: null
                };
                this.state.layers.push(layer);
                if (!this.state.currentLayerId) this.state.currentLayerId = id;
                this.renderLayersPanel();
                return layer;
            }

            removeLayer(id) {
                const idx = this.state.layers.findIndex(l => l.id === id);
                if (idx === -1) return false;
                
                // 记录删除前的状态用于撤销
                const prevSnapshot = this.createSnapshot();
                
                // 迁移或删除元素
                const migrateTo = this.promptForMigration(id);
                if (migrateTo) {
                    this.migrateLayerElements(id, migrateTo);
                } else {
                    this.deleteLayerElements(id);
                }
                
                this.state.layers.splice(idx, 1);
                if (this.state.currentLayerId === id) {
                    this.state.currentLayerId = this.state.layers.length ? this.state.layers[0].id : null;
                }
                
                this.renderLayersPanel();
                this.pushHistory('删除图层', 'layer-delete', prevSnapshot);
                this.invalidateStaticCache();
                return true;
            }

            // ===============================
            // 改进点6：错误处理和边界情况
            // ===============================
            handleDrawingStart(e) {
                try {
                    if (this.state.currentTool === 'text') {
                        this.showTextInput(e);
                        return;
                    }
                    
                    if (this.state.currentTool === 'pan') {
                        this.startPanning(e);
                        return;
                    }
                    
                    if (this.state.currentTool === 'mindmap') {
                        this.handleMindmapClick(e);
                        return;
                    }

                    const [x, y] = this.screenToLogical(...this.getEventCoordinates(e));
                    
                    // 检查当前图层是否锁定
                    const currentLayer = this.state.layers.find(l => l.id === this.state.currentLayerId);
                    if (currentLayer && currentLayer.locked) {
                        this.showNotification('当前图层已锁定，无法绘制');
                        return;
                    }

                    this.startDrawingStroke(x, y);
                    
                } catch (error) {
                    console.error('绘图开始错误:', error);
                    this.showNotification('绘图过程中出现错误');
                }
            }

            // ===============================
            // 改进点7：工具方法
            // ===============================
            screenToLogical(rawX, rawY) {
                return [
                    this.state.viewX + rawX / this.state.currentZoom,
                    this.state.viewY + rawY / this.state.currentZoom
                ];
            }

            getEventCoordinates(e) {
                let clientX, clientY;
                if (e.type && e.type.includes('touch')) {
                    clientX = e.touches[0].clientX;
                    clientY = e.touches[0].clientY;
                } else {
                    clientX = e.clientX;
                    clientY = e.clientY;
                }
                const rect = this.canvas.getBoundingClientRect();
                return [clientX - rect.left, clientY - rect.top];
            }

            // ===============================
            // 改进点8：撤销/重做系统
            // ===============================
            pushHistory(description, type = 'operation', snapshot = null) {
                const entry = {
                    description,
                    type,
                    timestamp: Date.now(),
                    snapshot: snapshot || this.createSnapshot()
                };
                
                this.state.history.push(entry);
                if (this.state.history.length > CONFIG.MAX_HISTORY) {
                    this.state.history.shift();
                }
                
                this.renderHistoryPanel();
            }

            createSnapshot() {
                return {
                    strokes: this.deepClone(this.state.strokes),
                    mindNodes: this.deepClone(this.state.mindNodes),
                    mindEdges: this.deepClone(this.state.mindEdges),
                    layers: this.deepClone(this.state.layers),
                    currentLayerId: this.state.currentLayerId
                };
            }

            deepClone(obj) {
                try {
                    return JSON.parse(JSON.stringify(obj));
                } catch (error) {
                    console.error('深拷贝错误:', error);
                    return obj;
                }
            }

            // ===============================
            // 改进点9：用户界面方法
            // ===============================
            showNotification(message, type = 'info') {
                // 实现一个简单的通知系统
                const notification = document.createElement('div');
                notification.style.cssText = `
                    position: fixed;
                    top: 20px;
                    right: 20px;
                    padding: 12px 20px;
                    background: ${type === 'error' ? '#ff4444' : type === 'warning' ? '#ffaa00' : '#44aa44'};
                    color: white;
                    border-radius: 5px;
                    z-index: 10000;
                    box-shadow: 0 2px 10px rgba(0,0,0,0.2);
                `;
                notification.textContent = message;
                document.body.appendChild(notification);
                
                setTimeout(() => {
                    if (notification.parentNode) {
                        notification.parentNode.removeChild(notification);
                    }
                }, 3000);
            }

            // ===============================
            // 改进点10：事件监听器设置
            // ===============================
            setupEventListeners() {
                // 绘图事件
                this.canvas.addEventListener('mousedown', (e) => this.handleDrawingStart(e));
                this.canvas.addEventListener('mousemove', (e) => this.handleDrawingMove(e));
                window.addEventListener('mouseup', (e) => this.handleDrawingEnd(e));
                
                // 触摸事件
                this.canvas.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    this.handleDrawingStart(e);
                }, { passive: false });
                
                this.canvas.addEventListener('touchmove', (e) => {
                    e.preventDefault();
                    this.handleDrawingMove(e);
                }, { passive: false });
                
                window.addEventListener('touchend', (e) => {
                    e.preventDefault();
                    this.handleDrawingEnd(e);
                }, { passive: false });

                // 键盘事件
                document.addEventListener('keydown', (e) => this.handleKeyDown(e));
                document.addEventListener('keyup', (e) => this.handleKeyUp(e));

                // 缩放事件
                this.canvas.addEventListener('wheel', (e) => this.handleWheel(e));
            }

            // 简化的其他方法实现...
            initializeUI() {
                // 返回UI元素引用
                return {
                    brushSize: document.getElementById('brushSize'),
                    brushSizeValue: document.getElementById('brushSizeValue'),
                    // 其他UI元素...
                };
            }

            renderLayersPanel() {
                // 图层面板渲染逻辑
            }

            renderHistoryPanel() {
                // 历史面板渲染逻辑
            }

            drawStaticContent() {
                // 绘制静态内容
            }

            drawDynamicContent() {
                // 绘制动态内容
            }

            // 其他必要的方法...
        }

        // ===============================
        // 改进点11：应用初始化
        // ===============================
        document.addEventListener('DOMContentLoaded', function() {
            try {
                const app = new DrawingApp();
                window.drawingApp = app; // 便于调试
                console.log('绘图工具初始化成功');
            } catch (error) {
                console.error('绘图工具初始化失败:', error);
                alert('绘图工具初始化失败，请刷新页面重试');
            }
        });

        // ===============================
        // 改进点12：工具函数库
        // ===============================
        const Utils = {
            // 防抖函数
            debounce(func, wait) {
                let timeout;
                return function executedFunction(...args) {
                    const later = () => {
                        clearTimeout(timeout);
                        func(...args);
                    };
                    clearTimeout(timeout);
                    timeout = setTimeout(later, wait);
                };
            },

            // 节流函数
            throttle(func, limit) {
                let inThrottle;
                return function(...args) {
                    if (!inThrottle) {
                        func.apply(this, args);
                        inThrottle = true;
                        setTimeout(() => inThrottle = false, limit);
                    }
                };
            },

            // 颜色工具
            hexToRgb(hex) {
                const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
                return result ? {
                    r: parseInt(result[1], 16),
                    g: parseInt(result[2], 16),
                    b: parseInt(result[3], 16)
                } : null;
            },

            // 坐标转换工具
            clamp(value, min, max) {
                return Math.min(Math.max(value, min), max);
            }
        };
    </script>
</body>
</html>
